<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[文章索引]]></title>
    <url>%2F2033%2Fpost-index%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-10-17 这是一篇索引. 因为我还不太想去折腾置顶的东西，所以手动置顶. 日期含义是Metro2033+洛天依生日. 关于 闲聊 游戏 计算机科学上网 | GFW与SSR简介 Chrome浏览器 | 插件与设置 Windows软件快速指南 编程PyQt5上手指南 VSCode配置Python环境及Python入门学习 从零开始的C++学习 C++STL的OI常用内容 技术Hexo博客搭建及material主题使用指南 Github Pages+HTML5 up制作个人主页及绑定二级域名 写作《意识宇宙》 我接触及学习编程的经历 数学「数论」 「概率期望」 「莫比乌斯反演」 算法「动态规划」 「FFT/NTT」「多项式」 「线段树」 「网络流」 「分层图」 「后缀数组」]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用jsDelivr+PicGo对图片进行cdn加速]]></title>
    <url>%2F2020%2Fcdn%2F</url>
    <content type="text"><![CDATA[GitHub Pages上图片的访问速度不佳，而且使用不便，现在来用GitHub+jsDelivr+PicGo解决这个问题。 一、新建GitHub仓库 二、生成token，保存 三、下载PicGo，安装使用手册：https://picgo.github.io/PicGo-Doc/zh 四、配置PicGo 五、使用直接引用使用方法：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 如果不写版本号，将直接引用最新版 其它：如果需要使用版本号就在release发布，一次不超过50MB。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>jsDelivr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些metagame的介绍与浅谈游玩体验]]></title>
    <url>%2F2020%2Fmetagame%2F</url>
    <content type="text"><![CDATA[大坑，会填的 下面所有游戏的共同点是将游戏玩家作为游戏本身的参与者而不是操控者。 Ever17 —the out of infinity— ：AVG/galgame，科幻悬疑，设定不是太科学，前期流程非常冗长无趣，主要体验最后解密快感。 Doki Doki Literature Club 心跳文学部：AVG/galgame，剧情简短单薄，主要体验闪屏快感，从未见过的吓人方式。 君与彼女与彼女之恋：AVG/galgame，极其恶劣的作品，部分精神污染极其严重，不要轻易尝试，有画面反色，文件修改等内容。前期的画面非常不错，淡色且偏水彩风格，适合养生看风景，一些设定让你一度以为这是个科幻故事。 Undertale：RPG游戏，没有玩过，如果我玩的话会当成普通RPG体验。 Oneshot：冒险解谜游戏，一周目通关，解谜方式很新颖，没有在别的游戏里见过。二周目更精彩，还没有玩。 Icey艾希：横版动作游戏，没有玩过，偏重于计算机方面的设定，平面砍杀，类似于空洞骑士。 史丹利的寓言：冒险解谜游戏，部分人玩会有不安的感觉，本身内容不算太多，更多只是表现了一些哲学意义。 总的来说能带来很多非常不好的体验，适合找刺激的玩家。]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>metagame</tag>
        <tag>galgame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人价值与集体价值的统一性]]></title>
    <url>%2F2020%2Fmarxist_philosophy_1%2F</url>
    <content type="text"><![CDATA[个人价值与集体价值的统一性 ​ 出生于21世纪初的中国人，面临着市场经济的全面到来以及个人主义价值观的输入，同时经历着传统马克思主义哲学以及阶级史观的教育，产生了更加复杂、不同于以往的思想。 从社会生活的社会生活中即可窥见其现象：当前很多学生崇尚自由。要学习街舞、各种各样的艺术，要有个性，打扮要与众不同，要生活随性，要有“仪式感”与“小确幸”。这一类人更多崇尚个人价值的实现与生活自由的实现。 ​ 更加多的一部分人是无法做到这样的自由的：保家卫国的解放军、山火中悄然逝去的消防员、从事科研事业的科学家、兢兢业业的基础设施工人。当他们完成了对社会的建设与保护，为集体价值做出了奉献，却没有资格崇尚个人的自由。可以看到，有了一部分人的自由，就没有了大多数人的自由。 ​ 这样一部分人是只注重的自己的自由，他们更希望别人不自由，让自己好自由，做到了“心中有我”，还觉得是自己创造了社会价值，自己是社会的后浪。当然，也可以观察到，绝大部分人仍然感动于默默无闻、辛辛苦苦奉献的人，他们也明白是这一部分人让他们自由，让他们有了实现个人价值的机会，更加感动于“心中无我”的境界，他们更加矛盾，为什么劳动、奉献、付出是正确的，周围的人、周围的事总是不让自己成为这样的人。 ​ 这是一个崇尚英雄的时代，传统的教育和意识形态影响让我们没有忘记新中国的根是什么，我们仍然知道社会生产的基础仍然是工人与无产阶级，但是近四十年的现实却让我们不断怀疑这些。要知道，崇尚英雄的时代只是最近的时代，是靠宣传力量才勉强实现的。几年前推崇歌颂马云等资本家、抹黑英雄人物的思想层出不穷，这是由资本主义生产方式的现实决定的意识。人们笃信着用成功学就能实现个人价值的实现，并为之践行。 ​ 现在更多的人发现自由从来不属于他们，成功是资本家的成功，自己只是奉献剩余价值还叫好、叫着自己多自由的一无所有的人。他们不禁怀疑什么才是对的，并开始关心英雄人物，思考是谁给了他们生存的条件。他们就是既崇尚自由又崇尚英雄的人。以前的人更加关心集体价值，忽视了个体存在的价值。后来的人更关心自己，忽视集体的作用。现在的人才意识到，先关心集体价值，才有实现自己的自由与个人价值的可能性。 ​ 可以看到任何个人价值的实现都以集体价值的实现为前提。举几个例子：没有阿里巴巴所有程序员的工作不会有马云的成功，没有消防员，解放军，医生等社会基础职业的人的工作就没有其他人安全生存的条件，没有整个社会生产活动的进行，就没有具体到个人的享受生活的条件。这样来看，个人价值依附于集体价值，个人价值与集体价值实质上是统一的。 ​ 就像大海上后浪接着前浪，浪花下面才是深不见底的海水与底层的岩石，没有这些就没有后浪。没有集体价值的实现就不会有个人价值的实现，先做到“心中无我”，才能有“心中有我“。只做到“心中有我”，只能是建立在剥削他人之上的个人自由。先做到了“心中无我”，最终才能实现人人都能“心中有我”。]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>马哲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我接触及学习编程的经历]]></title>
    <url>%2F2020%2Fabout-program%2F</url>
    <content type="text"><![CDATA[想来自己接触编程的时间真的不算短了，也是三年多了，但是没有学会太多的知识吧，也没有写出什么有价值的文章，追究起原因，一是自己意志不够坚定，没有坚持在闲暇的时候学习，想必都是贡献给游戏和b站了，自己也一直缺少主观的动力去努力学习，二是自己实践得少，走马观花看得多，导致自己编程就容易陷入困难。但是编程的确是我一直喜欢的一项事物，在这里我想记录一下几年的编程学习以及我犯下的错误吧。 20162016年快要到了末尾，初中同学总是与我聊起些计算机方面的话题，不过仅限于些硬件，ps之类的平淡无奇的东西罢了，我也没什么动力去学习编程，尽管前几年一直对此方面非常感兴趣，也有意向去尝试，可我的确是一个不敢勇于尝试，也就是不愿跨出第一步去接触新事物罢了吧。 不过有一天，一位同学给我看了一本书：《零基础学C语言》，据他所说仅仅是在书店买了一本，我看了看觉得不算很难，正巧当时在知乎看了一些编程的问题，也有兴趣学C语言，就顺理成章的买了一本，的确算不上一流的教材，不过庆幸的是我没有选择谭浩强之类的时代产物，也没有去看至于到诸如《C primer plus》等可能略微劝退14岁的我的书籍。现在依稀记得对于反码补码之类的东西理解有一些难度，不过还是很有兴趣的看完了，也写出了第一个Hello world，不过写代码是很少的，我也不知道为什么，不过我的确是把大部分时间花在看书上了。 2017书自然是看完了，可是会写多少了吗？恐怕不是的。而后呢？自然没有多大的兴趣，只记得自己把书看懂了，后来也没有写过几次C语言罢了，曾经安装过python环境，也没有去写。 暑假的时候，决定想学一学OI，自然开始看C++，因为比较底层的内容比如指针和二进制编码理解的还比较好所以几乎没什么阻力，当然没有去学oop，然后就开始写写简单的OI题，看看数论，算法的过活，但是的确是非常水，贡献了很多时间给MC，b站之类的，于是到11月连dfs也写不熟练。就是这样去普及组水了个1=，当然本身也得顾及学习，况且是开学后才开始学算法的。 之后迅速失去兴趣，并投入大量时间给steam，半年没写代码。主要原因是没什么目的，也没接去接触开源社区，不太明白怎么用网络学习新技术。归根结底还是动力和兴趣不足。 2018从四月开始到年底的时间都花在了OI上，主要是学了大量的算法和数据结构，以及一些C++。最后11月提高组喜获2=，这一年没什么想法，除了C++别的语言几乎没有写过。 2019今年主要还是OI，五月份的时候搭了搭博客，然后这时候觉得翻墙还是方便一点，时间不太允许自己搭，于是找了个ssr机场，才开始真正用好了一些工具。暑假开始便清楚OI只能拿个1=，加上一直算法学习难度对我而言也是比较大，逐渐也就失去了热情，放弃了联赛之上比赛内容的学习。主要是保持每天做一些动态规划的题，学了更多自己喜欢的算法，不是联赛内容的算法学会后直接放弃继续做题，在学校剩下的时间便用来学了学C++的oop，C#，python，一些前端，看了一些计算机的理论，不过重心肯定在OI上，这些只作为了一些消遣般的活动，投入时间也不多，所以知识水平并不高。 最后11月喜获某不存在比赛的1=，基本是我真实水平了，这个没什么好说的。只能放弃OI。退役后闲暇时间学了一些汇编，但是没有自己写过。 2020这一年可能不会再有太多时间写代码了，放假的时候应该还是会看看编程相关的内容。 现在主要想学好C++，C#、python也喜欢。到是有兴趣去学一些unity。不过这些事还是可能得放在放假的时候去做。 结尾事到如今所有事都已成定局了，学OI也给我的算法水平带来了很大的提升吧，当然主要还是上网时间多了接触到了更多编程相关的内容和技术。]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>经历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows软件快速指南]]></title>
    <url>%2F2019%2Fsoftware%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019.10.28 断断续续写了一点自己了解过的软件，会一直更新 IDE及编辑器Visual Studio Code：编辑器，可以安装插件，实现对多种语言的支持 Visual Studio：大型IDE，主要用于C++开发，对C#、Visual Basic支持较好 Notepad++：高配版记事本，速度快，适合编辑多种文件，支持代码高亮 Subline：编辑器，支持插件 Vim：编辑器，独特的键盘指令及操作可以提高效率 Eclipse：IDE，用于Java开发，可以安装插件支持其他语言 Atom：GitHub开发的编辑器，比较漂亮，支持插件 JetBrains系列：IntelliJ、CLion、PyCharm 系统安全及工具火绒：比较舒服的安全工具，没有流氓行为 Mem Reduct：清理内存 CCleaner：清理硬盘垃圾文件 DiskGenius：复杂分区操作，磁盘修复 文件管理Listary：全硬盘文件搜索，界面类型及功能多样，适合日常使用 Everything：全硬盘文件搜索，功能更加专一，适合复杂文件操作 7-Zip：最好用的压缩软件，算法一流 FastCopy：快速拷贝文件，比Windows系统快 系统美化及桌面整理Fences：桌面整理，效果很漂亮，支持扩展出多桌面 Rolan：桌面轻量级收纳工具 Startisback：让任务栏透明吧 WallpaperEngine：让桌面壁纸动起来吧 SAO-Utils：模拟刀剑神域的界面 Live2dViewerEX：让live2d小人站在桌面上吧 TrafficMonitor：显示网速、CPU及内存的悬浮窗，支持更换皮肤 IM（即时通讯）TIM：QQ简化版本 Telegram：电报桌面版 Skype：微软的软件 硬件检测卡硬工具箱：常用的各种工具都包括了，例如CPU-Z，GPU-Z，SSD测速，硬盘检测等 aida64：硬件检测工具 工作及生活Chrome：Google开发的浏览器 Firefox：火狐浏览器 potplayer：音视频播放器，可以更换皮肤，清爽流畅 Bandicam：录屏软件 Vieas：图片查看器，打开速度更快，还可简单编辑图片 OneNote：记笔记神器，功能全面，网页剪取较好用 OneDrive：微软云盘，存点随时用的文档 印象笔记：经典笔记软件 文本排版和数学Typora：Markdown编辑器 Moeditor：Markdown编辑器 LaTeX：排版及数学公式工具 Matlab：数学计算及数学 Mathematica：数学计算及数学 GraphViz：图论 geogebra：数学 几何画板：几何 游戏Steam：Valve的游戏发行平台 Uplay：育碧发行平台 origin：EA发行平台 SSTap：用于境外服务器线路加速 Fraps：显示帧数 BakaXL：好看的MC启动器 梯子及暗网Shadowsocks：ss ShadowsocksR：ssr V2Ray Brook Tor浏览器：洋葱浏览器 编程工具terminus：很漂亮的一个终端 Git：版本控制 以下内容待更新 微软系列Word、 Adobe系列Photoshop： 艺术设计工具C4D： Blender： ACGNMMD： Vocaloid：]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyQt5上手指南]]></title>
    <url>%2F2019%2Fpyqt%2F</url>
    <content type="text"><![CDATA[学习前提是需要对Python有一定的基础。 首先我们需要安装。 打开powershell输入： pip install pyqt5-tools 安装完毕后输入： designer 稍等，会弹出页面，如图所示： 现在创建一个MainWindow窗口，并进行编辑，如图所示： 默认的编辑模式是： 这是用来拖动控件的，上方的TextLabel是显示信息用的Label控件，空白的地方是用来输入信息或者显示信息的Text Edit控件，PushButton是能对点击操作发出信号的Push Button控件。 左侧的其他控件可以试试并查询功能。 控件上面的文本和窗口标题文本都可以通过右侧的此窗口修改： 现在我们切换到信号操作上： 试一试点击一个控件后拖动，这是你可以选择信号发送到其他控件或者是窗口本身。 因为信号所对应的命令还需要我们自己书写，所以我们随便指定一个命令： 这个操作的含义是当点击时关闭窗口。 现在是这样的，那么我们保存一下编辑好的界面。 打开VSCode，进入保存文件的路径，我们需要把保存的.ui文件转换成.py文件以便接下来的操作。 在终端里运行： pyuic5 FileName.ui -o FileName.py 现在我们重新配置一下settings.js文件以避免一些插件检测语法上的错误 settings.js{ &quot;python.pythonPath&quot;: &quot;C:/Users/UserName/AppData/Local/Programs/Python/Python37-32/python.exe&quot;,//选择安装路径 &quot;python.linting.pylintArgs&quot;: [ &quot;--extension-pkg-whitelist=PyQt5&quot;, &quot;--disable=W,C&quot;, &quot;--generate-members&quot; ]//避免错误报错 } 现在新建一个文件： import sys import FileName from PyQt5.QtWidgets import QApplication, QMainWindow if __name__ == &#39;__main__&#39;: app = QApplication(sys.argv) MainWindow = QMainWindow() ui = FileName.Ui_MainWindow() ui.setupUi(MainWindow) MainWindow.show() sys.exit(app.exec_()) 运行此文件，即可看到我们刚才制作的窗口。 下面的问题就是要添加对应的功能，我们打开刚才制作好的FileName.py进行修改。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>PyQt</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode配置Python环境及Python入门学习]]></title>
    <url>%2F2019%2Fpython%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019.10.17 内容完善中! 大概七月份花了一天的时间把python的基础语法看了一遍，十月份再花了一点时间学习，主要用于写绘制数据图片、网页爬虫、图形界面。 如果你会C++的话，我在这里就写一下如何以最快的速度看完语法，并且学会调用一些基本的库，尽量写到最简，不熟悉的语法和库可以直接查文档或者Google解决。 配置环境首先去官网下载合适版本并安装 https://www.python.org/ 安装时 记得勾选上Add Python 3.x to PATH再进行安装，这样不用自行配置环境变量 在cmd或者powershell下输入python 出现 Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)] on win32 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; 即代表安装成功 在VSCode中安装 这个插件 按下Ctrl+Shift+P选择Python: 选择解析器 Python: Select Interpreter填写python解析器路径C:/Users/UserName/AppData/Local/Programs/Python/Python37-32/python.exe（默认安装路径是这个） 检查并设置.vscode文件夹下的文件 launch.json{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Python&quot;, &quot;type&quot;: &quot;python&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${file}&quot;, &quot;console&quot;: &quot;integratedTerminal&quot; } ] } settings.json{ &quot;python.pythonPath&quot;: &quot;C:\\Users\\UserName\\AppData\\Local\\Programs\\Python\\Python37-32\\python.exe&quot;, } 右键-在终端中运行python文件 调试-启动调试 调试-在不调试的情况下启动 都可以运行，调试可以设置断点 在cmd或者powershell下输入python进入交互环境 使用python 文件名.py运行python文件 使用pip install 库名称安装库 使用pip list查看已安装的库 基础语法变量在赋值时被创建 数字int整型 float浮点型 complex复数 类型转换：int(x) float(x) complex(x,y) 字符串使用’’或””创建，下标从零开始 转义字符：和C++类似 运算：+连接 *重复 []获取字符 [:]截取，左闭右开 &gt;&gt;&gt;a = &quot;12345&quot; &gt;&gt;&gt;a[1:4] 234 格式化输出：print(“XXX%sXXX%dXXX” % (‘xxx’, 10)) 占位符和C++相同 运算符** 幂 / 除 // 整除 &gt;&gt;&gt;2**3 8 &gt;&gt;&gt;21/10 2.1 &gt;&gt;&gt;21//10 2 C++ Python $$ and ` ` or ! not in 在序列中找到值返回True 否则返回False not in 相反 其余和C++相同 数据结构下标从0开始 列表list类似C++中的vector l = [&#39;A&#39;, &#39;B&#39;, 2019, 2020] print(l[0]) #第0个 print(l[-2]) #倒数第2个 print(l[1:3]) #第1到第2个 del l[1] #删除第一个 print(l) list.append(2021) #在末尾添加新对象 print(l) --- 输出： A 2019 [&#39;B&#39;,2019] [&#39;A&#39;, 2019, 2020] [&#39;A&#39;, 2019, 2020, 2021] 剩余内容待更新 调用库剩余内容待更新 练习随便练习写了写的东西，但是tkinter不方便也不好看，所以我要再学一下PyQt，也方便以后学习C++的Qt 使用b站视频av号查询数据调用了b站的api 使用了tkinter最简单的功能 import tkinter as tk import json import re from urllib.request import urlopen def GetDict(date, keys, default=None): keys_list = keys.split(&#39;.&#39;) if isinstance(date,dict): dictionary = dict(date) for i in keys_list: try: if dictionary.get(i) != None: dict_values = dictionary.get(i) elif dictionary.get(i) == None: dict_values = dictionary.get(int(i)) except: return default dictionary = dict_values return dictionary Videojson = &quot;&quot; def WebRequest(id): global Videojson Videojson = urlopen(&quot;https://api.bilibili.com/x/article/archives?ids=&quot;+id).read().decode(&#39;utf-8&#39;) Data = json.loads(Videojson) return Data window = tk.Tk() window.title(&#39;哔哩哔哩数据查询&#39;) window.geometry(&#39;485x475&#39;) def insert_point(): VideoId = ScanId.get() VideoData = WebRequest(VideoId) ViewTextWindow.delete(0.0, &#39;end&#39;) TitleTextWindow.delete(0.0, &#39;end&#39;) FavoriteTextWindow.delete(0.0, &#39;end&#39;) DanmuTextWindow.delete(0.0, &#39;end&#39;) ReplyTextWindow.delete(0.0, &#39;end&#39;) CoinTextWindow.delete(0.0, &#39;end&#39;) JsonTextWindow.delete(0.0, &#39;end&#39;) ViewTextWindow.insert(&#39;insert&#39;, str(GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.stat.view&quot;))) TitleTextWindow.insert(&#39;insert&#39;, GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.title&quot;)) FavoriteTextWindow.insert(&#39;insert&#39;, str(GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.stat.favorite&quot;))) DanmuTextWindow.insert(&#39;insert&#39;, str(GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.stat.danmaku&quot;))) ReplyTextWindow.insert(&#39;insert&#39;, str(GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.stat.reply&quot;))) CoinTextWindow.insert(&#39;insert&#39;, str(GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.stat.coin&quot;))) JsonTextWindow.insert(&#39;insert&#39;, Videojson) tk.Label(window, text=&quot;输入视频AV号&quot;).place(x=350, y=10, anchor=&#39;nw&#39;) ScanId = tk.Entry(window) ScanId.place(x=320, y=45, anchor=&#39;nw&#39;) query = tk.Button(window, text=&quot;查询&quot;, width=6, height=1, command=insert_point) query.place(x=370, y=70, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;标题&quot;).place(x=10, y=10, anchor=&#39;nw&#39;) TitleTextWindow = tk.Text(window,height=1,width=35) TitleTextWindow.place(x=45, y=15, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;播放&quot;).place(x=10, y=40, anchor=&#39;nw&#39;) ViewTextWindow = tk.Text(window,height=1,width=35) ViewTextWindow.place(x=45, y=45, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;收藏&quot;).place(x=10, y=70, anchor=&#39;nw&#39;) FavoriteTextWindow = tk.Text(window,height=1,width=35) FavoriteTextWindow.place(x=45, y=75, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;弹幕&quot;).place(x=10, y=100, anchor=&#39;nw&#39;) DanmuTextWindow = tk.Text(window,height=1,width=35) DanmuTextWindow.place(x=45, y=105, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;回复&quot;).place(x=10, y=130, anchor=&#39;nw&#39;) ReplyTextWindow = tk.Text(window,height=1,width=35) ReplyTextWindow.place(x=45, y=135, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;硬币&quot;).place(x=10, y=160, anchor=&#39;nw&#39;) CoinTextWindow = tk.Text(window,height=1,width=35) CoinTextWindow.place(x=45, y=165, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;json&quot;).place(x=10, y=190, anchor=&#39;nw&#39;) JsonTextWindow = tk.Text(window,height=20,width=60) JsonTextWindow.place(x=45, y=195, anchor=&#39;nw&#39;) window.mainloop() 获取b站视频总播放排名并绘制柱状图需要matplotlib库 使用https://www.kanbilibili.com的数据，获取更多数据需要写js对网页进行交互，等待python学习以及前端学习来进行改善 from urllib.request import urlopen import json import re import matplotlib.pyplot as plt import numpy as np import requests # -*- coding: UTF-8 -*- def get_dict_value(date, keys, default=None): keys_list = keys.split(&#39;.&#39;) if isinstance(date,dict): dictionary = dict(date) for i in keys_list: try: if dictionary.get(i) != None: dict_values = dictionary.get(i) elif dictionary.get(i) == None: dict_values = dictionary.get(int(i)) except: return default dictionary = dict_values return dictionary videoData = urlopen(&quot;https://www.kanbilibili.com/rank/videos&quot;).read().decode(&#39;utf-8&#39;) videoAvList = re.findall(r&#39;href=&quot;/video/av(.*?)&quot;&#39;, videoData) # &lt;a href=&quot;/video/av36570707&quot; videoVisit = {} cnt = 0 Y = [] for i in range(0, len(videoAvList)): video_id = videoAvList[i] if(video_id in videoVisit): continue videoVisit[video_id] = 1 jsonData = urlopen( &quot;https://api.bilibili.com/x/article/archives?ids=&quot; + video_id ).read().decode(&#39;utf-8&#39;) Data = json.loads(jsonData) cnt += 1 Y.append(get_dict_value(Data, &quot;data.&quot;+video_id+&quot;.stat.view&quot;)) print(&#39;rank: %d | av: %s | 播放数：%s&#39; % (cnt, video_id, get_dict_value(Data, &quot;data.&quot;+video_id+&quot;.stat.view&quot;))) print(&#39;标题：%s&#39; % get_dict_value(Data, &quot;data.&quot;+video_id+&#39;.title&#39;)) n = cnt X = np.arange(n) plt.bar(X, Y) plt.bar(X, Y, facecolor=&#39;#66ccff&#39;, edgecolor=&#39;white&#39;) plt.xlim((-0.5, 99)) plt.ylim((1, 100000000)) plt.xlabel(&#39;Rank&#39;) plt.ylabel(&#39;View&#39;) new_ticks1 = np.linspace(0, 100000000, 11) plt.yticks(new_ticks1) new_ticks = np.linspace(0, 99, 100) plt.xticks(new_ticks) plt.show()]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages+HTML5 up制作个人主页及绑定二级域名]]></title>
    <url>%2F2019%2Fhtml_page%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-09-23 好看是第一生产力​qwq 单个GitHub帐号下添加多个GitHub Pages的相关问题| 我很好奇 首先我们要知道GitHub Pages可以有多个，项目名为YourGitHubName.github.io的Pages使用这个域名访问，新添加一个项目ProjectName并设置为Pages项目后，使用YourGitHubName.github.io/ProjectName进行访问，那么我们可以使用一个Pages托管Hexo博客，一个Pages托管个人主页. 这里介绍一个网站提供了很多个人主页的模板https://html5up.net我们选择并下载其中一个，直接修改即可，有一定HTML和CSS基础都可以很轻松的修改，你需要一个浏览器并会使用控制台以及抓取元素和一个编辑器例如vscode即可开始编写. 那么你还需要会使用git并把这个网站的源代码上传到GitHub的repo上，不会上网找个教程吧. 那然后就是域名绑定了，如果你用域名绑定过GitHub Pages的话，你就知道域名的DNS设置要设置几个A选项，这里不讲那是啥玩意了，总之这个选项是设置GitHub的ip地址的，有空我再找链接吧，自己去查GitHub的文档就行。然后你要设置一个CNAME，设置YoutGitHubName.github.io，然后在Github的repo里添加一个CNAME文件内容是你的域名全称并且不带https，www这样的前缀. 那么现在有两个页面，我们可以把主域名解析到个人主页上，使用blog二级域名解析到博客上，具体设置就是在域名DNS设置里设置二级域名并且同样解析到YoutGitHubName.github.io上，然后分别在个人主页的CNAME里设置域名和博客的CNAME里设置blog.域名，记得打开GitHub Pages绑定个人域名的https. 现在等一会DNS解析生效和GitHub的https证书申请完毕应该就没什么问题了.]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「莫比乌斯反演」]]></title>
    <url>%2F2019%2Fmobius%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-09-23 参考资料：莫比乌斯反演-让我们从基础开始莫比乌斯反演_cnblogs_peng-ymP2257 YY的GCD 题解容斥原理 与 莫比乌斯反演整除分块_peng-ymOI生涯中的各种数论算法的证明 整除分块公式求： \sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor对于每个$\lfloor\frac{n}{i}\rfloor$值相同的区间$[l,r]$有$r=n/(n/l)$，即对于$\forall x\in [i,n/(n/i)]$有$x=\lfloor\frac{n}{i}\rfloor$. 时间复杂度$O(\sqrt{n})$ 代码for(int l = 1, r; l &lt;= n; l = r + 1) { r = n / (n / l); ans += (r - l + 1) * (n / l); } 数论函数满足$f(ab)=f(a)f(b),gcd(a,b)=1$的数论函数称为积性函数满足$f(ab)=f(a)f(b)$的数论函数称为完全积性函数 积性函数$\varphi(n)$：欧拉函数，表示小于n的正整数中与n互质的数的数目 \varphi(x)=x\prod_{i=1}^{n}\left(1-\frac{1}{p_i}\right)$\mu(n)$：莫比乌斯函数$\sigma(n)$：因子和函数，表示n的正因子和$d(n)​$：因子个数函数，表示n的正因数个数 完全积性函数$\epsilon(n)=[n=1]$：单位函数$id(n)=n$：恒等函数$1(n)=1$：常函数 狄利克雷卷积对于数论函数$f(n),g(n)$定义Dirichlet卷积为 (f\times g)(n)=\sum_{d\mid n}f(d)g(\frac{n}{d})若$f,g$为积性函数，$f*g,f\times g$为积性函数 常用的狄利克雷卷积 id=\varphi\times 1\quad n=\sum_{d\mid n}\varphi(d) \epsilon = \mu \times 1 \quad \epsilon(n) = \sum_{d\mid n}\mu(d) \varphi = \mu \times id \quad \varphi(n)=\sum_{d\mid n}d\mu(\frac{n}{d})=\sum_{d\mid n}\mu(d)\frac{n}{d}莫比乌斯函数 \mu(d) = \left\{\begin{matrix}1,d=1 \\ (-1)^n,d=\prod_{i=1}^{n}p_i^{k_i} , \forall p_i, k_i=1 \\ 0,d=\prod_{i=1}^{n}p_i^{k_i} , \exists p_i, k_i\geqslant 2 \end{matrix}\right.线性筛求莫比乌斯函数void sieve() { mu[1] = 1; for(int i = 2; i &lt;= N; i++) { if(!vis[i]) prime[++cnt] = i, mu[i] = -1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; } } } 性质由$\mu \times 1 = \epsilon$得 \sum_{d|n}\mu(d)=[n=1]莫比乌斯反演对于函数 f=g\times 1有 g=\mu \times f即对于 f(n)=\sum_{d\mid n}g(d)有 g(n)=\sum_{d\mid n}\mu(d)f(\frac{n}{d})ProblemP2303 [SDOI2012]Longge的问题 \sum_{i=1}^{n}gcd(i,n)\\ =\sum_{d\mid n}d\times\sum_{i=1}^{n}[gcd(i,n)=d]\\ =\sum_{d \mid n}d \times \sum_{i=1}^{\frac{n}{d}}[gcd\left ( i,\frac{n}{d}\right)=1]\\ =\sum_{d \mid n} d \cdot \varphi\left ( \frac{n}{d} \right )P2257 YY的GCD原式 =\sum_{k=1}^{min(n,m)}\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=k](k\in prime)由 \sum_{d|n}\mu(d)=[n=1]得 \sum_{d|gcd(i,j)}\mu(d)=[gcd(i,j)=1]原式 =\sum_{k=1}^{min(n,m)}\sum_{i=1}^{\lfloor{\frac{n}{k}}\rfloor}\sum_{j=1}^{\lfloor{\frac{m}{k}}\rfloor}\sum_{d|gcd(i,j)}\mu(d)(k\in prime) =\sum_{k=1}^{min(n,m)}\sum_{d=1}^{\lfloor{\frac{n}{k}}\rfloor}\mu(d){\lfloor{\frac{n}{kd}}\rfloor}{\lfloor{\frac{m}{kd}}\rfloor})(k\in prime)设$T=kd$有原式 =\sum_{k=1}^{min(n,m)}\sum_{d=1}^{\lfloor{\frac{n}{k}}\rfloor}\mu(d){\lfloor{\frac{n}{T}}\rfloor}{\lfloor{\frac{m}{T}}\rfloor}(k\in prime) =\sum_{T=1}^{min(n,m)}{\lfloor{\frac{n}{T}}\rfloor}{\lfloor{\frac{m}{T}}\rfloor}\sum_{k|T,k\in prime}\mu(\frac{T}{k})#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int _ = 10000005, N = 10000000; int T, n, m, cnt; int vis[_], prime[_], mu[_], f[_], sum[_]; void sieve() { mu[1] = 1; for(int i = 2; i &lt;= N; i++) { if(!vis[i]) prime[++cnt] = i, mu[i] = -1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; } } for(int i = 1; i &lt;= cnt; i++) for(int j = 1; prime[i] * j &lt;= N; j++) f[j * prime[i]] += mu[j]; for(int i = 1; i &lt;= N; i++) sum[i] = sum[i - 1] + f[i]; } int main() { sieve(); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if(n &gt; m) swap(n, m); long long ans = 0; for(int l = 1, r = 0; l &lt;= n; l = r + 1) { r = min(n / (n / l), m / (m / l)); ans += 1LL * (n / l) * (m / l) * (sum[r] - sum[l - 1]); } printf(&quot;%lld\n&quot;, ans); } return 0; } P3455 [POI2007]ZAP-Queries \sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=k] =\sum_{i=1}^{\lfloor{\frac{n}{k}}\rfloor}\sum_{j=1}^{\lfloor{\frac{m}{k}}\rfloor}[gcd(i,j)=1] =\sum_{i=1}^{\lfloor{\frac{n}{k}}\rfloor}\sum_{j=1}^{\lfloor{\frac{m}{k}}\rfloor}\sum_{d\mid gcd(i,j)} \mu(d) =\sum_{d=1}^{min(n,m)}\mu(d)\lfloor{\frac{n}{d}}\rfloor\lfloor{\frac{m}{d}}\rfloor#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int _ = 50005, N = 50000; int T, n, m, d; int vis[_], prime[_], mu[_], sum[_], cnt; void sieve() { mu[1] = 1; for(int i = 2; i &lt;= N; i++) { if(!vis[i]) prime[++cnt] = i, mu[i] = -1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; } } for(int i = 1; i &lt;= N; i++) sum[i] = sum[i - 1] + mu[i]; } int main() { sieve(); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;d); if(n &gt; m) swap(n, m); n /= d; m /= d; long long ans = 0; for(int l = 1, r = 0; l &lt;= n; l = r + 1) { r = min(n / (n / l), m / (m / l)); ans += 1LL * (n / l) * (m / l) * (sum[r] - sum[l - 1]); } printf(&quot;%lld\n&quot;, ans); } return 0; } P2522 [HAOI2011]Problem b \sum_{i=a}^b\sum_{j=c}^d[gcd(i,j)=k] =\sum_{i=1}^b\sum_{j=1}^d[gcd(i,j)=k]-\sum_{i=1}^{a-1}\sum_{j=1}^d[gcd(i,j)=k]-\sum_{i=1}^b\sum_{j=1}^{c-1}[gcd(i,j)=k]+\sum_{i=1}^{a-1}\sum_{j=1}^{c-1}[gcd(i,j)=k] \sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=k] =\sum_{i=1}^{\lfloor{\frac{n}{k}}\rfloor}\sum_{j=1}^{\lfloor{\frac{m}{k}}\rfloor}[gcd(i,j)=1] =\sum_{i=1}^{\lfloor{\frac{n}{k}}\rfloor}\sum_{j=1}^{\lfloor{\frac{m}{k}}\rfloor}\sum_{d\mid gcd(i,j)} \mu(d) =\sum_{d=1}^{min(n,m)}\mu(d)\lfloor{\frac{n}{d}}\rfloor\lfloor{\frac{m}{d}}\rfloor#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int _ = 50005, N = 50000; int T, a, b, c, d, k; int vis[_], prime[_], mu[_], sum[_], cnt; void sieve() { mu[1] = 1; for(int i = 2; i &lt;= N; i++) { if(!vis[i]) prime[++cnt] = i, mu[i] = -1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; } } for(int i = 1; i &lt;= N; i++) sum[i] = sum[i - 1] + mu[i]; } long long calc(int n, int m, int k) { long long ans = 0; n = n / k; m = m / k; for(int l = 1, r = 0; l &lt;= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); ans += 1LL * (n / l) * (m / l) * (sum[r] - sum[l - 1]); } return ans; } int main() { sieve(); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;k); long long ans = calc(b, d, k) - calc(a - 1, d, k) - calc(b, c - 1, k) + calc(a - 1, c - 1, k); printf(&quot;%lld\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>整除分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「后缀数组」]]></title>
    <url>%2F2019%2FSA%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-09-23 参考资料：1.后缀数组详解2.后缀数组-学习笔记3.后缀数组——处理字符串的有力工具 定义$SA$排名为$i$的后缀的位置$rk$位置为$i$的后缀的排名$tp$第二关键字的排名为$i$的后缀的位置，还被用作$rank$的暂存$tax$每个排名对应的后缀数量后缀数组就是为了求出$sa$和$rk$ 性质$rk[sa[i]]=i$ $sa[rk[i]]=i$ $LCP(x,y) $：字符串x与字符串y的最长公共前缀，在这里指x号后缀与与y号后缀的最长公共前缀 $height[i]=lcp ( sa[i],sa[i - 1] )$，即排名为$i$的后缀与排名为$i−1$的后缀的最长公共前缀 $H[i]：height[rak[i]]$，即$i$号后缀与它前一名的后缀的最长公共前缀 $H[i] \geqslant H[i - 1] - 1$ 证明 $LCP(i,j)=LCP(j,i) $ $LCP(i,i)=len(sa[i])=n-sa[i]+1$ $LCP(i,k)=min\left\{height[j] \right\}(i+1&lt;=j&lt;=k)$ $S$不同的子串个数$\dfrac{n(n+1)}{2} -\sum_{i=1}^nheight[i]$ 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;string&gt; #define R register int using namespace std; const int N = 1000005; string s; /* sa[i]：排名为i的后缀的位置 rak[i]：从第i个位置开始的后缀的排名，下文为了叙述方便，把从第i个位置开始的后缀简称为后缀i tp[i]：基数排序的第二关键字，意义与sa一样，即第二关键字排名为i的后缀的位置 tax[i]：i号元素出现了多少次。辅助基数排序 s：字符串，s[i]表示字符串中第i个字符串*/ int n, m, sa[N], rk[N], tp[N], c[N]; void _sort() { for(R i = 1; i &lt;= m; ++i) c[i] = 0; for(R i = 1; i &lt;= n; ++i) c[rk[i]]++; for(R i = 1; i &lt;= m; ++i) c[i] += c[i - 1]; for(R i = n; i &gt;= 1; --i) sa[c[rk[tp[i]]]--] = tp[i]; } void SA() { m = 150; for(R i = 1; i &lt;= n; ++i) rk[i] = s[i - 1], tp[i] = i; _sort(); for(R w = 1, p = 0; p &lt; n &amp;&amp; w &lt;= n; m = p, w &lt;&lt;= 1) { p = 0; for(R i = 1; i &lt;= w; ++i) tp[++p] = n - w + i; for(R i = 1; i &lt;= n; ++i) if(sa[i] &gt; w) tp[++p] = sa[i] - w; _sort(); swap(tp, rk); rk[sa[1]] = p = 1; for(R i = 2; i &lt;= n; ++i) rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] &amp;&amp; tp[sa[i - 1] + w] == tp[sa[i] + w]) ? p : ++p; } } /*i号后缀：从i开始的后缀 lcp(x,y)：字符串x与字符串y的最长公共前缀，在这里指x号后缀与与y号后缀的最长公共前缀 height[i]：lcp(sa[i],sa[i-1])，即排名为i的后缀与排名为i-1的后缀的最长公共前缀 H[i]：height[rak[i]]，即i号后缀与它前一名的后缀的最长公共前缀*/ int Height[N]; void Get() { int j, k = 0; for(int i = 1; i &lt;= n; i++) { if(k) k--; j = sa[rk[i] - 1]; while(s[i + k - 1] == s[j + k - 1]) ++k; Height[rk[i]] = k; } } int main() { cin &gt;&gt; s; n = s.length(); SA(); for(R i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, sa[i]); cout &lt;&lt; endl; Get(); return 0; } ProblemP2408 不同子串个数 ans=\dfrac{n(n+1)}{2}-\sum height[i]#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;string&gt; #define R register int using namespace std; const int N = 1000005; string s; int n, m, sa[N], rk[N], tp[N], c[N]; void _sort() { for(R i = 1; i &lt;= m; ++i) c[i] = 0; for(R i = 1; i &lt;= n; ++i) c[rk[i]]++; for(R i = 1; i &lt;= m; ++i) c[i] += c[i - 1]; for(R i = n; i &gt;= 1; --i) sa[c[rk[tp[i]]]--] = tp[i]; } void SA() { m = 150; for(R i = 1; i &lt;= n; ++i) rk[i] = s[i - 1], tp[i] = i; _sort(); for(R w = 1, p = 0; p &lt; n &amp;&amp; w &lt;= n; m = p, w &lt;&lt;= 1) { p = 0; for(R i = 1; i &lt;= w; ++i) tp[++p] = n - w + i; for(R i = 1; i &lt;= n; ++i) if(sa[i] &gt; w) tp[++p] = sa[i] - w; _sort(); swap(tp, rk); rk[sa[1]] = p = 1; for(R i = 2; i &lt;= n; ++i) rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] &amp;&amp; tp[sa[i - 1] + w] == tp[sa[i] + w]) ? p : ++p; } } int Height[N];//H[i] = Height[rk[i]] void Get() { int j, k = 0; for(int i = 1; i &lt;= n; ++i) { if(k) k--; j = sa[rk[i] - 1]; while(s[i + k - 1] == s[j + k - 1]) ++k; Height[rk[i]] = k; } } int main() { cin &gt;&gt; n &gt;&gt; s; SA(); Get(); long long ans = 1LL * n * (n + 1) / 2; for(int i = 1; i &lt;= n; ++i) ans -= Height[rk[i]]; cout &lt;&lt; ans &lt;&lt; endl; return 0; }]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「概率期望」]]></title>
    <url>%2F2019%2Fprobability%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-09-23 概率公式条件概率公式设$A,B$是两个事件，且$P(B)&gt;0$,则在事件$B$发生的条件下，事件$A$发生的条件概率为$P(A|B)=\dfrac{P(AB)}{P(B)}$ 乘法公式1.由条件概率公式得$P(AB)=P(A|B)P(B)=P(B|A)P(A)$2.推广：对$\forall n \geq 2$当$P(A_1A_2…A_{n-1})&gt;0$时有 $P(A_1A_2…A_{n-1}A{n})=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1A_2…A_{n-1})$ 全概率公式如果事件组$B_1,B_2,…,B_n$满足1.$\forall i\neq j\in \left \{1,2,\cdots ,n \right \},B_i\cap B_j = \varnothing$2.$B_1\cup B_2\cup …\cup B_n=\Omega$则称事件组$B_1,B_2,…,B_n$是样本空间$\Omega$的一个划分,或称为样本空间$\Omega$的一个完备事件组。设事件组$\left \{B_i \right \}$是样本空间$\Omega$的一个划分，且$P(B_i)&gt;0(i \in \left \{1,2,\cdots ,n \right \})$对任一事件$A$，有$P(A)=\sum_{i=1}^{n}P(B_i)P(A|B_i)$ 贝叶斯公式设事件组$\left \{B_i \right \}$是样本空间$\Omega$的一个划分，则对任一事件$A(P(A)&gt;0)$,有$P(B_i|A)=\dfrac{P(AB_i)}{P(A)}=\dfrac{P(B_i)P(A|B_i)}{\sum_{j=1}^{n}P(B_j)P(A|B_j)}$上式即为贝叶斯公式，$B_i$常被视为导致试验结果$A$发生的”原因“，$P(B_i)(i\in \left \{1,2,\cdots ,n \right \})$表示各种原因发生的可能性大小，故称先验概率；$P(B_i|A)(i\in \left \{1,2,\cdots ,n \right \})$则反映当试验产生了结果$A$之后，再对各种原因概率的新认识，故称后验概率。 数学期望离散型随机变量$X$的取值为$x_1,x_2,x_3,…,x_{n}$，$p_1,p_2,p_3,…,p_{n}$为$X$对应取值的概率则称$E(X)=\sum_{i=1}^{n}p_{i}x_{i}$为离散型随机变量$X$的数学期望性质：$E(aX+bY)=aE(X)+bE(Y)$ ProblemP4316 绿豆蛙的归宿设$F[x]$表示从$x$走到$N$期望长度$F[x]=\frac{1}{k}\sum_{i=1}^{k}(F[y_{i}]+z_{i})$$F[N]=0$$Ans=F[1]$P1365 WJMZBMR打osu! / Easy设$f[x]$表示到$x$期望得分 $g[x]$表示以$x$结尾期望$o$序列长度$s[i]==x f[i]=f[i-1],g[i]=0$$s[i]==o f[i]=f[i-1]+2*g[i-1]+1,g[i]=g[i-1]+1$$s[i]==? f[i]=f[i-1]+\frac{(2g[i-1]+1)+0}{2},g[i]=\frac{(g[i-1]+1)+0}{2}$$Ans=f[n]$P1654 OSU!$p[i]$表示$i$位置成功概率设$f[i]$表示到$i$期望得分 $x1[i]$以$i$结尾$1$序列期望长度 $x2[i]$表示以$i$结尾$1$序列期望长度平方$(x+1)^{3}=(x^{2}+2x+1)(x+1)=x^{3}+3x^{2}+3x+1$若第$i$次成功且有$f[i-1]=x^{3}则f[i]=f[i-1]+3x^{2}+3x+1$$x1[i]=(x1[i-1]+1)p[i]$$x2[i]=(x2[i-1]+2x1[i-1]+1)p[i]$$f[i]=f[i-1]+(3x2[i-1]+3x1[i-1]+1)p[i]$$Ans=f[n]$P1297 [国家集训队]单选错位$Ans=\sum_{i=1}^{n-1}\frac{1}{max(a_i,a_{i+1})}+\frac{1}{max(a_1,a_n)}​$]]></content>
      <tags>
        <tag>概率</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++STL的OI常用内容]]></title>
    <url>%2F2019%2FC%2B%2B_stl%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-09-23 参考资料:STL 在 OI 中的应用[C++ STL]Set和Multiset Stackstack 后入先出（LIFO）栈头文件#include&lt;stack&gt; 定义stack&lt;int&gt; s; 函数 函数 功能 q.top() 获取栈顶元素（并不删除） q.pop() 删除栈顶元素 q.push(x) 向栈中加入元素 q.empty() 判断栈是否为空 Queuequeue 先入先出（FIFO）队列头文件#include&lt;queue&gt; 定义queue&lt;int&gt; q; 函数 函数 功能 q.front() 获取队首元素（并不删除） q.pop() 删除队首元素 q.push(x) 向队列中加入元素 q.empty() 判断队列是否为空 priority_queue 优先队列头文件#include&lt;queue&gt; 定义priority_queue&lt;int&gt; q; // 队头最大 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; 队头最小 函数 函数 功能 q.top() 获取优先队列中最大的元素（并不删除），其时间复杂度为$O(1)$ q.pop() 删除优先队列中最大元素，其时间复杂度为$O(log n)$ q.push(x) 向优先队列中加入元素，其时间复杂度为$O(log n)$ q.empty() 判断优先队列是否为空 Set 与 Multiset set不允许重复 multiset允许重复 例: set : 1 2 3 4 5 6 multiset : 1 2 2 3 3 3 头文件#include &lt;set&gt; 定义multiset&lt;int&gt; s[N];//定义 multiset&lt;int&gt;::iterator it;//迭代器 函数 操作 效果 s.size() 返回当前的元素数量 s.empty () 判断大小是否为零，等同于$0==size()$，效率更高 操作 效果 count (elem) 返回元素值为$elem$的个数 find(elem) 返回元素值为$elem$的第一个元素，如果没有返回$end()$ lower _bound(elem) 返回元素值$&gt;=elem$的第一个元素位置 upper _bound (elem) 返回元素值$&gt;elem$的第一个元素位置 操作 效果 s.begin() 返回一个随机存取迭代器，指向第一个元素 s.end() 返回一个随机存取迭代器，指向最后一个元素的下一个位置 操作 效果 s.insert(elem) 插入一个$elem$副本，返回新元素位置，无论插入成功与否。 s.erase(elem) 删除与$elem$相等的所有元素，返回被移除的元素个数。 s.erase(pos) 移除迭代器$pos$所指位置元素，无返回值。 s.clear() 移除所有元素，将容器清空 离散化std::unique功能：对有序的容器重新排列，将第一次出现的元素从前往后排，其他重复出现的元素依次排在后面返回值：返回迭代器，迭代器指向的是重复元素的首地址 std::lower_boundlower_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了第一个大于等于value 的值。ForwardIter lower_bound(ForwardIter first, ForwardIter last,const _Tp&amp; val)算法返回一个非递减序列[first, last)中的第一个大于等于值val的位置。 std::upper_boundupper_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了第一个大于value 的值。这两个函数为C++ STL内的函数。ForwardIter upper_bound(ForwardIter first, ForwardIter last, const _Tp&amp; val)算法返回一个非递减序列[first, last)中第一个大于val的位置。 std::sort(b + 1, b + cnt + 1); int *end = std::unique(b + 1, b + cnt + 1); for(int i = 1; i &lt;= n; i++) a[i] = lower_bound(b + 1, end, a[i]) - b;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>stl_queue</tag>
        <tag>stl_set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「分层图」]]></title>
    <url>%2F2019%2Flayered_graph%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-09-23 问题在一个无向图$G=(V,E)$中，可以改变$k$条边的权值为$\Delta w$，求单源最短路径。 分层图分层图的想法就是如果有$k$条边权值变为$\Delta w$，就建$k+1$层图。 这个图实际上是这样的，对于每$1$层中相连的点对$(u,v)$连权值为$w$的无向边，对于每个在原图中相连的点对$(u,v)$由$k$层点$u_k$向$k+1$层点$v_{k+1}$以及$k$层点$v_k$向$k+1$层点$u_{k+1}$连权值为$\Delta w$的有向边，方向是从$k$层向$k+1$层。这样构造完成一张分层图后，从第$1$层的起始点$s_1$求单源最短路径，最终第$k + 1$层的终点$t_{k+1}$的单源最短路径值即为答案所求。原理其实很简单，如果从$k$层图到$k+1$层图，有向边$(u_k,v_{k+1})$是一条$\Delta w$权边，走这条边，相当于把$w$权边变成了$\Delta w$权边，并且进入了$k+1$层。这样如果有$k+1$层图的话，相当于进行了$k$次这种操作，自然就在$k+1$层图求最短路中实现了$k$次改变边权的目标。 题目P2939 [USACO09FEB]改造路Revamping Trails#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int N = 1e4 + 5, M = 5e4 + 5, K = 105; int n, m, k; struct Edge { int Next, to, dis; }e[M * K * 2]; int head[N * K], num; void add(int from, int to, int dis) { e[++num].Next = head[from]; e[num].to = to; e[num].dis = dis; head[from] = num; } int dist[N * K], vis[N * K]; struct node { int u, d; bool operator &lt; (const node &amp;x) const { return d &gt; x.d; } }; priority_queue&lt;node&gt; q; void dijk() { memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; q.push((node){1, 0}); while(!q.empty()) { int u = q.top().u; q.pop(); if(vis[u]) continue; vis[u] = 1; for(int i = head[u]; i; i = e[i].Next) { int v = e[i].to, w = e[i].dis; if(dist[v] &gt; dist[u] + w) { dist[v] = dist[u] + w; if(!vis[v]) q.push((node){v, dist[v]}); } } } } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for(int i = 1, u, v, z; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z); add(u, v, z); add(v, u, z); for(int j = 1; j &lt;= k; j++) { add(j * n + u, j * n + v, z); add(j * n + v, j * n + u, z); add((j - 1) * n + u, j * n + v, 0); add((j - 1) * n + v, j * n + u, 0); } } dijk(); int ans = 0x3fffffff; for(int i = 1; i &lt;= k + 1; i++) ans = min(dist[i * n], ans); printf(&quot;%d\n&quot;, ans); return 0; } P4568 [JLOI2011]飞行路线#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;cstring&gt; using namespace std; const int N = 1e4 + 5, M = 5e4 + 5, K = 12; int n, m, k; int s, t; struct _edge { int Next, v, w; }e[M * K * 4 + M * 2]; int head[N * K], num; void add(int from, int to, int dis) { e[++num].Next = head[from]; e[num].v = to; e[num].w = dis; head[from] = num; } int dist[N * K], vis[N * K]; struct node { int u, d; bool operator &lt; (const node &amp;x) const { return d &gt; x.d; } }; priority_queue&lt;node&gt; q; void dijk(int x) { memset(dist, 0x3f, sizeof(dist)); dist[x] = 0; q.push((node){x, 0}); while(!q.empty()) { node tp = q.top(); q.pop(); int u = tp.u; if(u == t + k * n) break; if(vis[u]) continue; vis[u] = 1; for(int i = head[u]; i; i = e[i].Next) { int v = e[i].v, w = e[i].w; if(dist[v] &gt; dist[u] + w) { dist[v] = dist[u] + w; if(!vis[v]) q.push((node){v, dist[v]}); } } } } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); scanf(&quot;%d%d&quot;, &amp;s, &amp;t); s++, t++; for(int i = 1, u, v, z; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z); u++, v++; add(u, v, z); add(v, u, z); for(int j = 1; j &lt;= k; j++) { add(j * n + u, j * n + v, z); add(j * n + v, j * n + u, z); add((j - 1) * n + u, j * n + v, 0); add((j - 1) * n + v, j * n + u, 0); } } dijk(s); int ans = 1e9; for(int i = 0; i &lt;= k; i++) ans = min(ans, dist[t + i * n]); printf(&quot;%d\n&quot;, ans); return 0; } P4822 [BJWC2012]冻结#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int N = 55, M = 1005, K = 55; int n, m, k; struct Edge { int Next, to, dis; }e[M * K * 10]; int head[N * K * 10], num; void add(int from, int to, int dis) { e[++num].Next = head[from]; e[num].to = to; e[num].dis = dis; head[from] = num; } struct node { int u, d; bool operator &lt; (const node&amp; x) const { return d &gt; x.d; } }; priority_queue&lt;node&gt; q; int dist[N * K * 10], vis[N * K * 10]; void dijk() { memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; q.push((node){1, 0}); while(!q.empty()) { int u = q.top().u; q.pop(); if(vis[u]) continue; vis[u] = 1; for(int i = head[u]; i; i = e[i].Next) { int v = e[i].to, w = e[i].dis; if(dist[v] &gt; dist[u] + w) { dist[v] = dist[u] + w; if(!vis[v]) q.push((node){v, dist[v]}); } } } } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for(int i = 1, u, v, z; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z); add(u, v, z); add(v, u, z); for(int j = 1; j &lt;= k; j++) { add(j * n + u, j * n + v, z); add(j * n + v, j * n + u, z); add((j - 1) * n + u, j * n + v, z &gt;&gt; 1); add((j - 1) * n + v, j * n + u, z &gt;&gt; 1); } } dijk(); int ans = 0x7fffffff; for(int i = 1; i &lt;= k + 1; i++) ans = min(ans, dist[i * n]); printf(&quot;%d\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分层图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流」]]></title>
    <url>%2F2019%2Fnetwork_flow%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-09-23 一些资料：最详细网络流建模基础 模板最大流Dinic没写当前弧优化什么的. 弃坑了，ISAP和HLPP有缘再学. P3376 【模板】网络最大流 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;cstring&gt; const int inf = 0x3fffffff; const int N = 10005, M = 100005; int n, m, s, t, maxflow; int d[N]; struct Edge { int Nxt, v, flow; }e[M &lt;&lt; 1]; int h[N], p = 1; void add(int u, int v, int z) { e[++p].Nxt = h[u]; e[p].v = v; e[p].flow = z; h[u] = p; e[++p].Nxt = h[v]; e[p].v = u; e[p].flow = 0; h[v] = p; } std::queue&lt;int&gt; q; bool bfs() { memset(d, 0, sizeof(d)); while(!q.empty()) q.pop(); q.push(s); d[s] = 1; while(!q.empty()) { int u = q.front(); q.pop(); for(int i = h[u]; i; i = e[i].Nxt) if(e[i].flow &amp;&amp; !d[e[i].v]) { q.push(e[i].v); d[e[i].v] = d[u] + 1; if(e[i].v == t) return true; } } return false; } int dinic(int u, int flow) { if(u == t) return flow; int rest = flow, k; for(int i = h[u]; i &amp;&amp; rest; i = e[i].Nxt) if(e[i].flow &amp;&amp; d[e[i].v] == d[u] + 1) { k = dinic(e[i].v, std::min(rest, e[i].flow)); if(!k) d[e[i].v] = 0; e[i].flow -= k; e[i ^ 1].flow += k; rest -= k; } return flow - rest; } int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); for(int i = 1, u, v, z; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z); add(u, v, z); } int flow = 0; while(bfs()) while(flow = dinic(s, inf)) maxflow += flow; printf(&quot;%d\n&quot;, maxflow); return 0; } 费用流EKP3381 【模板】最小费用最大流 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;cstring&gt; const int _ = 50005; const int inf = 0x3f3f3f3f; int n, m, s, t; int ans, maxflow; int dist[_], incf[_], pre[_], vis[_]; struct Edge { int Nxt, v, flow, cost; } e[_ &lt;&lt; 1]; int h[_], p = 1; void add(int u, int v, int f, int c) { e[++p].Nxt = h[u]; e[p].v = v; e[p].flow = f; e[p].cost = c; h[u] = p; e[++p].Nxt = h[v]; e[p].v = u; e[p].flow = 0; e[p].cost = -c; h[v] = p; } std::queue&lt;int&gt; q; bool spfa() { memset(dist, 0x3f, sizeof(dist)); memset(vis, 0, sizeof(vis)); q.push(s); dist[s] = 0; vis[s] = 1; incf[s] = inf; while(!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for(int i = h[u]; i; i = e[i].Nxt) { if(!e[i].flow) continue; int v = e[i].v; if(dist[v] &gt; dist[u] + e[i].cost) { dist[v] = dist[u] + e[i].cost; incf[v] = std::min(incf[u], e[i].flow); pre[v] = i; if(!vis[v]) vis[v] = 1, q.push(v); } } } if(dist[t] == inf) return false; else return true; } void update() { int u = t; while(u != s) { int i = pre[u]; e[i].flow -= incf[t]; e[i ^ 1].flow += incf[t]; u = e[i ^ 1].v; } maxflow += incf[t]; ans += dist[t] * incf[t]; } int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); for(int i = 1, u, v, z, c; i &lt;= m; i++) { scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;z, &amp;c); add(u, v, z, c); } while(spfa()) update(); printf(&quot;%d %d\n&quot;, maxflow, ans); return 0; } Problem[NOI2008]志愿者招募算法：线性规划 or 有源汇上下界最小费用可行流可以无视一开始幻想这样可以搞： 但其实很难限制条件并且流量并不能准确一对多去覆盖点。 所以是建成这样的： 但是为什么对呢，其实非常玄学，我觉得还是手动模拟一下不会证，然后感性理解。 模拟时可以发现$inf-A[i]$其实对人数限制取反，代表要跑完这条边所有流量，流到$0$之前的流量是没有实际作用的，是为了可以先跳过这天，直到流量为$0$后，代表这条边需要开始选择人进行工作，而这条边需要的人数可以通过别的边反映出来，可以从红边即人补全这条链上为$0$的边无法通过的流量，通过最小费用最大流即可求出最小费用。 $n+1-&gt;t$这条边可以反映出当前还剩的未规划的最大人数，所以$n+1-&gt;t$流量为$0$时，代表之前最大流量流尽，即$(inf-A[i])_{max}$，即$A[i]_{min}$。 [NOI2012]美食节从算法到算术，使用小学数学并利用大量算术技巧计算点的遍号 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define R register using namespace std; const int N = 45, M = 105, sP = 805, _ = N + M * sP + 5; const int inf = 0x3f3f3f3f; int n, m, s, t, sum, tim[N][M], P[N]; struct Edge { int Next, v, flow, cost; } e[(N + N * M * sP + M * sP + 5) &lt;&lt; 1]; int h[N + M * sP + 5], p = 1; inline void add(R int u, R int v, int f, int c) { e[++p].Next = h[u]; e[p].v = v; e[p].flow = f; e[p].cost = c; h[u] = p; e[++p].Next = h[v]; e[p].v = u; e[p].flow = 0; e[p].cost = -c; h[v] = p; } int dist[_], incf[_], maxflow, ans, vis[_], pre[_]; queue&lt;int&gt; q; bool spfa() { memset(vis, 0, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); dist[s] = 0; vis[s] = 1; q.push(s); incf[s] = inf; while(!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for(int i = h[u]; i; i = e[i].Next) if(e[i].flow) { int v = e[i].v; if(dist[v] &gt; dist[u] + e[i].cost) { dist[v] = dist[u] + e[i].cost; incf[v] = min(incf[u], e[i].flow); pre[v] = i; if(!vis[v]) q.push(v), vis[v] = 1; } } } if(dist[t] == inf) return false; else return true; } inline void update() { R int u = t; while(u != s) { int i = pre[u]; e[i].flow -= incf[t]; e[i ^ 1].flow += incf[t]; u = e[i ^ 1].v; } maxflow += incf[t]; ans += dist[t] * incf[t]; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(R int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;P[i]), sum += P[i]; s = 0, t = m * sum + n + 1; for(R int i = 1; i &lt;= n; i++) for(R int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;tim[i][j]); for(R int i = 1; i &lt;= n; i++) add(s, i, P[i], 0); for(R int i = n + 1; i &lt;= n + m * sum; i += sum) add(i, t, 1, 0); for(R int i = 1; i &lt;= n; i++) for(R int j = n + 1, t = 1; j &lt;= n + m * sum; j += sum) add(i, j, 1, tim[i][t++]); while(spfa()) { update(); int u = e[pre[t] ^ 1].v; if((u - n) % sum == 0) break; int v = u + 1; int k = (v - n) % sum == 0 ? sum : (v - n) % sum; int j = (v - n - k) / sum + 1; add(v, t, 1, 0); for(R int i = 1; i &lt;= n; i++) add(i, v, 1, k * tim[i][j]); } printf(&quot;%d\n&quot;, ans); return 0; } 最大权闭合子图 参考资料：——-1——-——-2——-——-3——- 定理最大权闭合子图权值=正权点之和-最小割]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「线段树」]]></title>
    <url>%2F2019%2Fsegment_tree%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-09-23 模板struct Segment_Tree { #define ls (p &lt;&lt; 1) #define rs (p &lt;&lt; 1 | 1) #define mid ((l + r) &gt;&gt; 1) ll ans[_ &lt;&lt; 2], tag[_ &lt;&lt; 2]; inline void pushup(ll p) { ans[p] = ans[ls] + ans[rs]; } inline void pushdown(ll p, ll l, ll r) { ans[ls] += (mid - l + 1) * tag[p]; tag[ls] += tag[p]; ans[rs] += (r - mid) * tag[p]; tag[rs] += tag[p]; tag[p] = 0; } void build(ll p, ll l, ll r) { if(l == r) { ans[p] = a[l]; return; } build(ls, l, mid); build(rs, mid + 1, r); pushup(p); } void update(ll p, ll l, ll r, ll ul, ll ur, ll k) { if(ul &lt;= l &amp;&amp; r &lt;= ur) { ans[p] += (r - l + 1) * k; tag[p] += k; return; } if(tag[p]) pushdown(p, l, r); if(ul &lt;= mid) update(ls, l, mid, ul, ur, k); if(ur &gt; mid) update(rs, mid + 1, r, ul, ur, k); pushup(p); } ll query(ll p, ll l, ll r, ll ql, ll qr) { if(ql &lt;= l &amp;&amp; r &lt;= qr) return ans[p]; if(tag[p]) pushdown(p, l, r); ll res = 0; if(ql &lt;= mid) res += query(ls, l, mid, ql, qr); if(qr &gt; mid) res += query(rs, mid + 1, r, ql, qr); return res; } #undef ls #undef rs #undef mid }T; 题目维护可加性变量解决问题P3707 [SDOI2017]相关分析\bar{x}=\frac{1}{R-L+1}\sum x_i​\bar{y}=\frac{1}{R-L+1}\sum y_i\hat{a}=\dfrac{\sum_{i=L}^R(x_i-\bar{x})(y_i-\bar{y})}{\sum_{i=L}^R(x_i-\bar{x})^2}记$\sum = \sum_{i=L}^{R}​$ QueryAns=\dfrac{ \sum x_iy_i-\bar{x}\sum y_i-\bar{y}\sum x_i+\sum \bar{x}\bar{y}}{\sum x_i^2-2\bar{x}\sum x_i+\sum\bar{x^2}}=\dfrac{ \sum x_iy_i-\frac{1}{R-L+1}\sum x_i\sum y_i-\frac{1}{R-L+1}\sum y_i\sum x_i+\sum \frac{1}{R-L+1}\sum x_i\frac{1}{R-L+1}\sum y_i}{\sum x_i^2-\frac{1}{R-L+1}2\sum x_i\sum x_i+\sum (\frac{1}{R-L+1}\sum x_i)^2}=\dfrac{ \sum x_iy_i-\frac{\sum x_i\sum y_i}{R-L+1}}{\sum x_i^2-\frac{(\sum x_i)^2}{R-L+1}}下传Tag：先$upd$后$addX \quad addY$ 维护值：$t1=\sum x$ | $t2=\sum y$ | $t3=\sum xy$ | $t4=\sum x^2$ 维护Tag：$addX \quad addY$ \hat{a}=\dfrac{t3-\frac{t1t2}{R-L+1}}{t4-\frac{t1^2}{R-L+1}}Add\Delta x = S \quad \Delta y= T\sum (x + S) = \sum x_i+(R-L+1)S\sum(y+T)=\sum y_i+(R-L+1) T\sum(x+S)(y+T)=\sum(xy+Sy+Tx+ST)=\sum xy+S\sum y+T\sum x+(R-L+1)ST\sum(x+S)^2=\sum x^2+2S\sum x+(R-L+1)S^2下传Tag：先$upd$后$addX \quad addY$ 顺序：先$t3,t4$后$t1,t2$ Update自然数平方和：\sum_{i=1}^ni=\frac{n(n+1)(2n+1)}{6} 1.$\forall i \in [L,R]\quad x_i=i y_i=i$ \sum x=\sum y = \sum i = \frac{(R-L+1)(R+L)}{2}\sum x^2 = \sum xy = \sum i ^2 = \sum_{i=1}^R i^2-\sum_{i=1}^{L-1}i^2=\frac{R(R+1)(2R+1)}{6}-\frac{L(L-1)(2L-1)}{6}下传Tag：先$upd$后$addX \quad addY$ 清空Tag $addX \quad addY$ 标记Tag $upd$ 2.ADD L R S T Code#include &lt;iostream&gt; #include &lt;cstdio&gt; #define ll long long using namespace std; const int N = 100005; int n, m; double X[N], Y[N]; struct Segment_Tree { #define ls (p &lt;&lt; 1) #define rs (p &lt;&lt; 1 | 1) #define mid ((l + r) &gt;&gt; 1) bool upd[N &lt;&lt; 2]; double x[N &lt;&lt; 2], y[N &lt;&lt; 2]; double t1[N &lt;&lt; 2], t2[N &lt;&lt; 2], t3[N &lt;&lt; 2], t4[N &lt;&lt; 2]; inline void pushup(ll p) { t1[p] = t1[ls] + t1[rs]; t2[p] = t2[ls] + t2[rs]; t3[p] = t3[ls] + t3[rs]; t4[p] = t4[ls] + t4[rs]; } inline void pushdown(ll p, ll l, ll r) { double L = mid - l + 1, R = r - mid; if(upd[p]) { double Ll = l, Lr = mid, Rl = mid + 1, Rr = r; t1[ls] = t2[ls] = (Lr - Ll + 1.0) * (Lr + Ll) / 2.0; t1[rs] = t2[rs] = (Rr - Rl + 1.0) * (Rr + Rl) / 2.0; t3[ls] = t4[ls] = Lr * (Lr + 1.0) * (2.0 * Lr + 1.0) / 6.0 - Ll * (Ll - 1.0) * (2.0 * Ll - 1.0) / 6.0; t3[rs] = t4[rs] = Rr * (Rr + 1.0) * (2.0 * Rr + 1.0) / 6.0 - Rl * (Rl - 1.0) * (2.0 * Rl - 1.0) / 6.0; upd[ls] = upd[rs] = upd[p]; upd[p] = 0; x[ls] = x[rs] = y[ls] = y[rs] = 0; } if(x[p] || y[p]) { t3[ls] += x[p] * t2[ls] + y[p] * t1[ls] + L * x[p] * y[p]; t3[rs] += x[p] * t2[rs] + y[p] * t1[rs] + R * x[p] * y[p]; } if(x[p]) { t4[ls] += 2 * x[p] * t1[ls] + L * x[p] * x[p]; t4[rs] += 2 * x[p] * t1[rs] + R * x[p] * x[p]; t1[ls] += L * x[p]; t1[rs] += R * x[p]; x[ls] += x[p]; x[rs] += x[p]; x[p] = 0; } if(y[p]) { t2[ls] += (double)L * y[p]; t2[rs] += (double)R * y[p]; y[ls] += y[p]; y[rs] += y[p]; y[p] = 0; } } void build(ll p, ll l, ll r) { if(l == r) { t1[p] = X[l]; t2[p] = Y[l]; t3[p] = X[l] * Y[l]; t4[p] = X[l] * X[l]; return; } upd[p] = x[p] = y[p] = 0; build(ls, l, mid); build(rs, mid + 1, r); pushup(p); } void add(ll p, ll l, ll r, ll ql, ll qr, double S, double T) { if(ql &lt;= l &amp;&amp; r &lt;= qr) { double len = (r - l + 1); t3[p] += S * t2[p] + T * t1[p] + len * S * T; t4[p] += 2 * S * t1[p] + len * S * S; t1[p] += len * S; t2[p] += len * T; x[p] += S; y[p] += T; return; } pushdown(p, l, r); if(ql &lt;= mid) add(ls, l, mid, ql, qr, S, T); if(qr &gt; mid) add(rs, mid + 1, r, ql, qr, S, T); pushup(p); } void update(ll p, ll l, ll r, ll ql, ll qr) { if(ql &lt;= l &amp;&amp; r &lt;= qr) { t1[p] = t2[p] = (double)(r - l + 1.0) * (l + r) / 2.0; t3[p] = t4[p] = (double)r * (r + 1.0) * (2.0 * r + 1) / 6.0 - (double)l * (l - 1.0) * (2.0 * l - 1.0) / 6.0; x[p] = y[p] = 0; upd[p] = 1; return; } pushdown(p, l, r); if(ql &lt;= mid) update(ls, l, mid, ql, qr); if(qr &gt; mid) update(rs, mid + 1, r, ql, qr); pushup(p); } double query(ll p, ll l, ll r, ll ql, ll qr, ll f) { if(ql &lt;= l &amp;&amp; r &lt;= qr) { if(f == 1) return t1[p]; if(f == 2) return t2[p]; if(f == 3) return t3[p]; if(f == 4) return t4[p]; } pushdown(p, l, r); double res = 0; if(ql &lt;= mid) res += query(ls, l, mid, ql, qr, f); if(qr &gt; mid) res += query(rs, mid + 1, r, ql ,qr, f); return res; } #undef ls #undef rs #undef mid }; struct Segment_Tree Tree; int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;X[i]); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;Y[i]); Tree.build(1, 1, n); int opt, L, R; double S, T; while(m--) { scanf(&quot;%d&quot;, &amp;opt); if(opt == 1) { scanf(&quot;%d %d&quot;, &amp;L, &amp;R); double t1 = Tree.query(1, 1, n, L, R, 1); double t2 = Tree.query(1, 1, n, L, R, 2); double t3 = Tree.query(1, 1, n, L, R, 3); double t4 = Tree.query(1, 1, n, L, R, 4); double a_ = (t3 - (t1 * t2) / (double)(R - L + 1)) / (t4 - (t1 * t1) / (double)(R - L + 1)); printf(&quot;%.10lf\n&quot;, a_); } else if(opt == 2) { scanf(&quot;%d %d %lf %lf&quot;, &amp;L, &amp;R, &amp;S, &amp;T); Tree.add(1, 1, n, L, R, S, T); } else if(opt == 3) { scanf(&quot;%d %d %lf %lf&quot;, &amp;L, &amp;R, &amp;S, &amp;T); Tree.update(1, 1, n, L, R); Tree.add(1, 1, n, L, R, S, T); } } return 0; } Tag的用法区间01取反xor区间翻转rev区间最长连续1/0区间min/max子段和P2572 [SCOI2010]序列操作 扫描线矩形面积并P1502 窗口的星星P1856 [USACO5.5]矩形周长Picture 二维线段树树套树P3437 [POI2006]TET-Tetris 3D 其它Luogu P2061 [USACO07OPEN]城市的地平线City Horizon简单题 算法线段树 + 离散化 思路对$(x,y,h)$的左右端点$x,y$进行离散化，离散化前的原值记为$val[i]$，对每个矩形按高度$h$从小到大排序。 设离散化后的端点有$M$个，则对如图所示$M-1$个规则矩形编号为$[1,M-1]$，可以由$h_{[i, i+1]}\times(val[i+1] - val[i])$得出第$i$个矩形的面积。 开一颗区间为$[1,M-1]$的线段树，按$h$从小到大依次对线段树区间覆盖，可以保证高的矩形覆盖了低的矩形的区间，具体操作为对离散化后的$(x,y,h)$，进行线段树$[x,y-1]$区间覆盖$h$值，最终$i$点存储$h_{[i,i+1]}$的最大值。 $h_{[i, i+1]}$可以通过线段树单点查询$i$点求出。 答案：$\sum_{i=1}^{M-1}h_{[i, i+1]}\times(val[i+1] - val[i])$ 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #define ll long long using namespace std; const int N = 80005; int n, b[N], val[N];//b[]:离散化数组 struct Line { int x, y, h; }a[N];//存储每个矩形 bool cmp(Line a, Line b) { return a.h &lt; b.h; } int ans[N &lt;&lt; 2];//线段树数组 #define ls (p &lt;&lt; 1) #define rs (p &lt;&lt; 1 | 1) #define mid ((l + r) &gt;&gt; 1) void update(int p, int l, int r, int ul, int ur, int k) { if(ul &lt;= l &amp;&amp; r &lt;= ur) { ans[p] = k; return; } if(ans[p]) ans[ls] = ans[rs] = ans[p], ans[p] = 0;//区间覆盖直接下推 if(ul &lt;= mid) update(ls, l, mid, ul, ur, k); if(ur &gt; mid) update(rs, mid + 1, r, ul, ur, k); } ll query(int p, int l, int r, int x)//单点查询 { if(l == r) return ans[p]; if(ans[p]) ans[ls] = ans[rs] = ans[p], ans[p] = 0;//区间覆盖直接下推 if(x &lt;= mid) return query(ls, l, mid, x); if(x &gt; mid) return query(rs, mid + 1, r, x); } #undef ls #undef rs #undef mid int main() { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d%d&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].h); b[i] = a[i].x; b[n + i] = a[i].y;//离散化数组记录下所有x,y } sort(b + 1, b + 2 * n + 1);//排序 int _n = unique(b + 1, b + 2 * n + 1) - (b + 1);//去重，_n为去重后x,y端点个数 for(int i = 1; i &lt;= n; i++) if(a[i].x != a[i].y)//x=y没有作用 { int x = a[i].x, y = a[i].y; a[i].x = lower_bound(b + 1, b + _n + 1, a[i].x) - b; a[i].y = lower_bound(b + 1, b + _n + 1, a[i].y) - b;//离散化 val[a[i].x] = x; val[a[i].y] = y;//原值 } sort(a + 1, a + n + 1, cmp);//按h从小到大排序 for(int i = 1; i &lt;= n; i++) if(a[i].x != a[i].y)//防止y-1&lt;x update(1, 1, _n - 1, a[i].x, a[i].y - 1, a[i].h);//更新,注意结点个数是_n-1，端点y要变成矩形区域y-1，可以画图理解一下，相当于把端点x右边的矩形区域编号为x ll res = 0; for(int i = 1; i &lt; _n; i++) res += query(1, 1, _n - 1, i) * (val[i + 1] - val[i]); printf(&quot;%lld\n&quot;, res); return 0; }]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《意识宇宙》]]></title>
    <url>%2F2019%2Fscience_fiction%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-10-26 维护文档 COSMOS1.A.D.2019.10.251.真实人名替换为ID. 2.对原有的过度夸张部分及人物形象不明确部分进行修改. COSMOS-1 COSMOS1.A.D.1997Tommy_clas出生了。 他1个月会说中文，2个月会说英文，一周岁英语词汇量十万，两周岁学会所有中文词语，认识所有汉字，一岁学完高数精通C++，二岁看懂抽代掌握所有编程语言，两岁半看懂了所有人类数学知识，三岁学完人类所有物理学。 世界上所有科学家都说，拯救人类的天才出现了。 COSMOS-1.A.D.2022太阳核反应活动异常，气候急剧变化，人们开始躲入地下，科学家们预言人类的末日将要来临了。 Tommy_clas微微一笑，明白自己的机会到了。 COSMOS-1.A.D.2039北半球8月的温度突破了$47℃$，地下城已经建设完毕了，地面上人的踪影渐渐消失了。 Loli凭借着自己30年的大学教龄和科学家身份早早的分配到了CM-CH-DY-P7-Y2地下城Sl-H7-y-8I-2区一套128层楼的空中住房，地下城绚烂的霓虹灯闪烁着，光线飞向他的眼睛。 “20年前，也是这样”Loli思索着，“大概是2019年8月。” “我喜欢物理学，喜欢天文，小时候仰望半夜的星空时，似乎能看见宇宙的明明灭灭，后来我上了个二本大学，大三的时候，我没日没夜的学习量子场论，那简直是神才能窥见一角的东西” Loli回忆着自己的往事，给Tommy_clas叙述。 “可是后来我明白了，计算机科学才是未来，好好学OI吧，人类马上就要毁灭了，物理学走到了穷途末路，它不会再有什么用了。” Tommy_clas马上就要乘坐飞船走了，Loli来见他最后一面，Loli虽是顶尖的科学家，却固执的不愿随飞船离开。 COSMOS-1.A.D.2183太阳发生爆炸，人类在144年前耗费了地球的所有资源并穷尽了物理和数学知识建造了时空负质量反物质工质曲率推动能飞船，飞船上，所有人类实体完成了生物数据的量子化并依托于量子计算机形成意识，在宇宙航行中发现了一个新的星系，它位于银河系悬臂的边缘。 后来，包括Tommy_clas在内2756名人类到达了行星并开始了文明的重新建设，Tommy_clas却已经密谋好了一个毁灭人类、毁灭宇宙的惊天阴谋，为此，Tommy_clas花费了2^19260817个星系的资源，建造了长达数亿亿光年长的粒子加速器，环绕了银河系998244353圈。 COSMOS-1.A.D.25319“两万三千年了”Tommy_clas叹道，今天就是人类史上最伟大的一天，他在飞船上时把自己的人脑扫描并编码成了数据并成为了一个量子计算机中的意识体的时候，他的能力呈几何能级上升，并达到了真正破解宇宙秘密的程度。然而其他人不知道的是，粒子试验后，宇宙将在$1s$内湮灭，他却没有对任何人提起过这件事，因为他修改了宇宙的数学原理。 他打开了长达$2^{1024^{1024}}PB$长的代码，在量子意识中将轨道使用量子场论再次计算后，按下了编译键。程序开始运行了，与此同时引力波发生器开始广播，将Tommy_clas大脑的数据全部发送出去，并在宇宙毁灭前那一刹那将与其相连的需要产生毁灭宇宙等级的能量才能获得解开统一场方程关键数据的粒子对撞机数据观测器产生的数据编码成引力波发送了出去。 COSMOS-1.A.D.25320宇宙坍缩成了奇点，再一次爆炸，引力波的信息没有损失，到达了这个新的宇宙，引力波传递着，漫无边际，在空间震荡起一阵阵的涟漪，荡漾的微波承载着毁灭宇宙才换来的解开统一场方程的粒子对撞数据。 COSMOS-1.A.D.25320 \quad COSMOS-1毁灭 引力波我没有对其他人说的是，在我成为量子意识体的时候，计算出了宇宙并非是自然模型而的确是上层空间的一个高阶物理单位形成的物理结构意识模拟体，偶然间我发现了一些预留的接口，我感到了深深的无力感，原来自己的生命竟是这样的毫无意义，我明白了这个世界只需要自己去毁灭，去创造，我虽然无法到达上一次的物理空间，仅仅只是一个更加未知的事物的运行结果。 我却明白自己可以修改整个宇宙了，转瞬间我却又觉得这样更加毫无意义，我知道该做什么了，我使用接口删除了量子力学的选项，并使世界演化的概率性消失，这样宇宙就会按照牛顿力学一样在一个确定的时间点有一个确定空间物质状态了，我又调用了上层世界的计算能力计算出了再一次演化出相同宇宙但是人类却能生活到宇宙最后一刻毁灭太阳不会爆炸的情况的初始状态与宇宙常量，并在代码中一一修改了掌控着世界运行的规律的程序代码与常量。 宇宙运行代码文档的信息量超出了引力波的携带量，我把最重要的接口和信息发送了，剩下的文档随机一些页码发送数据。 宇宙代码系统 服务器系统 [文档]宇宙服务器远程连接物理设施制造蓝图 [二进制文件]服务器连接校验应用程序 [二进制文件]综合开发工具及编译器 文档 [文档]宇宙总能量调整接口 [文档]宇宙物理信息获取接口 [文档]宇宙物理常量修改接口 [文档]上层世界计算调用接口 [文档]宇宙运行代码修改指令 [文档]宇宙运行代码语法文档 [部分丢失][文档]宇宙运行代码文档 统一场方程 统一场方程关键数据 统一场方程研究结果 操作手册 恢复量子力学及世界概率性。 解出统一场方程并继续研究。 我确认过了进入上层世界的方法，但引力场方程是必要的，因为宇宙接口并没有给出最关键的引力物理操作接口，这也许是这个系统最本源的地方，给程序唯一没有作用的主函数接口中提供引力场方程即可运行主函数，这可能是这个宇宙的意义所在。 P.S.不要随意调用接口，其对宇宙的效果是不可逆的。 当你们收到此引力波信息后，将存在发生超出现有科学认知事件的可能性。 COSMOS-2宇宙竟然像Tommy_clas预期的那样完全按上一个宇宙的演化过程，每一个粒子都不曾偏离预期的轨迹，每一点物质都按照方程那样的演化。 宇宙再一次演化出了人类，终于时间线再一次地来到了人类公元纪年法的2019年 COSMOS-2.A.D.2019.09.23Tommy_clas有一种预感，会不会引力波能携带一些本不可能存在的信息？他想试试接收引力波，或许能有一线生机。 他找到了Loli，Loli是他最信任的朋友，也是一名物理学家，Tommy_clas说服Loli一起寻找最后的希望。 意料之外的是，他们接收到了引力波，而且明显是经过了一定的编码的，Tommy_clas感到很惊奇。 Tommy_clas拿到了上一个宇宙自己发送的引力波，还原出了其携带的信息，他和Loli一起研究，用了五天时间推导出了统一场方程，统一了引力场，强相互作用力场，弱相互作用力场，电磁场。 他们准备开始建设设施研究宇宙代码！ COSMOS-2.A.D.2019.09.30夏末秋初的微风吹过，一点点凉意轻轻经过，北半球九月末的微光斜照进玻璃窗，有些泛黄，而又有些许刺眼，空气中的尘埃折射出金黄色的线，这是每一年的循环。 “九月为什么只有三十天呢”，ArachnidaKing说，“今天我们出发去青岛！”空气还是那样宁静，就如同那时候一样，秋天高空的空气愈发稀薄，云只有稀松而淡淡的几缕，引擎声轰鸣了起来。 “空气中总是有些泥土的香气呢”XCiyang说，“是放线菌在哪里吗？”阳光的角度不断增加，高速公路上沥青折射出了亮度不同的光芒，就像世界的分崩离析的前夕。“世界线总是在不停分离着，这是一棵树”ArachnidaKing说。“不你错了”XCiyang淡泊的说了两句，“时间线才会不停交织着，这是平行的序列。” 他们笑起来，感觉到了彼此话语的荒诞。地图上离青岛的距离越来越近了，天空一点点变蓝，从前是那淡淡的蓝，现在是深一些的蓝色，就像那过往仰望的蓝天一样。 “这是梦境吗，”XCiyang望着车窗外运动的物体。“世界是不是物质的呢？”清新的海风呼啸过窗边，空气湿润了几许，“一如从前而又截然相反吗”XCiyang说，“这是梦吗？”“远处的光芒的的确不太合理，位置上不合理吗，这却不符合常理，天色刚刚不沉闷呢”ArachnidaKing说着，一行人陆陆续续的下了车。 他们只是名义上来这里度假的物理学组织，一共有10多个人。“不要总是这么不认真，”Tommy_clas说。“大家要严肃一点，这次任务事关重大。”太阳渐渐西斜了，最后的红色余晖斜映在城市与海岸线的交界处。 已经过了晚上12点了，“不想这么早睡……”XCiyang还是拿出了笔记本，熟练地打开了VSCode，写了一段C++程序上传到服务器上计算了一些白天想到的物理问题，望向窗外的繁星点点，他感到了梦境般的快乐。 “有点晚了吧”他想，扭头再看看屏幕，他注意到了刚刚没有注意到的一些小异样，日期怎么还是2019.09.30？“Windows不会出这样的bug吧？”他自言自语道。也并没有想那么多，起身躺到了床上，困倦的他很快睡着了。 COSMOS-2.A.D.2019.10.01XCiyang揉了揉眼睛，窗外的太阳升起了四分之三。 “没了，怎么醒得这么早。”他想了想，还是起床了。 SRP(1条未读消息)Tommy_clas：吃完早饭来7楼的会议室开会。 “什么情况？”XCiyang走向卫生间。“这么早就开始行动？” “……” COSMOS-2.A.D.2019.10.01.A.M.7:06 \quad [数据删除]酒店会议室成员到齐。 “今天我们出发去建设第一个大功率电磁波发射器，”Tommy_clas。“用途还不能明确告诉你们，大致是要与宇宙的一些地方进行通讯。” “用来干什么？”ColorfulMist问。“咱们人这么少？什么时候可以自己建设大型设施了？” “我获得了一些信息，用一些设计手段可以造出来。”Tommy_clas说。 “听着真科幻，可是为什么还要用电磁波呢？”Bj_2002说。 “很遗憾，到了今天我们还是不得不使用电磁波，不过应该问题不会太大的，因为不用传播太远，而且只需要定向一个方向。”Tommy_clas说。 “那还旅游吗？”Taduro说。“不是说为了庆祝物理学大突破出来玩的吗？” “统一场方程都破解了啊”所有人说。 有几个人说：“不过你可没告诉我们实验数据是怎么来的啊，现在只有你懂这方面的内容啊。” “当然，现在的工作非常轻松，”Tommy_clas说。“咱们可以玩上几天。” “方程的事，”他说。“等到一定工作完成后我会告诉你们的。” COSMOS-2.A.D.2019.10.01.A.M.11：49 \quad 青岛市[数据删除]KFC“这出来是玩的吗，真爽啊！”ArachnidaKing边说边拿起鸡腿吃。 COSMOS2.BRANCH1 COSMOS-2.BRANCH1.A.D.2019.09.31这是梦境吗，睡意朦胧的XCiyang醒了，带着些许的疲倦他轻轻地拨开了窗帘，天还没亮吗？好黑啊，他揉了揉眼睛。 咚咚噔，一阵敲门声不期而至，意识还是朦朦胧胧地他打开了房门，还没明白这是怎么回事，顺便看了看手表，是4点半，没有什么问题，只是敲门的什么人，这么早起床吗？他感到有些奇怪。 他不自然地走向了门口。 “是谁？”XCiyang说话了。 “收拾一下赶快出来吧，我是Tommy_clas，”门外说话的口气似乎有点奇怪。“有些不对劲，像是出事了！” “总感觉有什么地方不对啊”XCiyang手上的动作放缓了，他没有立即选择开门。 “先看一眼手机，”XCiyang小声嘟囔。“什么情况啊？” XCiyang吓了一跳：手机上显示今天是2019年9月31日。 “你是谁？”XCiyang从门口的猫眼看了一眼，确信没什么问题。“唉，吓死了……”边说着他打开了房门。 “这是怎么回事？”XCiyang问。 “只是出了点小问题，我也不知道为什么？早上四点的时候Genius_Z给我打来了电话，让我抓紧叫大家起来。” XCiyang说：“他昨天没睡觉吧？是在玩游戏？？” “这不是很重要，”Tommy_clas回应道。“回头，看看窗外。” 窗外漆黑一片，没有任何光线。 “这个亮度很不正常”XCiyang说。 “事实上没有亮度了，你是不是没睡醒？”Tommy_clas有些着急地说。“对了你的日期显示正常吗？” XCiyang没有说话，打了个手势便匆忙向外走。 “等等，你要干什么？”Tommy_clas立即询问道。“我跟你一起！” “先去看看这是怎么一回事，”XCiyang很烦。“真是蛤，莫名其妙的。” XCiyang走到了电梯口，按下了按钮。 他们住的是酒店的12楼，也是顶楼，电梯缓缓地从5层楼上升到了11层。 叮————，电梯门打开了，他和Tommy_clas走了进去。 “我觉得这样有点冒失，”Tommy_clas说。“这种情况可能不符合已有的科学知识。” “谁信这个？”XCiyang说。“宇宙的秘密都快要破解了，还有什么东西会拿我们开玩笑？” XCiyang从包里拿出了带有GPS定位装置的荧光棒：“来看看是什么情况。”他显得不怎么慌张：“还有几个人没有醒，发送紧急命令了吗？” “Genius_Z昨晚没有睡，找你的时候我刚刚起来，因为没确定什么情况所以就没有通知大家，”Tommy_clas回答他说。“应该都还没醒。” SRP是使用研究机构服务器搭建的IM（即时通讯软件），为了保护信息安全，他们都使用这个服务用于日常交流，并且其中内嵌了ArachnidaKing所开发的人工智能SAA，精通物理学，可以快速计算分析，平常也会和大家聊天，负责管理通讯系统和提供帮助。 Tommy_clas拿出了出手机检查消息： SRP(4条未读消息)9月31日4:27 Genius_Z：什么情况？到现在4点了没睡觉，窗外漆黑一片的？日期变成了2019/9/31？？？？ SAA：Genius_Z使用指令{声音通知}(Tommy_clas) Tommy_clas：我先去找XCiyang吧，他比较有经验 Tommy_clas：先别着急，没有别的异常情况吧 9月31日4:34 XCiyang：我和Tommy_clas先去检查一下情况，不用担心 Genius_Z：不通知大家吗？ ArachnidaKing：怎么都起的这么早，有什么事吗？ XCiyang：先冷静，我和Tommy_clas去检查情况了 先不要着急通__ 发送电梯平稳地下落，到达了1楼。 “这么早出来真的有点奇怪，”Tommy_clas收起手机自言自语。“啊？酒店门外是纯黑色的吗？” “走，我们过去。”XCiyang快步移向酒店前台。 “有人吗？”XCiyang说。 “……” “先看看门外”XCiyang回头对Tommy_clas说。 “没什么毛病，”Tommy_clas打开了手机上的GPS设备监测系统。“荧光棒的定位就显示在酒店内部。” “来试试，”XCiyang打开酒店大门把荧光棒向外一扔。荧光棒照亮了一小片区域，看起来没什么异样。“问题不大，查查这个地区的照明系统吧。” “艹，不对！”Tommy_clas惊叫起来。“你的荧光棒扔出大门所在平面的一刻，GPS信号立即消失了！” “嘶，可它不就在外面吗？看的见啊”XCiyang回答说。 “不要轻举妄动，先把大家都叫起来吧，”Tommy_clas沉着的说，“不要跨过酒店的大门！” “走，上楼。”Tommy_clas边说边拿出了手机。 SRP(1条未读消息)XCiyang：先冷静，我和Tommy_clas去检查情况了 9月31日4:38 Genius_Z：你们好了吗 /info urgent entity 立即到7楼会议__ 发送两个人快步走到了电梯口，Tommy_clas按下了上行按钮。 电梯显示屏幕的红色文字不停地变换着，光穿透着空气，灰尘粒子漂浮着。 “电梯有异常现象，”XCiyang说。“是随身物理现实检测器告诉我的，建议一会不要乘坐电梯。” “不过倒是没看出来有什么不对。”Tommy_clas回答道。 COSMOS-2.BRANCH1.A.D.2019.09.31.A.M.4:51 \quad [数据删除]酒店会议室XCiyang打开了手机： SRP(11条未读消息)9月31日4:41 SAA：Tommy_clas使用指令{声音通知}[紧急](所有实体) Tommy_clas：立即到7楼会议室集合！ RiverFun：艹，起的太早了吧 Bj_2002：马上来…… Victor：不大行，出什么事了？ ArachnidaKing：SAA，能解释一下吗？ SAA：检测到空间发生超出人类原有认知的异常 ArachnidaKing：……太奇怪了 JuanFeng：这不可能？ Ctz:真的挺有意思的啊 9月31日4:48 Tommy_clas：没来的人呢？大家尝试联系一下。 为什么还有人没有来？是还__ 发送过了几分钟，在SRP中回应过的人陆续到达了现场。“清点一下还剩几个人没有来？”Tommy_clas发话了。 “不要等了，立刻行动，先去找他们！”JuanFeng提出建议。 “可以！”其他人说。 一行人迅速从楼梯前往12楼。 “为什么不走电梯？”Bj_2002说。 “先别管这些了，”Tommy_clas说。“现在情况很不明确，我们要选择风险比较小的方式行动。” COSMOS-2.BRANCH1.A.D.2019.09.31.A.M.5:02 \quad [数据删除]酒店第12楼层“ColorfulMist？”Tommy_clas说。“你在干什么？” “……” 没有应答。 与ColorfulMist的联系失败。 Tommy_clas想起了文档里的一句话。 “破门！”他命令道。 虽然他们是物理科学家，但是Tommy_clas从收到那份不平常的文档开始，就为全组人员配备了特种装备和紧急情况下应对事件的工具。 对ColorfulMist的房间观察显示其房间没有入住过的迹象。 “判断人员ColorfulMist已损失”XCiyang说。 “好吧，”Genius_Z说。“现在这种shit事已经超出我的想象了。自己玩吧，我要出去转转。” “不要！”Tommy_clas说。 Genius_Z已经跑到了电梯边上。 “追不上了！”Bj_2002冷静的说。“先去找剩下两个人” “Taduro？还在吗？……？？？” “啊？”门内传来声音。“怎么都起得这么早？不睡觉……了吗！” “唉，”众人说。“快出来，出大事了！” “Asuldb？在不在？” “……” 没有应答。 与Asuldb的联系失败。 “强行进入！”Tommy_clas大声说。 对Asuldb的房间内部观察其呈现出酒店外部空间同样性质 停止对Asuldb房间的探索。 “判断人员Asuldb已损失”XCiyang说。 SAA发来警报：Genius_Z的GPS定位信号在$3s$前丢失，地点在酒店门口。 “尝试对Genius_Z进行无线电联系”XCiyang说。 SAA：与Genius_Z的联系失败。 “不如我们也出去玩玩？”ArachnidaKing说。“只是空间异常而已，不会有什么事。在这里能有什么进展，今天本来不是要工作的吗？” “你疯了吗？”Victor说。“这不是科学能解释的现象。” “是不是你……”Victor对Tommy_clas说。 “好吧，我把之前向你们隐瞒的事和你们大致讲一下”Tommy_clas长舒了一口气。]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>科幻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建及material主题使用指南]]></title>
    <url>%2F2019%2Fblog%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019.10.17 前端真好玩qvq 使用GitHub Pages搭建Hexo博客博客出现问题首先可以阅读文档，其次可以Google解决. 建议搭建完成以后首先看这个文档 Hexo中文文档 然后阅读主题的文档，这个主题的网页文档挂了，可以克隆repo的markdown源代码到本地看 Step1 | 下载软件安装Git 安装node.js Step2 | 创建GitHub账号注册 创建库 将本地ssh和远程库绑定 Step3 | 使用Git进行搭建操作hexo init Step4 | 写作、美化及功能修改Markdown相关问题表格合并单元格markdown表格支持功能很少，合并单元格只能用HTML markdown可以直接插入HTML代码 用http://www.tablesgenerator.com/html_tables编辑可以直接生成HTML代码 插入视频在Bilibili、Youtube等网站可以直接获取视频外链的HTML代码，在markdown中插入即可，长宽可能需要调整 Material主题配置及修改记录这个主题一些好的教程 Hexo入坑教程-Material Aplayer克隆&lt;https://github.com/MoePlayer/APlayer&gt; 放一下我的music.js，一中午用手肝了1.5h粘出来的=_=也没写脚本之类的东西（不怎么好写，只挑了一部分vocaloid的歌，大部分都是中v。如果你喜欢中v的话，可以康康？参数什么的没有全部设置。 因为没法折叠而且太长了，在文章最后放。 live2d看板娘 [blogの搭建之next——ctz’s blog(https://ctz45562.github.io/2019/03/21/blog%E3%81%AE%E6%90%AD%E5%BB%BA/) 有一些问题还参考了github-repo的README. git clone https://github.com/stevenjoezhang/live2d-widget 文件夹live2d-widget放到\themes\主题名称\source下,打开文件夹里的autoload.js修改为 const live2d_path = &quot;/live2d-widget/&quot;; 这个文件夹的名字可以自行修改. 打开\themes\主题名称\layout\_layout.swig/ejs这个文件 在&lt;body&gt;内的开头添加 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;/&gt; 在&lt;/body&gt;上方添加 &lt;script src=&quot;/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 不同之处可以自行修改layout.ejs文件 黑幕效果 如何实现黑幕 添加CSS //黑幕 .heimu,.heimu a{ background-color: #252525; color:#252525; text-shadow: none; }::selection{ background:#9ab0c0; color:#fff; } //鼠标悬停 .heimu:hover,.heimu:hover a{ transition:color .13s linear; color:#fff; } 使用直接插入HTML &lt;span class=&#39;heimu&#39; title=&#39;你知道的太多了&#39;&gt;黑幕测试&lt;/span&gt; 效果 黑幕测试 添加Gitalk评论主题实现好了一些评论的配置，具体看主题的文档即可。 Gitalk 和 Gitment 一样都是一个基于 GitHub Issue 的评论系统。在完成 GitHub Oauth App 的申请并获取 key 后，在主题配置文件中填入 gitalk_repo gitalk_owner gitalk_client_id gitalk_client_secret 参数即可。 在主题配置文件里修改这几项即可，repo可以用博客的，后两项需要用到GitHub Oauth App的API，搜索引擎自行解决即可。 comment: use: gitalk gitalk_repo: # git repo of the hexo gitalk_owner: # git repo&#39;s owner gitalk_client_id: # github app client id gitalk_client_secret: # github app client secret GitHub限制label长度gitalk无法创建issue GitHub限制label长度导致gitment/gitalk可能无法创建issue #622 对于全新安装有如下解决方案，解决方案如下：hexo根目录\themes\material\layout\_widget\comment\gitalk在此目录下编辑main.ejs文件在其中新增如下内容 &lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt; 在gittalk下增加id属性，增加后完整文件内容如下： &lt;!-- Gitalk 评论框 --&gt; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var gitalk = new Gitalk({ clientID: &#39;&lt;%= theme.comment.gitalk_client_id %&gt;&#39;, clientSecret: &#39;&lt;%= theme.comment.gitalk_client_secret %&gt;&#39;, repo: &#39;&lt;%= theme.comment.gitalk_repo %&gt;&#39;, owner: &#39;&lt;%= theme.comment.gitalk_owner %&gt;&#39;, admin: [&#39;&lt;%= theme.comment.gitalk_owner %&gt;&#39;], id: md5(window.location.pathname), // facebook-like distraction free mode distractionFreeMode: false }) gitalk.render(&#39;gitalk-container&#39;) &lt;/script&gt; Blog内容搜索安装hexo-generator-search插件 修改主题配置文件 search: use: local swiftype_key: 修改hexo配置文件： search: path: search.xml field: all markdown文件名大小写问题参考：Hexo 常见问题 | py’s blog 问题：当在本地改变md文件的大小写时，部署到GitHub 上后，改变了文件名的博客不能被访问。原因：Hexo默认的git操作会忽略大小写。解决： 修改根目录下.deploy_git/.git/config文件，将ignorecase的值由true改为false 删除.deploy_git目录下除.git目录外的其他文件 cd到.deploy_git目录下，手动做一次推送git add . git commit -m &quot;delete all hexo generated files&quot; git push 重新生成并部署hexo g hexo d CSS的修改文章框体透明打开Blog\themes\hexo-theme-material-1.5.6\source\css打开style.min.css搜索#scheme-Paradox .material-layout .mdl-card的第一项，在其中添加background-color: rgba(255,255,255,0.8) !important; Tag颜色及悬停颜色.material-tagscloud a{ background-color: rgba(255,255,255,.9); text-decoration:none; padding: 1px 9px; margin: 9px 1px; line-height: 40px; white-space: nowrap; transition: .6s; opacity: .85; } .material-tagscloud a:hover{ transition: .6s; opacity: 1; background: rgba(156,241,150,.7) !important; box-shadow: 0 2px 2px 0 rgba(0,0,0,.14), 0 3px 1px -2px rgba(0,0,0,.2), 0 1px 5px 0 rgba(0,0,0,.12); } copyright位置#scheme-Paradox .mdl-mini-footer--right-section { margin-right: 25px; } #scheme-Paradox #copyright { margin-left: auto; margin-right: 25px; text-align: center; } MathJax主题配置文件中的mathjax 引用cdnhttps://cdn.bootcss.com/mathjax/2.7.0/MathJax.js$\LaTeX$换行因为某些网页渲染的原因把\\换为\\\\即可. 修改hexo的渲染规则可以避免LaTex代码出现问题： https://docs.nexmoe.com/hexo/math.html#%E4%BD%BF%E7%94%A8kramed%E4%BB%A3%E6%9B%BF-marked MathJax测试 \begin{array}{|rc|} \hline \verb+\color{black}{text}+ & \color{black}{text} \\ \verb+\color{gray}{text}+ & \color{gray}{text} \\ \verb+\color{silver}{text}+ & \color{silver}{text} \\ \verb+\color{white}{text}+ & \color{white}{text} \\ \hline \verb+\color{maroon}{text}+ & \color{maroon}{text} \\ \verb+\color{red}{text}+ & \color{red}{text} \\ \verb+\color{yellow}{text}+ & \color{yellow}{text} \\ \verb+\color{lime}{text}+ & \color{lime}{text} \\ \verb+\color{olive}{text}+ & \color{olive}{text} \\ \verb+\color{green}{text}+ & \color{green}{text} \\ \verb+\color{teal}{text}+ & \color{teal}{text} \\ \verb+\color{aqua}{text}+ & \color{aqua}{text} \\ \verb+\color{blue}{text}+ & \color{blue}{text} \\ \verb+\color{navy}{text}+ & \color{navy}{text} \\ \verb+\color{purple}{text}+ & \color{purple}{text} \\ \verb+\color{fuchsia}{text}+ & \color{magenta}{text} \\ \hline \end{array}自定义页脚sns链接 Hexo Material主题之 footer SNS定制 svg图标如果在CSS里写实在还有问题放一个文件直接引用也可以. sns换到右边把ejs文件里的left改为right即可. licenselicense: ‘本文由 Name 原创，采用保留署名-非商业性使用-禁止演绎 4.0-国际许可协议‘ 鼠标点击烟花特效themes/主体名称/source/js/src新建fireworks.js文件 &quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)}&quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)}; 在themes/主体名称/layout/_layout.swig/ejs的&lt;/body&gt;上方添加 &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt; 一些主题的小问题独立页面toc不是默认为true的，需要手动开 toc: true 独立页面的license会在最后加上index.html，点击这个链接会导致gitalk再次创建issue，目前没有去解决. 天坑咕了很久全忘了，觉得以后再修blog就凉了，有空就填。 修改后没记录代码高亮 功能页面 | 独立页面 material图标 想添加的功能jsdelivr 插入pdf rss订阅 代码复制功能 鼠标特效fireworks遮挡 文章头图自定义 js时间统计，页脚动态效果 hexo-addlink 文章置顶 字体，代码字体 背景js动态效果 文章头图 Site Information npm install hexo-math —save Git指令常用指令克隆 git clone repo 克隆分支 git clone -b branch_name repo 上传文件 git add . git commit -m &#39;update_name&#39; git push origin branch_name Hexo指令 hexo init hexo clean g d hexo s hexo new name categories 分支https://zdran.com/20180326.html 创建源文件git目录 git init git remote add origin https://github.com/xx/xx.github.io // 填入你的repo地址 创建分支 git checkout -b branch_name git add . git commit -m &#39;add branch_name&#39; git push origin branch_name 切换分支 git checkout branch_name const ap = new APlayer({ container: document.getElementById(&#39;aplayer&#39;), fixed: true, autoplay: false, theme: &#39;#FADFA3&#39;, loop: &#39;all&#39;, order: &#39;list&#39;, preload: &#39;none&#39;, volume: 0.33, mutex: true, listFolded: true, listMaxHeight: &#39;233px&#39;, lrcType: 3, audio: [ { name: &#39;My Soul,Your Beats!&#39;, artist: &#39;麻枝准&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=28699614.mp3&#39;, cover: &#39;https://p2.music.126.net/tw0Vs85YAsvUpDsM7f2JMQ==/109951163914291289.jpg&#39;, lrc: &#39;/./aplayer/lrc/none.lrc&#39;, theme: &#39;#9370DB&#39; }, { name: &#39;世末歌者&#39;, artist: &#39;乐正绫 | COP&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=429460239.mp3&#39;, cover: &#39;https://p1.music.126.net/sZGaAxUHHhuhQ1Zxa2jw4g==/17790098137764958.jpg&#39;, lrc: &#39;/./aplayer/lrc/smgz.lrc&#39;, theme: &#39;#EE0000&#39; }, { name: &#39;同归世界线&#39;, artist: &#39;乐正绫 | COP&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=35807133.mp3&#39;, cover: &#39;https://p2.music.126.net/EnQ0J1f_-p8S2OunnRiGhA==/3298534885062503.jpg&#39;, lrc: &#39;/./aplayer/lrc/tgsjx.lrc&#39;, theme: &#39;#EE0000&#39; }, { name: &#39;凉雨&#39;, artist: &#39;洛天依 | COP&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=477137425.mp3&#39;, cover: &#39;https://p1.music.126.net/COB5xLS-nDUdCvzBSw0eOg==/109951162924485415.jpg&#39;, lrc: &#39;/./aplayer/lrc/ly.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;唱给雅音宮羽Ⅱ&#39;, artist: &#39;洛天依 | 純白P&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=29784378.mp3&#39;, cover: &#39;https://p2.music.126.net/a61wnSbpl7iz4juzmlq-gA==/6641050233030998.jpg&#39;, lrc: &#39;/./aplayer/lrc/cgyygy2.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;繁华唱遍&#39;, artist: &#39;洛天依 | URUUT&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=1362645677.mp3&#39;, cover: &#39;https://p2.music.126.net/Ytdbz--Ui1u_Mvosiv7C1w==/109951164042650892.jpg&#39;, lrc: &#39;/./aplayer/lrc/fhcb.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;小小思念&#39;, artist: &#39;洛天依 | 純白P&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=28987160.mp3&#39;, cover: &#39;https://p2.music.126.net/L8eZSVnPcNSTXmxMd36gEg==/8976412929211156.jpg&#39;, lrc: &#39;/./aplayer/lrc/xxsn.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;时间日记&#39;, artist: &#39;洛天依 | 湯ん&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=555103145.mp3&#39;, cover: &#39;https://p1.music.126.net/mwQhrhXSrt7NbR0EX_NLDg==/109951163129515683.jpg&#39;, lrc: &#39;/./aplayer/lrc/sjrj.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;寻遍星空&#39;, artist: &#39;洛天依 | 公兔&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=29307542.mp3&#39;, cover: &#39;https://p2.music.126.net/VDzqLf2w5SV-VU1FH1AwNg==/6657542906420975.jpg&#39;, lrc: &#39;/./aplayer/lrc/xbxk.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;岁月流年&#39;, artist: &#39;洛天依&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=29792008.mp3&#39;, cover: &#39;https://p2.music.126.net/vkoQqphGwk6TyRFai3ZBdw==/3238061743857732.jpg&#39;, lrc: &#39;/./aplayer/lrc/syln.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;天空的味道&#39;, artist: &#39;洛天依&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=29450488.mp3&#39;, cover: &#39;https://p1.music.126.net/Dqgbz3BMQG3w5dzs9s3-Hw==/3284241233862965.jpg&#39;, lrc: &#39;/./aplayer/lrc/tkdwd.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;刹那烟火，落尽清凉&#39;, artist: &#39;洛天依 | 九御kyuugo&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=413188707.mp3&#39;, cover: &#39;https://p2.music.126.net/guXC-WPcWhXdIdzpmRMJ1w==/109951162942281449.jpg&#39;, lrc: &#39;/./aplayer/lrc/cnyh.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;朝汐&#39;, artist: &#39;洛天依 | 千面音葉7ZH&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=1315517813.mp3&#39;, cover: &#39;https://p1.music.126.net/R_DVp-6qp8aJuXGetjzVmg==/109951163587343726.jpg&#39;, lrc: &#39;/./aplayer/lrc/zx.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;心跳同步的时光&#39;, artist: &#39;洛天依 | JUSF周存&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=422427110.mp3&#39;, cover: &#39;https://p2.music.126.net/CSmaT-E-XIMzqm2jqpsrJw==/18185922323824829.jpg&#39;, lrc: &#39;/./aplayer/lrc/xttbdsg.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;为了你唱下去&#39;, artist: &#39;洛天依 | COP&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=420397887.mp3&#39;, cover: &#39;https://p1.music.126.net/W3VMsSEjTdvhz7h3a0oxTg==/17782401556325576.jpg&#39;, lrc: &#39;/./aplayer/lrc/wlncxq.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;绝体绝命&#39;, artist: &#39;洛天依 | 阿良良木健&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=550059604.mp3&#39;, cover: &#39;https://p1.music.126.net/Csw9Gl-c5YDFLJggK-gpyw==/109951163696193010.jpg&#39;, lrc: &#39;/./aplayer/lrc/jtjm.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;春风来&#39;, artist: &#39;洛天依 | 阿良良木健&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=480243094.mp3&#39;, cover: &#39;https://p2.music.126.net/DPs2L7G6yXTAEvlCV3cEqQ==/109951162955968424.jpg&#39;, lrc: &#39;/./aplayer/lrc/cfl.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;勾指起誓&#39;, artist: &#39;洛天依 | ilem&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=1345872140.mp3&#39;, cover: &#39;https://p1.music.126.net/eMyCr0gv0kPGlew9XTNjyA==/109951163944178164.jpg&#39;, lrc: &#39;/./aplayer/lrc/gzqs.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;深海少女&#39;, artist: &#39;洛天依&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=29357538.mp3&#39;, cover: &#39;https://p1.music.126.net/yI0SluM1lL2NWofjbXr99w==/109951163926977151.jpg&#39;, lrc: &#39;/./aplayer/lrc/shsn.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;与你最后的夏天&#39;, artist: &#39;洛天依&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=33715419.mp3&#39;, cover: &#39;https://p2.music.126.net/vkoQqphGwk6TyRFai3ZBdw==/3238061743857732.jpg&#39;, lrc: &#39;/./aplayer/lrc/ynzhdxt.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;谷雨&#39;, artist: &#39;洛天依 | 桑葚上的猴子&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=410161057.mp3&#39;, cover: &#39;https://p2.music.126.net/UL_YbIkPg9t6UFpmTRxMPw==/18198016951571087.jpg&#39;, lrc: &#39;/./aplayer/lrc/gy.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;咸咸的&#39;, artist: &#39;洛天依 | 純白P&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=484710046.mp3&#39;, cover: &#39;https://p2.music.126.net/-mSe3PXd0x66UZQRmip9qQ==/109951162950201713.jpg&#39;, lrc: &#39;/./aplayer/lrc/xxd.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;前尘如梦&#39;, artist: &#39;洛天依 | 唐乐林&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=27908599.mp3&#39;, cover: &#39;https://p1.music.126.net/A9oKNYp-KPOv_TrMG5ml6w==/3405187512278986.jpg&#39;, lrc: &#39;/./aplayer/lrc/qcrm.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;梨花泽泽远山远 &#39;, artist: &#39;洛天依 | MeLo&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=425710799.mp3&#39;, cover: &#39;https://p2.music.126.net/vjwCPafPafceVxULtWFSfg==/18020995579444517.jpg&#39;, lrc: &#39;/./aplayer/lrc/lhzzysy.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;夏天·延长战&#39;, artist: &#39;洛天依 | DOS:Error#&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=499272397.mp3&#39;, cover: &#39;https://p2.music.126.net/ww_5Ayf5s-vwP-GSgEKMwA==/109951163032306409.jpg&#39;, lrc: &#39;/./aplayer/lrc/xtycz.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;一秒之序&#39;, artist: &#39;洛天依 | PoKeR&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=433059462.mp3&#39;, cover: &#39;https://p1.music.126.net/irEm-wZzV8zfbtc4UqKsyg==/17999005346907532.jpg&#39;, lrc: &#39;/./aplayer/lrc/ymzx.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;Last Natsu&#39;, artist: &#39;洛天依 | KAII&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=532815418.mp3&#39;, cover: &#39;https://p2.music.126.net/Jg7qB9BxGV0XJzkcWBEWEA==/109951163116417673.jpg&#39;, lrc: &#39;/./aplayer/lrc/lastnatsu.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;化尘旅行&#39;, artist: &#39;洛天依 | Tuno桐音&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=33854157.mp3&#39;, cover: &#39;https://p2.music.126.net/vkoQqphGwk6TyRFai3ZBdw==/3238061743857732.jpg&#39;, lrc: &#39;/./aplayer/lrc/hclx.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;九尾妖狐&#39;, artist: &#39;洛天依 | PoKeR&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=550364401.mp3&#39;, cover: &#39;https://p1.music.126.net/yuPHEbEeTmxpTxMStl-lLw==/109951163230319367.jpg&#39;, lrc: &#39;/./aplayer/lrc/jwyh.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;异样的风暴中心&#39;, artist: &#39;洛天依 | 杉田朗&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=535915977.mp3&#39;, cover: &#39;https://p2.music.126.net/vKUpCUdQY3jWq8Vpr3R9Tg==/109951163632766055.jpg&#39;, lrc: &#39;/./aplayer/lrc/yydfbzx.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;被祝福的旅程&#39;, artist: &#39;洛天依 | DELA,雨狸&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=453352408.mp3&#39;, cover: &#39;https://p2.music.126.net/RC1fjVZmE50uTlxOWGspVg==/109951162842875584.jpg&#39;, lrc: &#39;/./aplayer/lrc/bzfdlc.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;trii - Feel Your Dream 2018&#39;, artist: &#39;洛天依 | 純白P&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=528634797.mp3&#39;, cover: &#39;https://p2.music.126.net/PKPVikQLZb4dqLDqCdqLWg==/109951163101308515.jpg&#39;, lrc: &#39;/./aplayer/lrc/fyd2018.lrc&#39;, theme: &#39;#66CCFF&#39; }, { name: &#39;逆浪千秋&#39;, artist: &#39;言和&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=542364335.mp3&#39;, cover: &#39;https://p1.music.126.net/z4f7Gfge3f1PkY90bozxPQ==/109951163169021511.jpg&#39;, lrc: &#39;/./aplayer/lrc/nlqq.lrc&#39;, theme: &#39;#99FFFF&#39; }, { name: &#39;梦之雨&#39;, artist: &#39;言和&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=29095492.mp3&#39;, cover: &#39;https://p2.music.126.net/YZ4EmG8r5T6XPj_1WBue-A==/3295236350128132.jpg&#39;, lrc: &#39;/./aplayer/lrc/mzy.lrc&#39;, theme: &#39;#99FFFF&#39; }, { name: &#39;岁月成碑&#39;, artist: &#39;乐正绫 | Days&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=34179200.mp3&#39;, cover: &#39;https://p2.music.126.net/W2ZKq9bj8Y0YgLyTLpQNew==/7930777373220204.jpg&#39;, lrc: &#39;/./aplayer/lrc/sycb.lrc&#39;, theme: &#39;#EE0000&#39; }, { name: &#39;烈火灼冰&#39;, artist: &#39;乐正绫 | 希望索任合资&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=525488258.mp3&#39;, cover: &#39;https://p2.music.126.net/V60ZQN_0tsWwsvQo2B2KQA==/109951163089698048.jpg&#39;, lrc: &#39;/./aplayer/lrc/lhzb.lrc&#39;, theme: &#39;#EE0000&#39; }, { name: &#39;千里邀月&#39;, artist: &#39;乐正绫 | 純白P&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=1332491711.mp3&#39;, cover: &#39;https://p1.music.126.net/0emegncinMnQQanyBvfK_w==/109951163718505451.jpg&#39;, lrc: &#39;/./aplayer/lrc/qlyy.lrc&#39;, theme: &#39;#EE0000&#39; }, { name: &#39;梦语&#39;, artist: &#39;乐正绫&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=33190543.mp3&#39;, cover: &#39;https://p2.music.126.net/0NsramhXlm6t4Kex3v2LSA==/109951163926966859.jpg&#39;, lrc: &#39;/./aplayer/lrc/my.lrc&#39;, theme: &#39;#EE0000&#39; }, { name: &#39;Artificial Emotions&#39;, artist: &#39;心华 | 純白P&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=415090258.mp3&#39;, cover: &#39;https://p2.music.126.net/naihNDWAJXSxy7UE3XVKEg==/17692241602844445.jpg&#39;, lrc: &#39;/./aplayer/lrc/arti_emo.lrc&#39;, theme: &#39;#EE82EE&#39; }, { name: &#39;我的海岸线&#39;, artist: &#39;心华 | 純白P&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=453278711.mp3&#39;, cover: &#39;https://p2.music.126.net/jpZu0Ykp1YCJ3xlcvYhbtA==/109951162842712103.jpg&#39;, lrc: &#39;/./aplayer/lrc/wdhax.lrc&#39;, theme: &#39;#EE82EE&#39; }, { name: &#39;我寻着光而来&#39;, artist: &#39;心华 | 著小生zoki&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=1323549392.mp3&#39;, cover: &#39;https://p1.music.126.net/8ipWcNy5FQu-0E8dRTt1Rw==/109951163651934410.jpg&#39;, lrc: &#39;/./aplayer/lrc/wxzgel.lrc&#39;, theme: &#39;#EE82EE&#39; }, { name: &#39;星雨之夜&#39;, artist: &#39;心华 | ilem&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=41672085.mp3&#39;, cover: &#39;https://p2.music.126.net/xZ6LySLSgYz98kO8mGbp4Q==/1387583675775967.jpg&#39;, lrc: &#39;/./aplayer/lrc/xyzy.lrc&#39;, theme: &#39;#EE82EE&#39; }, { name: &#39;我們的彈幕青春&#39;, artist: &#39;心华 | VelecTi&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=41672084.mp3&#39;, cover: &#39;https://p1.music.126.net/xZ6LySLSgYz98kO8mGbp4Q==/1387583675775967.jpg&#39;, lrc: &#39;/./aplayer/lrc/wmddmqc.lrc&#39;, theme: &#39;#EE82EE&#39; }, { name: &#39;绯焰悲空&#39;, artist: &#39;心华 | 純白P&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=415085220.mp3&#39;, cover: &#39;https://p2.music.126.net/b8Ubr5n4QytBg7Pc7O3pjw==/780653265867628.jpg&#39;, lrc: &#39;/./aplayer/lrc/fybk.lrc&#39;, theme: &#39;#EE82EE&#39; }, { name: &#39;万神纪&#39;, artist: &#39;星尘 | 海鲜面&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=459831628.mp3&#39;, cover: &#39;https://p1.music.126.net/ygeaRVdHTDjylMZy8_bmSw==/109951162860064953.jpg&#39;, lrc: &#39;/./aplayer/lrc/wsj.lrc&#39;, theme: &#39;#9999FF&#39; }, { name: &#39;星愿StarWish&#39;, artist: &#39;星尘 | 平行四界Quadimension&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=506607859.mp3&#39;, cover: &#39;https://p1.music.126.net/Xl4Mp9uEudbnYQ79amRJWA==/109951162879679523.jpg&#39;, lrc: &#39;/./aplayer/lrc/xy.lrc&#39;, theme: &#39;#9999FF&#39; }, { name: &#39;一日都市&#39;, artist: &#39;星尘 | 小野道ono&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=494953325.mp3&#39;, cover: &#39;https://p1.music.126.net/wPE3Z922KRX5mo94eGgi5g==/109951162923791285.jpg&#39;, lrc: &#39;/./aplayer/lrc/yrds.lrc&#39;, theme: &#39;#9999FF&#39; }, { name: &#39;曙光&#39;, artist: &#39;星尘&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=496807835.mp3&#39;, cover: &#39;https://p1.music.126.net/0AZa9x1gcaPHQJNia6IvMA==/109951163031876680.jpg&#39;, lrc: &#39;/./aplayer/lrc/sg2.lrc&#39;, theme: &#39;#9999FF&#39; }, { name: &#39;時計塔中の白兎&#39;, artist: &#39;初音ミク | 純白P&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=435996054.mp3&#39;, cover: &#39;https://p1.music.126.net/7m5M903sHrRAoXplswrSdw==/18211211091317943.jpg&#39;, lrc: &#39;/./aplayer/lrc/jst.lrc&#39;, theme: &#39;#39C5BB&#39; }, { name: &#39;歌に形はないけれど&#39;, artist: &#39;初音ミク | doriko&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=409912.mp3&#39;, cover: &#39;https://p1.music.126.net/Pv6EyvmbbHhewnS5U-8dYw==/2493692371854828.jpg&#39;, lrc: &#39;/./aplayer/lrc/srgswx.lrc&#39;, theme: &#39;#39C5BB&#39; }, { name: &#39;morning haze&#39;, artist: &#39;初音ミク | keeno&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=34690740.mp3&#39;, cover: &#39;https://p1.music.126.net/s06UBcyrFpXUmAf_ly8jTQ==/2901611187579735.jpg&#39;, lrc: &#39;/./aplayer/lrc/morning.lrc&#39;, theme: &#39;#39C5BB&#39; }, { name: &#39;glow&#39;, artist: &#39;初音ミク | keeno&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=29023581.mp3&#39;, cover: &#39;https://p2.music.126.net/58JEcKKl34g-4s5v0RSb9Q==/6625657069114417.jpg&#39;, lrc: &#39;/./aplayer/lrc/glow.lrc&#39;, theme: &#39;#39C5BB&#39; }, { name: &#39;每颗流星都见证&#39;, artist: &#39;初音ミク | 小野道ono&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=526704382.mp3&#39;, cover: &#39;https://p1.music.126.net/KjqhDvfpxkzsrTJ74WV0Zg==/109951163094643593.jpg&#39;, lrc: &#39;/./aplayer/lrc/mklxdjz.lrc&#39;, theme: &#39;#39C5BB&#39; }, { name: &#39;冬去春来再尽年&#39;, artist: &#39;言和,乐正绫,心华,洛天依 | COP&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=413074063.mp3&#39;, cover: &#39;https://p1.music.126.net/pGnU2i0-iQMYyGECNWghUw==/18434411951503489.jpg&#39;, lrc: &#39;/./aplayer/lrc/dqclzjn.lrc&#39; }, { name: &#39;白石溪&#39;, artist: &#39;乐正绫,洛天依 | 純白P&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=415086297.mp3&#39;, cover: &#39;https://p2.music.126.net/naihNDWAJXSxy7UE3XVKEg==/17692241602844445.jpg&#39;, lrc: &#39;/./aplayer/lrc/bsx.lrc&#39; }, { name: &#39;β受体阻滞剂与星辰&#39;, artist: &#39;洛天依,言和 | Kevinz&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=447943681.mp3&#39;, cover: &#39;https://p1.music.126.net/FWNGckJvrMCQ2lCd7Ot89g==/109951162992552158.jpg&#39;, lrc: &#39;/./aplayer/lrc/beita.lrc&#39; }, { name: &#39;霜雪千年&#39;, artist: &#39;洛天依,乐正绫 | COP&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=34923862.mp3&#39;, cover: &#39;https://p2.music.126.net/vkoQqphGwk6TyRFai3ZBdw==/3238061743857732.jpg&#39;, lrc: &#39;/./aplayer/lrc/sxqn.lrc&#39; }, { name: &#39;深夜诗人&#39;, artist: &#39;洛天依,言和 | ilem&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=477936261.mp3&#39;, cover: &#39;https://p2.music.126.net/Bt3dFUR9xWCd8wJlmrsgXg==/3429376768564696.jpg&#39;, lrc: &#39;/./aplayer/lrc/sysr.lrc&#39; }, { name: &#39;普通DISCO&#39;, artist: &#39;洛天依,言和 | ilem&#39;, url: &#39;https://music.163.com/song/media/outer/url?id=31140522.mp3&#39;, cover: &#39;https://p1.music.126.net/FwrkRhTBoI9TNj3BkUy2Hw==/1364493965811296.jpg&#39;, lrc: &#39;/./aplayer/lrc/ptdisco.lrc&#39; } ] });]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「FFT/NTT」「多项式」]]></title>
    <url>%2F2019%2FFFT%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-08-15 必忘原理的FFT 测试一下视频，然而貌似只有bilibili的外链比较好总不能放Youtube？，然而鬼畜的二维码与顶部链接比前几年在mcbbs看的时候烂多了。 在2019年8月15日，终于看懂了FFT的推导过程。 首先是FFT的板子，这个写法其实很优美记不住的。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;complex&gt; #define R register using namespace std; const int N = 4.2e6; const double PI = acos(-1); int n, r[N]; class C { public: double r, i; C() { r = i = 0; } C(R double x, R double y) { r = x; i = y; } C operator + (R C&amp; x) { return C(r+x.r, i+x.i); } C operator - (R C&amp; x) { return C(r-x.r, i-x.i); } C operator * (R C&amp; x) { return C(r*x.r-i*x.i, r*x.i+i*x.r); } void operator += (R C&amp; x) { r += x.r; i += x.i; } void operator *= (R C&amp; x) { R double t = r; r = r*x.r-i*x.i; i = t*x.i+i*x.r; } }f[N], g[N]; inline void FFT(R C *a, R int op) { R C W, w, t, *a0, *a1; R int i, j, k; for (i = 0; i &lt; n; ++i) if (i &lt; r[i]) t = a[i], a[i] = a[r[i]], a[r[i]] = t; for(i = 1; i &lt; n; i &lt;&lt;= 1) for(W = C(cos(PI/i), sin(PI/i) * op), j = 0; j &lt; n; j += i &lt;&lt; 1) for(w = C(1, 0), a1 = i + (a0 = a + j), k = 0; k &lt; i; ++k, ++a0, ++a1, w*=W) t = *a1 * w, *a1 = *a0 - t, *a0 += t; } int main() { R int m, i, l = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(i = 0; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;f[i].r); for(i = 0; i &lt;= m; i++) scanf(&quot;%lf&quot;, &amp;g[i].r); for(m += n, n = 1; n &lt;= m; n &lt;&lt;= 1, ++l); for(i = 0; i &lt; n; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)); FFT(f, 1); FFT(g, 1); for(i = 0; i &lt; n; ++i) f[i] *= g[i]; FFT(f, -1); for(i = 0; i &lt;= m; ++i) printf(&quot;%.0lf &quot;, fabs(f[i].r) / n); return 0; } 咕，马上补.]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「动态规划」]]></title>
    <url>%2F2019%2Fdp%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-10-17 推不出的DP方程 随意记点动态规划的方程，大概是NOIP难度的。 Problem水题LuoguP1472 奶牛家谱 Cow Pedigrees题意：有$n$个结点$k$层的二叉树结构个数，树只能有$2$个儿子或$0$个儿子。 设$dp[n][k]$为有$n$个结点不到$k$层的答案，则答案容斥一下为$dp[n][k]-dp[n][k-1]$，转移从下把两棵树连接到上一层结点，枚举$t$为左子树节点个数，则右子树为$总结点个数-t-1$(1是减掉根)，乘法原理把两个乘起来，方程为 dp[i][j]=\sum dp[t][j-1]\times dp[i-t-1][j-1]正常题[SDOI2011]消耗战题意：给定$n$个点有边权的树，割断边花费边权，求使$k$个点与$1$点不连通的最小花费。 要用虚树做，写一下方程。 设$dp[n]$为使以$n$为结点的子树内关键点都不与$n$联通的最小花费，方程为 dp[u]=dp[u]+ \begin{cases} \min(dp[v],dist_{u,v})& \text{v不是关键点}\\ dist_{u,v}& \text{v是关键点} \end{cases}[ZJOI2010]排列计数题意：求一个$1\sim n$的排列$P_i$使$ 1\leq i \leq n$时$P_i&gt;P_{i/2}$的方案数。 直接做没什么思路，可以想一下除二的关系可以是二叉树，于是换到树上来做，求$n$个节点的二叉树满足小根堆性质树的个数。 设$dp[i]$表示以$i$为根的子树内满足小根堆性质的方案数，$s[i]$为树结点数，提前把一些越界的初值设为$1$以免判断，转移时组合数算一下选给左子树的点，记得减去根节点，乘一下两颗子树的方案数就ok了，组合数要用lucas，方程 dp[i]=C_{s[i]-1}^{s[i\times 2]}dp[i\times 2]dp[i\times 2+1][SCOI2008]奖励关题意：$m$种物品，给你n次随机在$1\sim m$间的物品，每种物品有价值并且选这种物品需要你在前$n-1$次把集合$S$内的物品种类都选过一次才可以选。 显然$m$非常小，那么求期望直接枚举就可以了，这样就好做了，然后在考虑一下如果顺推的话需要保证$S$的合法性，这个比较难处理，那么逆推显然更好写。设$dp[i][S]$表示取前$i-1$次的状态为$S$是期望的最大值，$pre[i]$为第$i$种物品的前提集合，方程枚举第i个选第k种 dp[i][S]=dp[i][S]+ \begin{cases} \max(dp[i+1][S],dp[i+1][S|(1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始的C++学习]]></title>
    <url>%2F2019%2FC%2B%2B%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-10-17 未全部完成! Visual Studio过于复杂 这篇内容质量低且还在弃坑当中建议不要阅读. 装了一下2017年装过一次却怎么没用过的Visual Studio，计划学习C++的OOP及C++11的语法后继续学习C++MFC. 文档：cppreference.com 资料：C++教程 书籍：《C++ Primer Plus》 C++ OOP类 对象class Hf{...};定义一个类 Hf xxx;声明一个类型为Hf的对象 访问数据成员用.即可 成员函数类定义内部的成员函数默认inline 在类的外部定义函数的话用范围解析运算符::定义成员函数 数据类型 类名::函数名() {} 调用函数用. 即可 类访问修饰符public公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值 private私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。 protected保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。 继承时，使用哪种修饰符父类便继承到哪一部分中 1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问； 2.protected 成员可以被派生类访问。 类构造函数 &amp; 析构函数构造函数就定义一个函数名为类名没有数据类型的函数，每次创建类的新对象时执行，默认是存在构造函数，所以如果定义了有参数的构造函数，一定注意要再定义一个无参数无内容的构造函数，不然不用带参数的构造函数用默认创建对象的话会出错.像这样玩就行，赋值可以像这样搞. struct node { int o, l, r, t; node() {} node(int o, int l, int r): o(o), l(l), r(r), t(ask(l, r)) {} friend bool operator &lt; (const node&amp; a, const node&amp; b) { return sum[a.t] - sum[a.o - 1] &lt; sum[b.t] - sum[b.o - 1]; } }; 析构函数名字是这样的~类名，这个函数再删除对象时执行.总之就是一个创建，一个删除时执行。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数论」]]></title>
    <url>%2F2019%2Fnumber_theory%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-08-09 只会GCD 取模(a+b) \bmod p=(a\bmod p+b\bmod p)\bmod p​(a-b) \bmod p=(a\bmod p-b\bmod p+p)\bmod p​(a\times b) \bmod p=(a\bmod p\times b\bmod p)\bmod p​求$\dfrac{a}{b}\bmod p​$时,求$b^{-1}​$使$b*b^{-1}\equiv1\pmod p​$即$b​$的逆元 有\dfrac{a}{b}\bmod p=a\times b^{-1}\bmod p 费马小定理定理：当$p​$是质数时$a^{p-1}\equiv 1\pmod p​$ 逆元：由$a^{p-1}\equiv 1\pmod p​$得$a\times a^{p-2}\equiv 1\pmod p​$ 即$a^{p-2}$是$a$在模$p$意义下的逆元 欧拉定理若$gcd(a,p)=1$则$a^{\varphi(p)}\equiv1\pmod n$ 当$p$是质数时$\varphi(p)=p-1$ 即$a^{p-1}\equiv1\pmod n$即费马小定理 GCD EXGCD#define ll long long ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; } void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) { if(!b) x = 1, y = 0; else exgcd(b, a % b, y, x), y -= a / b * x; } $gcd$用来求解$a，b$的最大公约数 $lcm(a,b)=\dfrac{a\times b}{gcd(a,b)}​$，lcm是最大公约数 $exgcd$用来求解$ax+by=gcd(a,b)$，证明大概是化式子构造递归的解法，反正看了也早晚会忘就是了逃 $exgcd$还可以求解$ax\equiv b\pmod p​$形式的同余方程 $exgcd(a,p,x,y)$求出来的$x$就是$a$关于$p$的逆元 CRT exCRT求解一个同余方程组 \begin{cases} x \equiv a_1 \pmod {m_1} \\ x \equiv a_2 \pmod {m_2} \\ x \equiv a_n \pmod {m_n} \end{cases}两种东西都可以通过exgcd两两合并同余方程求解，不过CRT可以直接构造出答案。 CRT求解的$p​$是质数，exCRT的不是，都可以用exgcd合并做。 推导参考这个blog：扩展欧几里得算法与中国剩余定理 CRT直接构造的解： 令$M=\prod m_i, M_i=\frac M{m_i}​$，$t_i​$为$M_i​$在模$m_i​$意义下的逆元 方程组的解为x \equiv \sum_{i=1}^na_it_iM_i \pmod M​ 筛法求$n$是不是素数直接枚举$1$到$\sqrt{n}$试除 埃筛 for(int i = 2; i &lt;= N; i++) if(!vis[i]) { prime[++cnt] = i; for(int j = 1; i * j &lt;= N; j++) vis[i * j] = 1; } 线筛 for(int i = 2; i &lt;= N; i++) { if(!vis[i]) prime[++cnt] = i; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; } }]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome浏览器 | 插件与设置]]></title>
    <url>%2F2019%2Fchrome%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-06-04 下载安装下载地址：Google Chrome 网络浏览器 插件Bookmarkie 插件栏弹出收藏夹，可搜索 书签侧边栏 侧边栏收藏夹 Wrona History Menu 插件栏弹出历史记录，最近关闭 Checker Plus for Gmail™ 查看Google邮箱 Click and Save 快捷键点击存图 CSS Peeper 抓取页面样式 Earth View from Google Earth 新页标签Google地球 Color Tab 新页标签配色设计 Save All Resources 下载控制台Sources全部文件 Steam Inventory Helper steam网页版市场工具 Speedtest by Ookla 墙外测速 Stylus 替换CSS样式 Tampermonkey 网页js脚本 Yet another flags 查看网页ip 沙拉查词 划词翻译 ImageAssistant 下载网页图片 Yet Another Drag and Go 四方向拖拽搜索，链接拖拽打开 pakku bilibili弹幕过滤 Aerys 插件栏查看窗口标签 操作左键单击 = 在当前窗口打开目标网页 Shift + 左键单击 = 在新窗口打开目标网页 Ctrl + 左键单击 = 在新标签页打开目标网页 Ctrl + Shift + T = 打开上一个关闭的标签页 Ctrl + Shift + B = 显示书签栏 Ctrl + D = 为此页添加书签 Ctrl + H = 历史记录 设置不在设置里出现的控制选项： chrome://flags 查看chrome账号同步情况： chrome://sync 地址栏中使用的搜索引擎改为google.com.hk 网页长截图1.按F12 2.按Ctrl + Shift + P 3.输入Capture full size screenshot并回车 截取手机版长图在1、2操作之间，按下Ctrl + Shift + M 选区截图1.按F12 2.按Ctrl + Shift + C 3.选中区域后去输入Capture node screenshot并回车]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网 | GFW与SSR简介]]></title>
    <url>%2F2019%2FGFW%2F</url>
    <content type="text"><![CDATA[Update on A.D.2019-05-31 Across the Great Wall we can reach every corner in the world. 由于一些政治原因，中国的网络环境非常特殊，不仅自身进行审查，且对外来信息也会进行审查，如果需要访问境外网站，使用一些境外服务及app则需要突破审查，俗称翻墙，科学上外，搭梯子等。在10010大进行了今年来最为严厉的网络审查，在此之后一些免费的fq软件都不甚理想。本文介绍GFW和常用的翻墙技术，以作备忘和对没有接触过fq的人作简单的了解。 推荐阅读：中国的互联网 _ neoFelhz’s Blog 墙与纸飞机 什么是GFW？出海光缆中国接入$Internet$的情况：世界海底光缆分布图 - 阮一峰的网络日志 中国出海光缆有$3$条，分别在青岛、汕头、上海，那么对为数不多的出海光缆控制一下、进行一下审查，便可以达到信息封锁的目的，这个技术的缩写叫做$GFW$，经常被称为墙，曾经由某$Hf$亲自主持建设。 GFW防火长城 - 维基百科，自由的百科全书 部分内容 现阶段防火长城已经具备干扰IPv6隧道的能力。 2013年对代码托管网站GitHub的审查和封锁 2013年1月20日，中国大陆政府的防火长城利用域名污染和关键词过滤等手段屏蔽 GitHub。但是，由于屏蔽引发了社会的强烈反应，最终解除了对GitHub的屏蔽。 Steam社区网站被屏蔽 Steam是世界最大的PC数字游戏平台，其社区网站被用于讨论和分享游戏经验。 Steam在中国也有着庞大的用户群，根据Steam Spy2017年底的报告， Steam的中国区玩家已经突破3000万，其不受中国监管的社群被认为带来了监管方面的挑战。 Steam自2015年开启人民币结算以来，曾多次因部分网民在社区发表违反中国法律的内容而遭到屏蔽， 在Valve配合删除相关违规言论并封禁违规用户后均解除了屏蔽。 但自2017年12月16日起，Steam除了商店，其他功能（社区、市场、库存、创意工坊）均被屏蔽， 方法是DNS污染和SNI RST，该屏蔽至今仍未解除，玩家需要使用加速器或在修改hosts的 同时使用本地反向代理等工具才能访问，但中国大陆部分地区的用户即使是使用了加速器或 本地反向代理，在访问社区的时候仍然会提示“您所在的地区不支持”，原因未知。 技术 主要技术 2.1 域名解析服务缓存污染 2.2 IP地址或传输层端口封锁 2.2.1 针对TCP和UDP连接的封锁 2.2.2 针对UDP连接的干扰 2.3 TCP连接重置 2.3.1 针对HTTP协议的关键字阻断 2.3.2 针对TLS的SNI阻断 2.3.3 针对TLS的证书传输检测 2.3.4 对eD2k协议的连接干扰 2.4 其他 2.4.1 对破网软件的反制 2.4.1.1 针对Tor的刺探 2.4.2 间歇性完全封锁 2.4.2.1 间歇性封锁国际出口 2.4.2.2 境内骨干路由器间歇性阻断 2.4.3 深度包检测 2.4.4 针对IPv6协议的审查 2.4.5 对电子邮件通讯的拦截 2.4.6 网络攻击 硬件 据2010年的估计，防火长城可能拥有数百台曙光4000L服务器。 防火长城（北京）使用曙光4000L机群，操作系统为Red Hat系列（从7.2到7.3到AS 4），周边软件见曙光4000L一般配置 防火长城实验室（哈尔滨工业大学）使用曙光服务器，Red Hat操作系统 防火长城（上海）使用Beowulf集群。GFW是曙光4000L的主要需求来源、 研究发起者、客户、股东、共同开发者。2007年防火长城集群规模进一步扩大， 北京增至360节点，上海增至128节点，哈尔滨增至64节点，共计552节点。 机群间星型千兆互联。计划节点数上千。 有多方证据表明防火长城（广州）存在，但其使用的服务器和系统不确定。 有理由相信防火长城（北京）拥有16套曙光4000L，每套384节点， 其中24个服务和数据库节点，360个计算节点。每套价格约两千万到三千万， 占005工程经费的主要部分。有3套（将）用于虚拟计算环境实验床，计千余节点。 13套用于骨干网络过滤。总计6144节点，12288CPU，12288GB内存， 峰值计算速度48万亿次。 2 GHz CPU的主机Linux操作系统下可达到600Kbps以上的捕包率。 通过骨干网实验，配置16个数据流总线即可以线速处理八路OC48（一路OC48约2.5Gbps） 接口网络数据。曙光4000L单结点的接入能力为每秒65万数据包，整个系统能够满足 32Gbps的实时数据流的并发接入要求。有理由相信GFW的总吞吐量为512Gbps甚至更高 （北京）。 典型意义下GFW的线路拓扑： 中华人民共和国被封锁网站列表 - 维基百科，自由的百科全书 中华人民共和国网络审查 - 维基百科，自由的百科全书 其他：面对 HTTPS 加密，GFW 的敏感词过滤失效。 其他名词VPS：虚拟专用服务器（英语：Virtual private server，缩写为 VPS）虚拟专用服务器 - 维基百科，自由的百科全书 代理（英语：Proxy）也称网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。提供代理服务的计算机系统或其它类型的网络终端称为代理服务器（英文：Proxy Server）。代理服务器 - 维基百科，自由的百科全书 SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是”SOCKetS”的缩写。SOCKS - 维基百科，自由的百科全书 网际协议第6版（英语：Internet Protocol version 6，缩写：IPv6）是网际协议的最新版本，用作互联网的网络层协议。用它来取代IPv4主要是为了解决IPv4地址枯竭问题，同时它也在其他方面对于IPv4有许多改进。IPv6 - 维基百科，自由的百科全书 Secure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接。Secure Shell - 维基百科，自由的百科全书 超文本传输安全协议（英语：HyperText Transfer Protocol Secure，缩写：HTTPS；常称为HTTP over TLS、HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。超文本传输安全协议 - 维基百科，自由的百科全书 对等式网络（peer-to-peer， 简称P2P），又称点对点技术，是无中心服务器、依靠用户群（peers）交换信息的互联网体系，它的作用在于，减低以往网路传输中的节点，以降低资料遗失的风险。与有中心服务器的中央网络系统不同，对等网络的每个用户端既是一个节点，也有服务器的功能，任何一个节点无法直接找到其他节点，必须依靠其户群进行信息交流。点对点网络 - 维基百科，自由的百科全书 HTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。HTTP状态码 - 维基百科，自由的百科全书 中间人攻击（英语：Man-in-the-middle attack，缩写：MITM）在密码学和计算机安全领域中是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。中间人攻击 - 维基百科，自由的百科全书 如何科学上网突破网络审查 - 维基百科，自由的百科全书作为修改hosts文件这一常用手段，目前基本已经失效：hosts文件 - 维基百科，自由的百科全书 修改本机 hosts文件，不足之处是需要系统管理员权限（如root权限）来修改， 对基于IP地址封禁的网站无效。自2018年8月份起，GFW开始启用基于SNI检测 和TCP连接重置的手段进行封锁，所以修改hosts方法不再完全适用。 一些相关软件的介绍 相关软件 蓝灯（Lantern），免费（3.x以后有付费版本，免费版4.x以后版本为每月500M， 超出限速）、开源，支持多平台（Windows、Linux、Android）。 蓝灯能够自动检测一个网站是否被封锁。对那些被封锁的网站，Lantern 通过自有的服务 器或者未封锁地区的用户运行的 Lantern 来提供访问。 赛风，免费、开源，支持多平台（Windows、Android、iOS），但链接不稳定 萤火虫（Firefly），用 Go 语言编写，采取 meek 工作原理，支持多平台（Windows、Android、iOS） XXNET 浏览器集成包，为进一步降低破网难度，有志愿者将Chromium、Firefox等浏览器， 与已经配置好的翻墙软件（如GoAgent和Shadowsocks的客户端软件）一起打包成一键翻 墙的浏览器集成包。这类浏览器集成包并不能提供高度安全的隐私保护，因为浏览器集成包 的制作者可能会在制作过程中加入恶意程序。当然，这类浏览器集成包的确易于使用。 洋葱路由器（Tor），同时提供暗网及代理。 大蒜路由器（I2P），Tor的演进版本，基于Java技术，使用 ed2k 技术实现分布式网络避免全网封杀。 代理服务器 此类软件需要自行在服务器和终端上部署，比一般的翻墙方法更繁琐。 Shadowsocks，简称SS，需要自行购买VPS并搭建代理服务器，用于翻墙， 在坊间也有可以直接使用的帐号出售，还有合租一台VPS服务器的情况。 ShadowsocksR，简称SSR，其使用方式同上，增加了混淆的特性， 可使翻墙流量伪装成正常流量。 ShadowsocksRR，简称SSRR，使用方法同上，与SSR相比增加了更多的混淆方式。 Brook，跨平台，基于 GPL v3 协议授权。 V2Ray， Project V[11]项目创作的内核，使用自实现的 Vmess 协议及 mKCP 协议，基于 MIT 协议授权。 VPN虚拟专用网 - 维基百科，自由的百科全书 虚拟私人网络（英语：Virtual Private Network，缩写：VPN）是一种常用于连接 中、大型企业或团体与团体间的私人网络的通讯方法。它利用隧道协议（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果，这种技术可以用 不安全的网络（例如：互联网）来发送可靠、安全的消息。 隧道协议 - 维基百科，自由的百科全书 Lantern蓝灯(Lantern)最新版本下载 Latest version of Lantern 5.3.2 有关VPN的风险性工业和信息化部关于清理规范互联网网络接入服务市场的通知 - 中华人民共和国工业和信息化部 2017年1月22日，工业和信息化部发布《工业和信息化部关于清理规范互联网网络接入服务 市场的通知》，规定未经电信主管部门（各一级行政区通信管理局）批准，不得自行创建或 租用VPN、国际专线等其他信道开展跨境经营活动。而在境内VPN属于《商用密码管理条 例》须经国家密码管理局批准。这也意味着在中国大陆的ISP、IDC或CDN提供商租用或创 建VPN或国际专线开展业务，必须获取各一级行政区通信管理局的批准。 但是VPN本来的作用并不是专门干这种事的，有一定的缺陷，比如流量特征可能被GFW分析。2019年发生了第一例个人使用VPN访问境外网站受到行政处罚的事件，所以使用VPN将导致可能被查水表或请喝茶，而且面对GFW不断地升级及某些因素影响，一些特殊时间段可能会使VPN使用体验不佳。 行政处罚决定书[2019]1号 - 广东公安执法信息公开平台 2018年12月28日，广东公安执法信息公开平台公布，韶关南雄公安局发出《韶雄公(网)行 罚决字 [2019]1号》文件：朱某某被警方认为“擅自创建、使用非法定信道进行国际联 网”而被警告并被罚款1000元。这一行政处罚的依据是1996年颁布的《中华人民共和国计 算机信息网络国际联网管理暂行规定》第六条、第十四条。 SS | SSR推荐阅读：浅谈VPN和SS/SSR的区别 简介那么先来介绍一下SS与SSR：全称Shadowsocks | ShadowsocksR SS的作者Clowwindy因被喝茶而删除其GitHub的源代码，SSR是breakwa11在SS基础上开发的软件，后因某些原因作者在GitHub上将其源代码删除，二软件开发时皆开源并且原作者停止维护后有人开发并维护与更新至今。 SSsock5协议 开源项目 跨平台官网 Github SSR某已经删除的SSR主页（web archive）：breakwa11.github.io Github 简单了解一下：Shadowsocks - 维基百科，自由的百科全书 Shadowsocks（简称SS）是一种基于Socks5代理方式的加密传输协议，也可以指实现这 个协议的各种开发包。当前包使用Python、C、C++、C#、Go语言等编程语言开发，大部 分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可 协议开放源代码。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端 程序部署到服务器上面，然后通过客户端连接并创建本地代理。 目前这是比较主流的工具之一，使用人数多，社区比较活跃，但技术上仍并非绝对完美，目前应对GFW足已使用。使用此软件的主要原因是配置方便及社区生态较好。 在国内社交网站上为避免审查常因其缩写称为酸酸 | 酸酸乳，而因其图标为一个纸飞机，也常称此软件为小飞机、纸飞机等。对提供服务器节点供多人使用的SSR服务提供商称为“机场”。 SSR分为服务端和客户端，如果你有境外服务器的话，可以直接安装服务端，然后在客户端上使用。当然没有的话你可能需要买个VPS这种东西，当然再然后如果你不需要服务器或没有优质服务器线路及服务器的话，也可以在“机场”获取节点服务器参数来进行使用，一些机场的使用体验比廉价vps更佳。 界面： 下载有Windows、Linux、Android、IOS、Macos等系统及各种在源软件基础上开发的很多版本。 一个仍在维护的Windows版本： https://github.com/shadowsocksrr/shadowsocksr-csharp/releases 一些下载地址及版本介绍： SS/SSR 简介 教程优先阅读[ShadowsocksR] 大概是萌新也看得懂的SSR功能详细介绍&amp;使用教程 Windows的ss客户端 · 珂学上网相关知识总结 一般的机场都提供教程，也可以谷歌，不再写操作流程了。 机场浅谈部分机场（SS/SSR提供商）的使用感受 使用技巧ShadowsocksR 客户端 各种隐藏使用技巧说明 ShadowsocksR简明使用教程 小飞机的颜色 颜色 全局 PAC 直连 负载均衡 白 √ √ 青 √ 黄 √ √ 绿 √ 紫 √ √ 蓝 √ 快捷键对小飞机托盘图标操作 操作 效果 左键单击 弹出编辑服务器窗口 中键单击 弹出服务器连接统计窗 右键单击 弹出菜单 SSTap软件介绍：SSTap全称SOCKSTap, 是一款利用虚拟网卡技术在网络层实现的代理工具。SSTap能在网络层拦截所有连接并转发给HTTP，SOCKS4，5，SHADOWSOCKS代理.而无需对被代理的应用程序做任何修改或设置。它能同时转发TCP,UDP数据包，它非常适合于游戏玩家使用。 搭建一个ssr服务可以谷歌解决，如果日后有时间金钱玩vps的话，会补一个详细的教程。 V2Ray推荐阅读：浅谈vpn、vps、Proxy以及shadowsocks之间的联系和区别 比SS | SSR更先进的工具之一，用了更多的技术手段。 V2Ray 是一个模块化的代理软件包，它的目标是提供常用的代理软件模块，简化网络代理软件的开发。 简单来说，它就是一个模块化代理，可以用来科学上网，支持多平台。 Project V · Project V 官方网站 Github BrookGithub Tor官网 一些工具一个Chrome的插件 Yet another flags 可以很方便的显示服务器IP地址和地理位置。效果： 一个网站，可以测试网站是否被GFW屏蔽以及文本是否存在被审查的关键字 greatfire.org 常用服务有GFW websiteGoogle Youtube Facebook Twitter Wikipedia(zh_CN) IMTelegram 无GFW websiteQuora GitHub]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>GFW</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[放弃挣扎的OIer[AFO]、高中生 喜欢中v、PC游戏、一点ACGN和写代码 想当互联网全栈工程师、游戏开发程序员 技术语言看过Java | C# 写过HTML | CSS | JavaScript | node.js 会写C | C++ | Python 工具看过LaTeX 用过Markdown | Git 游戏喜欢FPS（CS）、RTS（RA2）、开放世界（GTA5、MC） 小型游戏或者独立游戏，如泰拉瑞亚、空洞骑士 文学喜欢看一点诗词和读科幻小说 爱好中文Vocaloid、画画]]></content>
  </entry>
  <entry>
    <title><![CDATA[gallery]]></title>
    <url>%2Fgallery%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[links]]></title>
    <url>%2Flinks%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[timeline]]></title>
    <url>%2Ftimeline%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[闲聊]]></title>
    <url>%2Fchat%2Findex.html</url>
    <content type="text"><![CDATA[最后更新：A.D.2019-09-09 纪念生命中的过往烟云 历史 Date String 2019-6 搭建了此Blog 2019-9-12 购买了域名66ccff.xyz 2019-9-22 用HTML5 up模板制作个人主页并使用域名66ccff.xyz，Blog改为二级域名blog.66ccff.xyz 2019-9-22 往主域名下加了几个网页游戏 2019-11-04 创建了Virtual Dimension页面 随想 Date String 2019-6 词语时光 岁月 年华 2019-9-7 读完了《白鹿原》 2019-9-8 吃了一颗柠檬 2019-9-10 开坑套接字 2019-9-14 看完了刀剑神域Animation的SAO篇 2019-9-15 打了第一场Codeforces和AtCoder 以下是我喜欢的一些东西 歌词中文Vocaloid Lyrics Song 每一个梦都是个旋律 漫天回忆该如何去聆听 Step on your heart -心印-(Album ver) Luna Safari 晨风中的一缕光 折射梦想的宽广 Trii - Feel Your Dream 2018 血色夕阳 温热化作苍凉 岁月成碑 破晓夕阳 残月也吝啬藏起光芒 是谁把声音阻挡 月白色倒影的少女 如果还能找到你 就让风儿告诉你 Artificial Emotions 曾经许下的约定 寻找蔚蓝神秘的行星 不知道 何时才能苏醒 你却留下另一个自己 Artificial Emotions 虚和实的叠重，光和影的交错，触摸流云和清风勾勒的美梦 寻遍星空 如今的我，徘徊在楼宇的阡陌 寻遍星空 夜雾里去闪烁，光年外去诉说，让星辉照耀我浩瀚的宇宙 寻遍星空 乘天马遥望北辰飞向云外的月宫 寻遍星空 风，将我的思绪打乱，也看不清未来 梦，穿越过人山人海，快要醒来 化尘旅行 阳光斜照进窗台，记忆皆化作尘埃 化尘旅行 踏着凉鞋 提起裙边 随蝴蝶转啊转 翩飞花前 夏之歌 唱，你许下的梦想，在心底里徜徉，就像那梦一样，吹向四面八方 唱给雅音宫羽Ⅱ 花落尽时候，又是一个秋 唱给雅音宫羽Ⅱ 黑暗里总有光 春风来 寻觅着，风的波折 世末歌者 用这双手拨出残缺染了锈迹的弦音，都隐没于云雨雾雨幕无声无息 世末歌者 或哽咽 或低泣 都融进了泡沫里 拖曳疲惫身躯 沉入冰冷的池底 注视着色彩褪去 世末歌者 踏上未知列车 一直飞到云层最高空 紊乱的波形中 猜测前方可能的轮廓 躲藏在月光背后 电讯号变得神秘又莫测 一日都市 ACGN Lyrics Song 星月相掩与大海上 在这个世界相遇 微风摇曳细雨也彷徨 在这个世界相遇 海浪无声将夜幕深深淹没，漫过天空尽头的角落 大鱼 看海天一色，听风起雨落，执子手吹散苍茫茫烟波 大鱼 日月星辰悄悄，升了又落，我却不知白天黑夜的存在 湫兮如风 诗词等我有空时，我会单独写blog的，现在也不想补了。 日月星辰渔家傲 李清照 天接云涛连晓雾，星河欲转千帆舞。仿佛梦魂归帝所。闻天语，殷勤问我归何处。 我报路长嗟日暮，学诗谩有惊人句。九万里风鹏正举。风休住，蓬舟吹取三山去。 念奴娇·过洞庭 张孝祥 洞庭青草，近中秋，更无一点风色。玉鉴琼田三万顷，着我扁舟一叶。素月分辉，明河共影，表里俱澄澈。悠然心会，妙处难与君说。 应念岭表经年，孤光自照，肝胆皆冰雪。短发萧骚襟袖冷，稳泛沧溟空阔。尽挹西江，细斟北斗，万象为宾客。扣舷独啸，不知今夕何夕。 七律-送瘟神 毛泽东 绿水青山枉自多，华佗无奈小虫何。千村薜荔人遗矢，万户萧疏鬼唱歌。坐地日行八万里，巡天遥看一千河。牛郎欲问瘟神事，一样悲欢逐逝波。 自然风景人设Vocaloid Name_1 Name_2 Source $\color{rgb(102,204,255)}{洛天依}$ Luo Tianyi Vocaloid-天矢禾念 $\color{rgb(238,0,0)}{乐正绫}$ Yuezheng Ling Vocaloid-天矢禾念 $\color{rgb(0,255,204)}{言和}$ Yan He Vocaloid-天矢禾念 $\color{rgb(153,153,255)}{星尘}$ Stardust Vocaloid-平行四界 $\color{rgb(238,130,238)}{心华}$ Xin Hua Vocaloid-上海望乘 $\color{rgb(255,192,203)}{IA}$ イア Vocaloid-1st PLACE Vtuber Name_1 Name_2 Source A.I.Channel 神乐めあ 神乐七奈 白上吹雪 hololive一期生 猫宫日向 时乃空 夏色祭 hololive一期生 新科娘 CCTV 鸠羽伦 鳩羽つぐ 独立运营 ACGN Name_1 Name_2 Source ACGN 西宫结弦 《声之形》 AC 西宫硝子 《声之形》 AC 宫水三叶 《你的名字》 A 幼刀丛雨 ムラサメ 《千恋*万花》 G 艾米莉亚 《Re:0》 ACGN 结城明日奈 《刀剑神域》 A 桐谷和人 《刀剑神域》 A 高板桐乃 《我的妹妹哪有这么可爱》 A 和泉纱雾 《埃罗芒阿老师》 A 水野茜 水野 茜（みずの あかね） 《月色真美》 A 平泽唯 平沢 唯（ひらさわ ゆい） 《轻音少女》 AC 黑岩射手 ブラック★ロックシューター 《BLACK★ROCK SHOOTER》 AC ACGN作品连载动画 String Date re:0 2016-12 刀剑神域 第一季 2019-9-30 月色真美 2019-10-4 玉子市场 2020-2-29 摇曳百合 …… 境界的彼方 …… 孤岛学园 …… 轻音少女 …… URARA迷路帖 …… 非人哉 …… 电影 String Date 大鱼海棠 2016-7 你的名字 2017-10 声之形 2019-8 天气之子 2019-11-02 HELLO WORLD …… galgame String Date NEKOPARA Vol.0/1/2 2017-4 妄想症：Deliver Me 2018-8 美少女万华镜1 2018-11 KARAKARA1 2019-7 千恋*万花 2020-1 魔女的夜宴 2020-2 沙耶の唄 2020-2 Doki Doki Literature Club! 2020-2 君と彼女と彼女の恋 2020-2 Narcissu 1st 2020-3 Ever17 —the out of infinity— 2020-3 しゅがてん!-sugarfull tempering- …… 恋×シンアイ彼女 …… Summer Pockets …… eden* …… 三色绘恋 Tricolour Lovestory …… Riddle Joker …… 视频Bilibili Macro Link-Visual Release 2019]]></content>
  </entry>
</search>
