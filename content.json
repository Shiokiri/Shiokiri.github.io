{"meta":{"title":"落影汐雾的虚空印刷站","subtitle":null,"description":null,"author":"落影汐雾","url":"https://shiokiri.com","root":"/"},"pages":[{"title":"关于","date":"2025-03-21T02:02:47.223Z","updated":"2025-03-21T02:02:47.223Z","comments":true,"path":"about/index.html","permalink":"https://shiokiri.com/about/index.html","excerpt":"","text":"落影汐雾（Shiokiri），想努力做一个有趣的人 曾经是OIer，用过的id是ColorfulMist 喜欢电子产品、编程、PC/VR/Switch游戏、ACGN、中文VOCALOID、VRChat、galgame 日常使用Windows 10和macOS笔记本，会用一点GNU/Linux和NixOS，喜欢Haskell 梦想是当互联网全栈工程师、游戏开发程序员和技术美术 会用数位板摸鱼画点画，懂一点点3D建模，什么都愿意玩一点 网站是高中时期摸鱼搭建的静态博客，使用 Hexo，主题是 Material 交换友链在此回复名称+介绍+头像链接+主页链接即可\\ (￣︶￣\\ *))"},{"title":"闲聊","date":"2025-03-21T02:07:18.391Z","updated":"2025-03-21T02:07:18.391Z","comments":true,"path":"chat/index.html","permalink":"https://shiokiri.com/chat/index.html","excerpt":"","text":"喜欢什么样的二次元？ https://bangumi.tv/user/shiokiri 做过什么算法题？ https://www.luogu.com.cn/user/51525https://leetcode-cn.com/u/shiokiri/https://vjudge.net/user/i/552714https://codeforces.com/profile/colorfulmisthttps://atcoder.jp/users/neoSoda 还想了解更多？ Shiokiri’s Wiki"},{"title":"gallery","date":"2021-08-02T07:18:15.855Z","updated":"2019-06-05T02:12:39.411Z","comments":true,"path":"gallery/index.html","permalink":"https://shiokiri.com/gallery/index.html","excerpt":"","text":""},{"title":"links","date":"2022-06-02T10:56:30.214Z","updated":"2019-06-05T01:55:50.556Z","comments":true,"path":"links/index.html","permalink":"https://shiokiri.com/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-28T23:46:29.832Z","updated":"2019-06-05T01:55:21.571Z","comments":true,"path":"tags/index.html","permalink":"https://shiokiri.com/tags/index.html","excerpt":"","text":""},{"title":"timeline","date":"2021-07-28T23:46:29.832Z","updated":"2019-06-05T02:15:20.850Z","comments":true,"path":"timeline/index.html","permalink":"https://shiokiri.com/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"2016年至2025年日记收录","slug":"2025-03-21-diary","date":"2025-03-21T07:32:50.000Z","updated":"2025-03-21T01:52:37.038Z","comments":true,"path":"2025-03-21-diary/","link":"","permalink":"https://shiokiri.com/2025-03-21-diary/","excerpt":"更新于：A.D.2025.03.21","text":"更新于：A.D.2025.03.21 2016.07.22 机缘巧合之下影响了我生活的一部动画——大鱼海棠时间线在此刻变化。 事情发在这个祥和而安逸的暑假中，直到这个暑假之前我对大部分生活之外基本是漠不关心的。 虽然也经常上网，但是浏览过的信息实在是不多，大部分时间大概都花在了玩游戏上。 但是说成不怎么接受什么不常规的信息更为恰当。 有一天，是暑假，出去玩，看到电影院的大鱼海棠？是动画片吗？ 随便吧，毕竟我不怎么在意看一部电影的事情。 在此之前我完全不了解这是什么电影。 作画有一种很梦幻的感觉…… 几天之后，愈发地……想看看影片的评价，于是上网搜索。 链接到了知乎，便入坑了，又想起了很久很久没怎么看过的哔哩哔哩，于是也渐渐开始重新看了。 在知乎看到了很多有趣的东西，并且成功指导了我计算机的学习，然后我入坑了C语言，只喜欢看看书，自己就写过2次…… 就在入坑C语言的时候，在B站鬼畜看到了洛天依，然后不可抗拒地感觉很喜欢，就顺理成章地入坑了中v。 17年初的时候在知乎偶然看到蓝灯，就去试了试，发现了一些其它的方法，看到了SS之类的东西，但是没去尝试。 行道树的影子，还定格在那个夏天吗…… 2017.01.27 二零一七年的春节2017年的春节，这是一个我最喜欢的春节。 烟花还没有禁放，鞭炮也会响起几声。 我好像在2016年末看过了B站的2016年拜年祭，一些动画效果挺好的。 我在2017年春节玩了《返校》、《看门狗2》，除夕夜看了2017年拜年祭。 听了好多中v的歌曲，还下载了Vocaloid3。 那时候，我才知道，虚拟世界里还有很多我没接触过的快乐。 还会有声音吗，天空还会闪起几点彩色的烟花吗…… 2018.10.22 想起了二零一六年两年渐渐只是一瞬的时间，过去变成了遥不可及的永远。 想起了2016年初的春节前夕那点点飘落的雪、 寒假里玩过的MC和看过的MC视频、 暑假里的自由与闲适、 秋天玩得很开心的运动会…… 和那场年末的到目前为止的最后一次冬天的大雾。 还记得入夜后出去走走看见遍地的落雪飞下，回到家中，打开电脑吗？ 寂静温暖，刹那永昼。 如同2015年一样，冬天又有一场大雾，能见度不到15米，学校上午宣布停课。中午回家，高兴地，穿行在雾霭中骑行，一路与曾经的同学打打闹闹，到家感受着温暖，看看B站和知乎。天气阴沉，没有刺眼的阳光，我喜欢灰色的光线。 过去只能是回忆当中的碎片。 还会再走过那条路吗？ 2018.11.02 写在16岁生日何时开始一直在追寻那片理想中的境地呢，是远离世间的边界还又是那么完美的处境吗？曾经许许多多的梦想与憧憬都忘却了，什么时候去试试过往的想法和愿望呢？ 活着就是这样的吗？什么时候到达心中那所向往的抽象的无法描述的不存在的世界呢？遇到的现实总是不符合的，梦怎么去追寻呢？ 这种或那种事物是一个符合的载体吗？匹配了我许许多多的幻想与理解吗？但又抽象不出什么具体的东西出来吗？是一个确切的意境与现实吗？ 祝愿自己能一直喜欢中文Vocaloid和NOIP2018顺利。 一片虚无，无穷无尽的虚无…… 2018.12.11 下雪了，在学校又是一场雪。 雪一直是记忆中很重要的部分呢。 还会再下雪吗…… 2019.10.19 《前进，达瓦里希》动画观感悲凉。 想起身边从小长大一直过上平等生活的希望在不断被消灭，有种感同身受的心情。 未来会怎么样呢…… 2019.11.01 写在17岁生日感觉现在价值观念、人生理想和兴趣爱好明确多了。 至少比起去年这个时候的我来说是的。 人好像越来越像标签化的动物了…… 2019.11.02 《天气之子》观影感受及影评今晚去看了《天气之子》，回家的路上猝不及防地下起了雨…… 非常幸运地出去拉上一个同学出去玩了玩，如果只有一个人的话我就不去看了。 细细一想，天气之子的世界观和剧情和大鱼海棠竟有异曲同工之妙，只不过情感关系不同罢了。 不过，天气之子甚至全程只让我在性暗示和尴尬的地方笑出声来，而没有什么的情感上的触动，我看大鱼海棠的时候甚至还有几处让我感到强烈的情感触动的地方。 不过我喜欢城市轨道交通和信号铁塔、光影效果、镜头旋转效果和烟花、雨雪以及城市灯光的作画。 感觉看剧情和的话实在是没什么意思，至少没什么可以引发人思考的地方。 我觉得剧情和上一作的不同大概如下： 1.缺少剧情的复杂度和叙事逻辑的复杂度 上一作使用了可具科幻文学解释的宗教设定世界观，而此作转而偏向架空设定与采用完全的宗教及神话元素，其对宗教的交代不清导致缺乏剧情发展时的逻辑推理感与营造悬念的机会，使人很容易预测情节，限制了观众的想象力。采用单线叙事，相比上一作双线叙事显得情节简单。相比上一作复杂的逻辑关系和剧情，这作剧情实在太简单了。 2.缺少大多数人的一般生活的代入感与真实感。 离家出走和未成年独立生活不是普遍性的行为，不断违法与逃脱警察让我如同感觉在玩gta5一般，上一作对日常生活的写实风格，更能让观众回忆起自身的相似经历从而产生触动与代入感。这一作非常的浪漫主义与理想主义，总体来说是不切合现实实际的。 3.缺少矛盾与冲突感，人物行为动机原因不够强。 电影主要表达的价值观偏向于简单的爱情情感的行为动机取向，这部动画本身并没有传达一些更为复杂的情感与价值，比如对于天气的行为后果没有表现出价值评价与大规模的描写，所以我认为影片本身没有去刻意描绘个人主义和集体主义的矛盾冲突，它只是一个表现的方式而不是表现的内容。 综上，我认为观看此片需要你不特别喜欢科幻设定与复杂剧情，不特别纠结于影片价值观和社会意义的表现，非常浪漫主义和喜欢纯爱情题材剧情才能感受到影片本身所想传达到的一些东西。 《HELLO WORLD》你好，世界…… 2019.11.06 重新起一次ID今天想了想自己上网这么长时间，一直都没用过一个统一的ID，总是用了又看不惯，然后又改，每次注册账号都有可能换一个。这样显得很难受，自己的各个地方的ID乱七八糟的，于是想好好起一个ID，并且以后也尽量不换。 最终结果就是中文ID：落影汐雾，算是综合了我前几年一直用的中文ID（前两个字），后面两个字也还算用上了汉字的意思组合一下。英文想到了neo这个前缀还算还听，觉得soda这个词还行，那就这样吧，毕竟我不想ID里有英文名和用罗马音拼日文名以及没法读的东西……那最后就是neoSoda，就用这个id注册账号了，有重名的话会用neoSodas。 如果用neoSoda发现重名还是太多了啊啊啊，这样好多网站都没法注册了，只能再想一个了，汐雾换成英文实在有些难以接受，索性用日文拼一下罗马音，汐换成shio，雾换成片假名写法读音的kiri。那就是shiokiri，应该不会重名了，这样英文字形看起来也比较整洁。 无论如何，我没有再换过英文ID…… 2019.11.07 你好，世界！在时间线渐渐模糊的此时此刻 以下内容作废，原有博客已关闭，并合并至此文章中 Hello, world! 你好，世界！ 这个博客在2019-11-07完成搭建，使用GitHub + Jekyll + Maupassant，因为作者实现的功能不多，索性把不必要的内容删去了。 这个博客只写纯文字内容，想记录下一点自己的经历和想法。 用作记载所有时间点下的记录过想法及随笔和此时间点之前凭回忆写下的内容。 写过的文字内容和文章分类为随笔。一些事件时间点和经历回忆分类为历史。 日期仅作标注事件时间意义，不代表写作日期。 解构一切…… 2019.11.17 最终结束的OI从day1结束的无限自闭到day2总算打出暴力dp，我的OI生活终究在此刻结束了。 day1考完真的很难受，自闭到哭了，t2还是没做出来，和去年一样。 day2总算是把暴力dp都写出来了呢，真的超乎想象的顺利。 在车上，这是用手机写的，Google拼音输入法用得有点不舒服。。。 想起了自己上半年会了一点的前端，JS还是不太会写呢，暑假认真看了一天语法的Python，终于会用各种库了呢，想起了还没安装成功的Tensorflow和刚刚配好环境还没写过的Go，想起了一直没学会的SAM。 一切就这样都结束了…… 2021.11.28 雪夜时间越来越快，仿佛一刻也不被挽留。 又下雪了。 永远也忘不了通关ever17的那个初春，欣喜、空虚、一片虚无。 新冠肺炎给平淡的生活笼上了一层阴霾，却也是短暂的宁静，一点孤寂。 一直陷入为什么要在苦苦挣扎的矛盾中，却不得不面对一个显然的结局，一瞬明了。 下雪了，走进了雪地里，还是10年前的模样，还是10年前的记忆，却不知道何时未再踏入已然曾熟悉之地，细碎的雪花飘落在夜空里，轻轻地、柔和地、一如从前却又截然相反。 还会停下吗，能停止吗？…… 2022.03.27 以下内容作废，原有博客已关闭，并合并至此文章中 Hello, world! 你好，世界！ 更换主题为TeXt Theme，大部分配置还没有修改，会在合适的时间逐渐配置的。 重构一切…… 2022.03.29 递归的边界线（游戏剧本）递归的边界线（游戏剧本） 2022.06.01 从计算机开始、到OI与OI之外——七年之间从计算机开始、到OI与OI之外——七年之间（2015.09-2022.06） 2024.05.11 网络、现实与幻想——我的童年2024.05.11 网络、现实与幻想——我的童年（2006-2015.09） 2025.03.21 囿于真实和墨色虚无的交界——中文VOCALOID与我囿于真实和墨色虚无的交界——中文VOCALOID与我（2013-2025） 2025.06.10 在虚拟与现实的边界线——大学回忆录在虚拟与现实的边界线——大学回忆录（2021.06-2025.06）","categories":[{"name":"随笔","slug":"随笔","permalink":"https://shiokiri.com/categories/随笔/"}],"tags":[{"name":"回忆录","slug":"回忆录","permalink":"https://shiokiri.com/tags/回忆录/"}]},{"title":"Minecraft Spigot开服记录","slug":"2024-04-05-minecraft-server","date":"2024-04-05T07:32:50.000Z","updated":"2025-03-21T00:56:30.758Z","comments":true,"path":"2024-04-05-minecraft-server/","link":"","permalink":"https://shiokiri.com/2024-04-05-minecraft-server/","excerpt":"更新于：A.D.2024.04.05","text":"更新于：A.D.2024.04.05 安装系统是Debian 12 安装jre tmux sudo apt install default-jre tmux 检查java环境 java --version 添加用户mc useradd -m -s /bin/bash mc 切换用户mc，检查路径 su mc cd ~ pwd 下载spigot最新版本BuildTools mkdir spigot cd spigot wget https://hub.spigotmc.org/jenkins/job/BuildTools/lastSuccessfulBuild/artifact/target/BuildTools.jar 运行jar包，这里等待一会，必要时换一下Maven源 java -jar BuildTools.jar --rev 1.20.4 创建服务器目录 cd ~ mkdir mcserver cp spigot/spigot-1.20.4.jar ./server/ cd server 先运行一次 java -Xmx1024M -Xms1024M -jar spigot-1.20.4.jar 查看eula.txt并同意协议（文件内容改为eula=true） vim eula.txt 写一个脚本start.sh #!/bin/sh trap &quot;exit&quot; 2 java -Xmx1024M -Xms1024M -jar spigot-1.20.4.jar 新建一个tmux窗口 tmux new -s mc 运行脚本· chmod +x start.sh ./start.sh 插件MOTDMOTD [1.8 - 1.20] | SpigotMC - High Performance Minecraft 用于实现motd消息显示 域名DNS解析配置一条SRV记录即可隐藏端口 参考RFC2782_Service._Proto.Name TTL Class SRV Priority Weight Port Target _Service._Proto.Name 设为 _minecraft._tcp.mc.example.com TTL 设为 30min Priority Weight Port Target 设为 5 0 25565 example.com","categories":[{"name":"技术","slug":"技术","permalink":"https://shiokiri.com/categories/技术/"}],"tags":[{"name":"Minecraft服务器","slug":"Minecraft服务器","permalink":"https://shiokiri.com/tags/Minecraft服务器/"},{"name":"Spigot","slug":"Spigot","permalink":"https://shiokiri.com/tags/Spigot/"}]},{"title":"VRChat穿衣/换衣/上传模型流程","slug":"2023-12-01-vrchat","date":"2023-12-21T07:32:50.000Z","updated":"2025-03-21T00:56:27.848Z","comments":true,"path":"2023-12-01-vrchat/","link":"","permalink":"https://shiokiri.com/2023-12-01-vrchat/","excerpt":"更新于：A.D.2023.12.21","text":"更新于：A.D.2023.12.21 一般来说说这种操作GUI软件的流程应该看视频教程的，但我不喜欢边看视频边操作，为了防止下一次忘记了，在这里简单记录一下完整步骤。 咕咕QAQ","categories":[{"name":"技术","slug":"技术","permalink":"https://shiokiri.com/categories/技术/"}],"tags":[{"name":"VRChat","slug":"VRChat","permalink":"https://shiokiri.com/tags/VRChat/"}]},{"title":"写一个Chrome extensions存储标签栏网页至书签","slug":"2023-11-02-chrome-extensions","date":"2023-11-02T07:32:50.000Z","updated":"2025-03-21T00:50:50.722Z","comments":true,"path":"2023-11-02-chrome-extensions/","link":"","permalink":"https://shiokiri.com/2023-11-02-chrome-extensions/","excerpt":"更新于：A.D.2023.11.02","text":"更新于：A.D.2023.11.02 我一直有在浏览器中开过多页面和打开浏览器保持上次浏览页面的习惯，并且喜欢把过多的页面按照当日日期保存到书签中再关闭，但这样操作步骤非常麻烦：按下Ctrl+Shift+D，选择文件夹，更改文件夹名为日期，点击确定，依次关闭所有标签栏。 查找了一些扩展程序都不太想用，因为很多都没有直接存入书签中。我认为保存到书签中是最安全最不容易丢失的方案，所以直接自己写一个简单的插件好了。 配置Chrome extensions的开发步骤：创建和发布自定义 Chrome 应用和扩展程序 首先按照Google的文档导入一个最简单的页面：Hello World 扩展程序 | Extensions | Chrome for Developers 功能首先不考虑扩展性，把基本功能先写完，思考一下要用到什么API，要读取并关闭所有标签栏，并且把信息存入书签，所以需要用到tabs和bookmarks的API，查询文档后发现v3版本支持promise写法，继续仔细阅读一下文档并且写一写代码，这样基本流程就可以跑通了。 document.getElementById(&quot;getButton&quot;).addEventListener(&quot;click&quot;, async () =&gt; { const queryOptions = { lastFocusedWindow: true }; const tabs = await chrome.tabs.query(queryOptions); const extensionsFolderTitle = document.getElementById(&quot;folderNameInput&quot;).value; const data = new Date().toISOString().slice(0, 10); const tree = await chrome.bookmarks.getTree(); const extensionsFolder = tree[0].children[0].children.find( (child) =&gt; child.title === extensionsFolderTitle ); const currentExtensionsFolder = extensionsFolder == null ? await chrome.bookmarks.create({ parentId: tree[0].children[0].id, title: extensionsFolderTitle, }) : extensionsFolder; let currentDate = data, index = 1; while ( currentExtensionsFolder.children.find( (child) =&gt; child.title === currentDate ) ) { currentDate = data + `-${index}`; index++; } const currentDateFolder = await chrome.bookmarks.create({ parentId: currentExtensionsFolder.id, title: currentDate, }); for (const tab of tabs) { await chrome.bookmarks.create({ parentId: currentDateFolder.id, title: tab.title, url: tab.url, }); } chrome.tabs.create({ active: true }); await chrome.tabs.remove(tabs.map((t) =&gt; t.id)); }); 样式没怎么写过前端QAQ，为了尽可能简单用Bootstrap随便写写好了（不要学我）。 &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;Bootstrap demo&lt;/title&gt; &lt;link href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; integrity=&quot;sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;style&gt; body { width: 280px; height: 200px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container mt-3&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col text-center&quot;&gt; &lt;h1&gt;Save Tabs Extension&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;mb-3&quot;&gt; &lt;label for=&quot;folderNameInput&quot; class=&quot;form-label&quot;&gt;Bookmark Folder name&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;folderNameInput&quot; placeholder=&quot;Enter the folder name.&quot; value=&quot;Timeline&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col text-center&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; id=&quot;getButton&quot;&gt;Save&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;popup.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"编程","slug":"编程","permalink":"https://shiokiri.com/categories/编程/"}],"tags":[{"name":"Chrome插件","slug":"Chrome插件","permalink":"https://shiokiri.com/tags/Chrome插件/"}]},{"title":"搭建一个物理服务器并安装Unraid","slug":"2023-10-24-server-and-unraid","date":"2023-10-23T16:00:00.000Z","updated":"2025-03-21T00:50:47.981Z","comments":true,"path":"2023-10-24-server-and-unraid/","link":"","permalink":"https://shiokiri.com/2023-10-24-server-and-unraid/","excerpt":"更新于：A.D.2023.10.24","text":"更新于：A.D.2023.10.24 装机需求简单列一下需要（防止一直想加钱）：用途是跑Unraid，起Docker，起一个OpenWrt软路由，起一个10T盘RAID 0的NAS，做实验搭一点内网服务IaaS（Database、OSS、Git）和SaaS（Wiki）。 因为也没什么性能需要，所以捡垃圾就好，发热也要尽可能小。 配置CPU Intel Xeon E5-2630 v4 散热 Q9双铜管散热器 双风扇 主板 科脑 X99H-DDR4千兆 MATX 内存 镁光 DDR4 2133MHz ECC REG 16g 硬盘 SSD 威刚 IM2P33F8 512G 硬盘 HDD 希捷银河 X10 10TB 显卡 昂达 GT610 典范 1GD3 电源 鑫谷 战斧400 300W 机箱 爱国者 YOGO M2 Performance 风扇 航嘉清风12cm 网卡 SSU PCI-E千兆 RTL8111F Unraid咕咕QAQ","categories":[{"name":"计算机","slug":"计算机","permalink":"https://shiokiri.com/categories/计算机/"}],"tags":[{"name":"物理服务器","slug":"物理服务器","permalink":"https://shiokiri.com/tags/物理服务器/"},{"name":"Unraid","slug":"Unraid","permalink":"https://shiokiri.com/tags/Unraid/"}]},{"title":"Debian在LVM下ext4文件系统调整/和/home分区大小","slug":"2023-07-06-linux-lvm","date":"2023-07-06T07:32:50.000Z","updated":"2025-03-21T00:58:55.726Z","comments":true,"path":"2023-07-06-linux-lvm/","link":"","permalink":"https://shiokiri.com/2023-07-06-linux-lvm/","excerpt":"更新于：A.D.2023.07.06","text":"更新于：A.D.2023.07.06 安装系统时给/home分配的空间过大，/空间太小，重新进行分配。 环境shiokiri@thinkpad-e15:~$ neofetch _,met$$$$$gg. shiokiri@thinkpad-e15 ,g$$$$$$$$$$$$$$$P. --------------------- ,g$$P&quot; &quot;&quot;&quot;Y$$.&quot;. OS: Debian GNU/Linux 11 (bullseye) x86_64 ,$$P&#39; `$$$. Host: 20YG001YCD ThinkPad E15 Gen 3 &#39;,$$P ,ggs. `$$b: Kernel: 5.10.0-23-amd64 `d$$&#39; ,$P&quot;&#39; . $$$ Uptime: 27 mins $$P d$&#39; , $$P Packages: 2191 (dpkg) $$: $$. - ,d$$&#39; Shell: bash 5.1.4 $$; Y$b._ _,d$P&#39; Resolution: 3840x2160 Y$$. `.`&quot;Y$$$$P&quot;&#39; DE: GNOME 3.38.6 `$$b &quot;-.__ WM: Mutter `Y$$ WM Theme: Adwaita `Y$$. Theme: Ant [GTK2/3] `$$b. Icons: Adwaita [GTK2/3] `Y$$b. Terminal: gnome-terminal `&quot;Y$b._ CPU: AMD Ryzen 5 5500U with Radeon Graphics (12) @ 2.100GHz `&quot;&quot;&quot; GPU: AMD ATI 04:00.0 Lucienne Memory: 1064MiB / 14868MiB 过程使用recovery mode启动在GRUB启动页面选择即可 查看文件系统使用情况# df -hT 示例（非操作过程中数据）： 文件系统 类型 容量 已用 可用 已用% 挂载点 udev devtmpfs 7.2G 0 7.2G 0% /dev tmpfs tmpfs 1.5G 9.9M 1.5G 1% /run /dev/mapper/debian--vg-root ext4 222G 23G 190G 11% / tmpfs tmpfs 7.3G 12M 7.3G 1% /dev/shm tmpfs tmpfs 5.0M 4.0K 5.0M 1% /run/lock /dev/nvme0n1p2 ext2 471M 117M 330M 27% /boot /dev/nvme0n1p1 vfat 511M 5.8M 506M 2% /boot/efi /dev/mapper/debian--vg-home ext4 246G 39G 196G 17% /home tmpfs tmpfs 1.5G 144K 1.5G 1% /run/user/1000 查看LVM元数据查看卷组# vgdisplay 示例（非操作过程中数据）： --- Volume group --- VG Name debian-vg System ID Format lvm2 Metadata Areas 1 Metadata Sequence No 11 VG Access read/write VG Status resizable MAX LV 0 Cur LV 3 Open LV 3 Max PV 0 Cur PV 1 Act PV 1 VG Size 475.96 GiB PE Size 4.00 MiB Total PE 121846 Alloc PE / Size 121846 / 475.96 GiB Free PE / Size 0 / 0 VG UUID oU51kj-3uiu-4nPI-1OTp-K4NN-i4IG-gqsZrE 查看逻辑卷# lvdisplay 卸载/home不能在线缩减，需要先卸载 # umount /home 卸载挂载的lv # mount 查看挂载的lv是否卸载成功 缩减/home大小 不得更改顺序！！！必须先缩减逻辑卷的逻辑边界，再缩减物理边界 确保缩减后的空间大小依然能存储原有的所有数据 e2fsck 在缩减之前应该先强行检查文件，以确保文件系统处于一致性状态 resize2fs 对lv逻辑卷的文件系统首先尽可能缩小 lvreduce 对lv逻辑卷的物理边界缩减到需要的值 resize2fs 扩展文件系统到物理边界大小 缩减行为非常危险，缩减文件系统时要尽可能缩小，缩减逻辑卷物理边界时缩减到需要的值，然后再次调整文件系统（使用一段时间后，文件系统df -hT要比逻辑卷fdisk -l / lvdisplay小，硬盘元数据需要占用空间），这点所有的中文教程叙述都不正确，非常危险！ # e2fsck -f /dev/mapper/debian--vg-home # resize2fs /dev/mapper/debian--vg-home 200GG 调整逻辑卷的文件系统大小为200G # lvreduce -L 250G /dev/mapper/debian--vg-home 对逻辑卷的物理边界缩减为250G # resize2fs -p /dev/mapper/debian--vg-home 扩展文件系统到物理边界大小 挂载/home挂载lv逻辑卷 # mount /dev/mapper/debian--vg-home /home 扩充/大小 不得更改顺序！！！必须先扩展逻辑卷的物理边界，再调整文件系统 lvextend 扩展逻辑卷的物理边界 lvextend -L [+]# /PATH/TO/LV_NAME 指定扩展后的容量，+表示在目前容量上直接增加#容量，不用+表示，扩展后的容量为# lvextend -l +100%FREE /PATH/TO/LV_NAME 把所有空余容量进行分配 resize2fs 调整逻辑卷的文件系统 resize2fs /PATH/TO/LV # 调整文件系统到#，该值不能超过物理边界 resize2fs -p /PATH/TO/LV -p 表示打印已完成的百分比进度条 # lvextend -l +100%FREE /dev/mapper/debian--vg-root # resize2fs -p /dev/mapper/debian--vg-root 检查结果# df -hT 扩充交换空间大小# free -m # swapoff /dev/VolGroup/lv_swap # lvextend -l +100%FREE /dev/mapper/debian--vg-swap_1 # mkswap /dev/VolGroup/lv_swap # swapon /dev/VolGroup/lv_swap # free -m 注意事项 ext4才可以缩减，xfs不能缩减 扩充空间一定是先lvresize后resize2fs！！！ 缩减空间一定是先resize2fs后lvresize！！！","categories":[{"name":"计算机","slug":"计算机","permalink":"https://shiokiri.com/categories/计算机/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://shiokiri.com/tags/Linux/"},{"name":"Debian","slug":"Debian","permalink":"https://shiokiri.com/tags/Debian/"}]},{"title":"构建第一个Vue 3项目","slug":"2023-03-18-vue","date":"2023-03-18T07:32:50.000Z","updated":"2025-03-21T01:13:31.016Z","comments":true,"path":"2023-03-18-vue/","link":"","permalink":"https://shiokiri.com/2023-03-18-vue/","excerpt":"更新于：A.D.2023.03.18","text":"更新于：A.D.2023.03.18 环境配置安装 Node.js 下载 | Node.js 中文网（Node.js自带npm包管理工具） 配置环境变量 检查npm和node是否安装成功 npm -v node -v 安装镜像并检查cnpm是否安装成功 npm install -g cnpm --registry=https://registry.npm.taobao.org 以上步骤出现问题检查一下网络状况及环境变量。 安装 vue-cli 若安装过vue-cli，首先删除2.0版本：cnpm uni -g vue-cli cnpm i -g @vue/cli 检查是否安装成功 vue -v 初始化Vue 3项目 使用VSCode进行编辑，在终端中输入 vue create project-name 会弹出选项 Vue CLI v5.0.8 ? Please pick a preset: (Use arrow keys) &gt; Default ([Vue 3] babel, eslint) Default ([Vue 2] babel, eslint) Manually select features 若选择Manually select features，弹出多选选项 Vue CLI v5.0.8 ? Please pick a preset: Manually select features ? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection, and &lt;enter&gt; to proceed) &gt;(*) Babel ( ) TypeScript ( ) Progressive Web App (PWA) Support ( ) Router ( ) Vuex ( ) CSS Pre-processors (*) Linter / Formatter ( ) Unit Testing ( ) E2E Testing Babel：JS编译器，可以将ES6语法转换为浏览器可识别的ES5，JSX转换为JS TypeScript：比JS类型更强，Vue兼容TS PWA：PWA 全称为 Progressive Web App，中文译为渐进式 Web APP，其目的是通过各种 Web技术实现与原生 App 相近的用户体验。 Router：路由配置 Vuex：Vue的状态管理模式，管理组件的状态及其变化 CSS Pre-processors：CSS预处理器，例如sass、less，对已有css功能进行扩展，简化CSS Linter/Formatter：代码风格检查和格式化，例如ESLint Unit Testing：单元测试 E2E Testing：集成测试 初始化后运行项目cd project-name npm run serve 项目目录结构 node_modules：所有通过npm包管理工具下载的项目依赖包 public：公共文件夹、网站的图标、入口的HTML文件 src：源文件目录source简称 assets：静态资源文件（图片、CSS全局文件） components： Vue组件文件夹 router：vue-router路由文件 store：vuex views： App.vue：根组件 main.js：JS入口文件，用于挂在项目根组件、引入资源 .gitignore：配置Git忽略的文件 package.json：命令配置和包管理文件","categories":[{"name":"编程","slug":"编程","permalink":"https://shiokiri.com/categories/编程/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://shiokiri.com/tags/vue/"},{"name":"前端","slug":"前端","permalink":"https://shiokiri.com/tags/前端/"}]},{"title":"云服务器购买与Linux使用经验","slug":"2023-03-17-cloud-server","date":"2023-03-17T07:32:50.000Z","updated":"2025-03-21T00:56:47.958Z","comments":true,"path":"2023-03-17-cloud-server/","link":"","permalink":"https://shiokiri.com/2023-03-17-cloud-server/","excerpt":"更新于：A.D.2023.03.18","text":"更新于：A.D.2023.03.18 近日比较了几家国内的云服务后选择了购买腾讯云Lighthouse产品，选择国内的原因是想建一个访问速度比较快的博客或者网站，或者开一下MC服务器。这里写一些云服务器购买和Linux操作的经验。 服务器购买阿里云学生应该是可以免费获得6个月的服务器的，但是我觉得服务器物理位置不太好。然后GitHub学生包中的服务：Azure禁止了大陆学生邮箱，Digital Ocean还需要先充值才能用。综合来看最终还是选择了自己购买，最后感觉腾讯云的价格不错，购买的时候参考了下面的文章。 参考文章：https://zhuanlan.zhihu.com/p/457728444 最后购买了下图159元/年的服务器，2C4G6M应该可以开MC服务器了，60G SSD硬盘，1000GB月流量。（建议买一年换账号或者换服务商，正常买一年的价格太贵了） 购买链接：https://cloud.tencent.com/act/pro/lighthouse2021 域名购买之前在NameSilo购买了lyxw.xyz这个域名，发现NameCheap卖的com域名有优惠券，于是在NameCheap购买了shiokiri.com这个域名。 可以从下面这个网站查看不同域名最便宜的国外服务商。 优惠信息：https://www.domcomp.com/ 注意无论域名注册服务商还是服务器运营商，域名是否需要备案（访问80、443端口），最终取决于服务器的物理位置是否位于中国大陆境内，也就是说域名在国内国外服务商注册都没关系，只有位于大陆境内的服务器需要进行域名备案。 如果没有备案，域名的其他端口解析正常使用是没问题的（例如用作Linux SSH登录的22端口），直接访问公网IP也是没问题的（通过IP访问网站）。也就说备案仅仅影响域名的80和443端口解析。 域名解析知识…… 服务器操作购买云服务器后会有一个面板，我们需要在这里进行一些操作，例如安装操作系统，配置密码密钥、VNC登录，设置防火墙等。这些具体可以参考服务商的相关文档。 安全问题不要使用root用户直接登录，root用户只设置密码，禁止使用ssh登录root，另开一个可以使用sudo的用户设置密钥登录，ssh拒绝密码登录。 Linux操作我们首先需要一个终端，所以这里先介绍一些常见的终端并且比较一下他们的好坏。在通过终端进行SSH连接后，我们就可以进行Linux操作。之后可以使用VSCode的Remote - SSH插件直接编辑文件及编写代码，省去使用scp命令或者其他文件传输工具的步骤、以及使用vim的困难。 终端介绍及美化首先我们要先区分一下terminal（终端）和shell。 VSCode Remote - SSH插件…… 搭建MC服务器……","categories":[{"name":"计算机","slug":"计算机","permalink":"https://shiokiri.com/categories/计算机/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://shiokiri.com/tags/服务器/"}]},{"title":"开始记忆一些Linux命令","slug":"2023-03-05-linux","date":"2023-03-05T07:32:50.000Z","updated":"2025-03-21T00:56:53.129Z","comments":true,"path":"2023-03-05-linux/","link":"","permalink":"https://shiokiri.com/2023-03-05-linux/","excerpt":"更新于：A.D.2023.03.05","text":"更新于：A.D.2023.03.05 文件目录lslist ls [选项][目录名] ls -a 列出目录所有文件，包含以.开始的隐藏文件 ls -A 列出除.及..的其它文件 ls -r 反序排列 ls -t 以文件修改时间排序 ls -S 以文件大小排序 ls -h 以易读大小显示 ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 ls -lhrt 按易读方式按时间反序排序，并显示文件详细信息 ls -lrS 按大小反序显示文件详细信息 ls -l t* 列出当前目录中所有以&quot;t&quot;开头的目录的详细内容 ls | sed &quot;s:^:`pwd`/:&quot; 列出文件绝对路径（不包含隐藏文件） find $pwd -maxdepth 1 | xargs ls -ld 列出文件绝对路径（包含隐藏文件） cdchange directory cd [目录名] cd / 进入根目录 cd ~ 进入home目录 cd - 进入上一次工作路径 cd !$ 把上个命令的参数作为cd参数使用 pwdprint work directory pwd [选项] -P 显示实际物理路径，而非使用连接（link）路径 -L 当目录为连接路径时，显示连接路径 mkdirmake directory mkdir [选项] 目录 -m 对新建目录设置存取权限，也可以用 chmod 命令设置 -p 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录 rmremove rm [选项] 文件 -f, --force 忽略不存在的文件，从不给出提示 -i, --interactive 进行交互式删除 -r, -R, --recursive 指示rm将参数中列出的全部目录和子目录均递归地删除。 -v, --verbose 详细显示进行的步骤 --help 显示此帮助信息并退出 --version 输出版本信息并退出 rmdirremove directory mvmove(rename) files mv [选项] 源文件或目录 目标文件或目录 -b ：若需覆盖文件，则覆盖前先行备份 -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖 -u ：若目标文件已经存在，且 source 比较新，才会更新(update) -t ： --target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后 cpcopy cp [选项] 源文件 目录 或 cp [选项] -t 目录 源文件 -t --target-directory 指定目标目录 -i --interactive 覆盖前询问（使前面的 -n 选项失效） -n --no-clobber 不要覆盖已存在的文件（使前面的 -i 选项失效） -f --force 强行复制文件或目录，不论目的文件或目录是否已经存在 -u --update 使用这项参数之后，只会在源文件的修改时间较目的文件更新时，或是对应的目的文件并不存在，才复制文件 catconcatenate cat [选项] [文件] -A, --show-all 等价于 -vET -b, --number-nonblank 对非空输出行编号 -e 等价于 -vE -E, --show-ends 在每行结束处显示 $ -n, --number 对输出的所有行编号,由1开始对所有输出的行数编号 -s, --squeeze-blank 有连续两行以上的空白行，就代换为一行的空白行 -t 与 -vT 等价 -T, --show-tabs 将跳格字符显示为 ^I -u (被忽略) -v, --show-nonprinting 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外","categories":[{"name":"计算机","slug":"计算机","permalink":"https://shiokiri.com/categories/计算机/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://shiokiri.com/tags/Linux/"}]},{"title":"3D游戏开发中美术/程序的软件流程","slug":"2022-09-27-3d-game-development","date":"2022-09-27T07:32:50.000Z","updated":"2025-03-21T00:48:18.919Z","comments":true,"path":"2022-09-27-3d-game-development/","link":"","permalink":"https://shiokiri.com/2022-09-27-3d-game-development/","excerpt":"更新于：A.D.2022.09.27","text":"更新于：A.D.2022.09.27 美术工作流Unity工作流mermaid插件寄了，而我却没有能力修好它……更没有把这篇文章写完 graph LR A --&gt; B UE工作流","categories":[{"name":"技术","slug":"技术","permalink":"https://shiokiri.com/categories/技术/"}],"tags":[{"name":"渲染","slug":"渲染","permalink":"https://shiokiri.com/tags/渲染/"},{"name":"三维建模","slug":"三维建模","permalink":"https://shiokiri.com/tags/三维建模/"}]},{"title":"3D建模的PBR流程","slug":"2022-09-27-pbr","date":"2022-09-27T07:32:50.000Z","updated":"2022-10-13T12:55:27.060Z","comments":true,"path":"2022-09-27-pbr/","link":"","permalink":"https://shiokiri.com/2022-09-27-pbr/","excerpt":"更新于：A.D.2022.09.27","text":"更新于：A.D.2022.09.27 一种PBR流程 3ds Max / Maya 制作中模 Zbrush 雕刻高模 3ds Max / Maya 拓扑低模 3ds Max / Maya UV展开 Substance Painter 烘培贴图 Substance Painter 绘制PBR贴图 贴图类型 漫反射贴图 Diffuse map 凹凸贴图 Bump maps 2.1. 法线贴图 Normal maps 2.2. 高度贴图 Height maps 高光贴图 Specular maps AO贴图 Ambient Occlusiont 环境贴图 Cube map 光照纹理 Light map Mip map和Detail map","categories":[{"name":"技术","slug":"技术","permalink":"https://shiokiri.com/categories/技术/"}],"tags":[{"name":"渲染","slug":"渲染","permalink":"https://shiokiri.com/tags/渲染/"},{"name":"三维建模","slug":"三维建模","permalink":"https://shiokiri.com/tags/三维建模/"}]},{"title":"Redis数据库学习笔记","slug":"2022-09-27-redis","date":"2022-09-27T07:32:50.000Z","updated":"2023-03-04T19:32:03.200Z","comments":true,"path":"2022-09-27-redis/","link":"","permalink":"https://shiokiri.com/2022-09-27-redis/","excerpt":"更新于：A.D.2023.03.05","text":"更新于：A.D.2023.03.05 什么是Redis为什么需要Redis 数据从单表，演进除了分库分表 MySQL从单机演进出了集群 数据量增长 读写数据压力的不断增加 数据分冷热 热数据：经常被访问到的数据 将热数据存储到内存中 Redis基本工作原理 数据从内存中读写 数据保存到硬盘上防止重启数据丢失 增量数据保存到AOF文件 全量数据RBD文件 单线程处理所有操作命令 Redis应用案例连续签到String数据结构 可以存储字符串、数字、二进制数据 通常和expire配合使用 场景：存储计数、Session 消息通知用List作为消息队列 QuickList由一个双向链表和listpack实现 计数一个用户有多项计数需求，可通过Hash结构存储 Hash数据结构dict rehash 渐进式rehash 排行榜zset数据结构 zskiplist 限流分布式锁可以使用Redis的setnx实现 Redis是单线程执行命令 setnx只有未设置过才能执行成功 Redis使用注意事项大Key、热Key 数据类型 大Key标准 String类型 value的字节数大于10KB即为大Key Hash/Set/Zset/List等复杂数据结构类型 元素个数大于5000个或总value字节数大于10MB即为大Key 大Key的危害 读取成本高 容易导致慢查询（过期、删除） 主从复制异常、服务阻塞无法正常响应请求 业务侧使用大Key的表现 请求Redis超时报错 慢查询场景容易导致Redis慢查询的操作 批量操作一次性传入过多的key/value，如mset/hmset/sadd/zadd等O(n)操作，建议单批次不要超过100，超过100之后性能下降明显 zset大部分命令都是O(log(n))，当大小超过5k以上时，简单的zadd/zrem也可能导致慢查询 操作的单个value过大，超过10KB。也即，避免使用大Key 对大Key的delete/expire操作也可能导致慢查询，Redis4.0之前不支持异步删除unlink，大Key删除会阻塞Redis","categories":[{"name":"编程","slug":"编程","permalink":"https://shiokiri.com/categories/编程/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://shiokiri.com/tags/数据库/"},{"name":"Redis","slug":"Redis","permalink":"https://shiokiri.com/tags/Redis/"}]},{"title":"Unity Shader入门学习","slug":"2022-09-27-unity-shader","date":"2022-09-27T07:32:50.000Z","updated":"2022-09-27T14:25:17.681Z","comments":true,"path":"2022-09-27-unity-shader/","link":"","permalink":"https://shiokiri.com/2022-09-27-unity-shader/","excerpt":"更新于：A.D.2022.09.27","text":"更新于：A.D.2022.09.27 什么是Shader三种Shader语言 基于OpenGL的OpenGL Shading Language，简称GLSL。 基于DirectX的High Level Shading Language，简称HLSL。 NVIDIA公司的C for Graphic，简称Cg语言。 Unity Shader","categories":[{"name":"技术","slug":"技术","permalink":"https://shiokiri.com/categories/技术/"}],"tags":[{"name":"Shader","slug":"Shader","permalink":"https://shiokiri.com/tags/Shader/"}]},{"title":"编程与CS学习的必要前置知识","slug":"2022-06-28-before-cs-learning","date":"2022-06-28T07:32:50.000Z","updated":"2025-03-21T01:56:18.766Z","comments":true,"path":"2022-06-28-before-cs-learning/","link":"","permalink":"https://shiokiri.com/2022-06-28-before-cs-learning/","excerpt":"更新于：A.D.2022.06.28","text":"更新于：A.D.2022.06.28 访问网站方法学会科学上网，Google、GitHub、Stack Overflow 可以解决你在开发过程中遇到的 95% 的问题。 计算机操作掌握一些比较基本的快捷键 Ctrl+C/V 复制粘贴 Ctrl/Shift+方向键 文本操作 Ctrl+Tab/Ctrl+Shift+Tab 浏览器页面向前/向后 建立一些解决计算机使用方面问题的基本认识 购买笔记本需要注意什么？怎么判断型号的优劣？ 笔记本可以加装固态硬盘吗？要注意怎么操作？ C盘满了会有什么后果？应该怎么处理？ 资源获取途径信息获取仅仅列出一些常见网站，初步了解一个领域建议在知乎进行关键字搜索 Google 知乎 掘金 思否 V2EX 书籍下载专业书籍可以下载PDF扫描版，文学及小说可以下载EPUB进行多端阅读 Z-Library. The world’s largest ebook library. 搜索与提问学会搜索学会搜索，首先学会使用正确的网站 当遇到问题时，按以下优先级解决： 通过Google搜索汉语描述 通过Google搜索英语描述 通过StackOverflow搜索英语描述 通过专业论坛例如Qt论坛、Unity论坛、Reddit编程版搜索英语描述 通过GitHub等开发页面搜索Issues匹配类似问题 学会提问学会提问，首先学会描述问题 提问的智慧 当搜索无法解决时，选择以下方法： 通过GitHub提出Issue直接咨询开发者 在国内论坛通过汉语提出问题咨询 在国外论坛通过英语提出问题咨询 在StackOverflow通过英语提出问题咨询 向认识的计算机专业人士与程序员咨询 软件安装与环境配置软件安装安装软件，首先选择正确的网站下载安装包，否则就是…… 寻找大型商业软件替代品：AlternativeTo 参考软件列表：作为程序员的你，常用的工具软件有哪些？ 对于IDE选择最新的版本！一定不能用VC++等过时工具 环境配置学会搜索，学会提问 保持耐心，仔细解决可能出现的报错 出现网络问题换国内镜像或代理命令行 配置环境时及时进行记录，便于日后更换机器时寻找资料 工具与IDE工具学会使用Git命令（若需要可学习SVN） 学会使用GitHub，尝试使用Hexo等引擎搭建博客（可以进一步了解域名） 学会使用命令行cmd、powershell、zsh等 学会使用markdown和LaTeX（可以使用Typora、Obsidian等软件） 学会使用ssh连接远程主机（可以使用MobaXterm、XShell、FinalShell等软件） 使用记事本升级版Notepad++，有时可以解决很多简单的文本编辑问题 Downloads | Notepad++ 尝试使用笔记软件Notion、OneNote、语雀等 尝试了解Linux及其发行版Ubuntu、Debian等 尝试了解Windows Terminal及WSL（适用于Linux的Windows子系统 Windows Subsystem for Linux） 详细可以参考CS自学指南的内容 IDE集成开发环境（Integrated Development Environment，简称IDE，也称为Integration Design Environment、Integration Debugging Environment）是一种辅助程序开发人员开发软件的应用软件，在开发工具内部就可以辅助编写源代码文本、并编译打包成为可用的程序，有些甚至可以设计图形接口。 了解编程语言Which Programming Language Should I Learn First? [Infographic] TIOBE Index for June 2022 June Headline: C++ is about to surpass Java HelloGitHub 2022年05月编程语言排行榜 PYPL PopularitY of Programming Language 了解并安装IDETop IDE index 微软方面的VS、VSCode是可能用到的选择 Visual Studio 2022 IDE - 适用于软件开发人员的编程工具 Visual Studio Code - Code Editing. Redefined JetBrains方面的各种语言的IDE也非常人性化、方便 JetBrains 出品的所有开发者工具和产品 参考资料CS自学指南CS自学指南 必学工具：IDE, 翻墙, StackOverflow, Git, GitHub, Vim, LaTeX, GNU Make, 实用工具 … 国外高质量 CS 课程汇总：我将把我上过的所有高质量的国外 CS 课程分门别类进行汇总，并给出相关的自学建议，大部分课程都会有一个独立的仓库维护相关的资源以及我的作业实现。 环境配置：Linux 基础，bash，环境变量，Anaconda … 经典书籍推荐：看过 CSAPP 这本书的同学一定感叹好书的重要，我将列举推荐自己看过的计算机领域的必看好书与资源链接。 MIT-Missing-Semester 计算机教育中缺失的一课The Missing Semester of Your CS Education 中文版 大学里的计算机课程通常专注于讲授从操作系统到机器学习这些学院派的课程或主题，而对于如何精通工具这一主题则往往会留给学生自行探索。在这个系列课程中，我们讲授命令行、强大的文本编辑器的使用、使用版本控制系统提供的多种特性等等。学生在他们受教育阶段就会和这些工具朝夕相处（在他们的职业生涯中更是这样）。 因此，花时间打磨使用这些工具的能力并能够最终熟练地、流畅地使用它们是非常有必要的。 精通这些工具不仅可以帮助您更快的使用工具完成任务，并且可以帮助您解决在之前看来似乎无比复杂的问题。 南京大学 计算机系统基础 课程实验 (PA)南京大学 计算机科学与技术系 计算机系统基础 课程实验 2022 理解”程序如何在计算机上运行”的根本途径是从”零”开始实现一个完整的计算机系统. 南京大学计算机科学与技术系计算机系统基础课程的小型项目 (Programming Assignment, PA)将提出x86/mips32/riscv32(64)架构相应的教学版子集, 指导学生实现一个经过简化但功能完备的x86/mips32/riscv32(64)模拟器NEMU(NJU EMUlator), 最终在NEMU上运行游戏”仙剑奇侠传”, 来让学生探究”程序在计算机上运行”的基本原理. NEMU受到了QEMU的启发, 并去除了大量与课程内容差异较大的部分. PA包括一个准备实验(配置实验环境)以及5部分连贯的实验内容: 图灵机与简易调试器 冯诺依曼计算机系统 批处理系统 分时多任务 程序性能优化 后记了解OI、ACM、CTFOI Wiki CTF Wiki 一些入门学习菜鸟教程 - 学的不仅是技术，更是梦想！ w3school 在线教程 【计算机科学速成课】[40集全/精校] - Crash Course Computer Science 【官方双语/合集】线性代数的本质 - 系列合集 【官方双语/合集】微积分的本质 - 系列合集 软件开发对数学的要求普通的软件开发不需要过多的数学知识，只需要建立对离散数学的认识，掌握数据结构与算法即可 软件开发需要信息的获取与整理能力、良好的沟通能力、规划与设计能力、耐心与仔细地编写代码 对于计算机研究来说，就我通过网络的了解而言： 人工智能（ML、CV、NLP）：数学分析 -&gt; 实变函数 -&gt; 概率论与数理统计 离散数学 算法分析 数据结构 程序语言研究（PLT）：高等代数 -&gt; 代数结构 -&gt; 抽象代数 数理逻辑 类型论 范畴论 计算理论：离散数学 -&gt; 形式语言与自动机 算法分析 学习内容的分类编程语言与框架C、C++、C#、Java、Python、JavaScript、TypeScript、HTML、CSS、Haskell等 Qt、SpringBoot、Flutter、Vue.js、React.js、Unity、UE5等 画了个图，拼凑了些自己见过的东西 算法与数据结构写一点题：https://leetcode.cn/ 计算机基础理论知识可以看一些经典教材，比如深入理解计算机系统（CS : APP） 做一些课程Lab，例如mit6.824等 操作系统，计算机组成原理，计算机网络，编译原理、数据库系统等 实际开发项目Windows桌面应用、Unity或者UE4游戏、web前后端、小程序、Android / iOS应用等 事实上，一般情况下，web前后端是比较常见的 软件工程知识学习设计模式，OOD，System Design等 版本控制系统的使用，例如Git、SVN 其他各种杂项工具的使用 一些面试经验前端工具链，Java的基础知识等，各种框架和组件的应用、细节、实现等","categories":[{"name":"编程","slug":"编程","permalink":"https://shiokiri.com/categories/编程/"}],"tags":[{"name":"技术工具","slug":"技术工具","permalink":"https://shiokiri.com/tags/技术工具/"},{"name":"计算机科学","slug":"计算机科学","permalink":"https://shiokiri.com/tags/计算机科学/"}]},{"title":"MySQL数据库学习笔记","slug":"2022-06-28-mysql","date":"2022-06-28T06:54:44.000Z","updated":"2022-06-28T07:16:50.039Z","comments":true,"path":"2022-06-28-mysql/","link":"","permalink":"https://shiokiri.com/2022-06-28-mysql/","excerpt":"更新于：A.D.2022.06.28","text":"更新于：A.D.2022.06.28 参考书籍：《MySQL必知必会》 检索数据SELECT语句检索单个列 SELECT 列 FROM 表; 检索多个列 SELECT 列, 列, 列 FROM 表; 检索所有列 SELECT * FROM 表; 检索不同的行 SELECT 行 FROM 表; SELECT DISTINCT 行 FROM 表; 限制结果 SELECT 列 FROM 表 LIMIT 数量; SELECT 列 FROM 表 LIMIT 数量 OFFSET 行号; 排序检索数据ORDER BY语句按单个列排序 SELECT 列 FROM 表 ORDER BY 列; 按多个列排序 SELECT 列, 列, 列 FROM 表 ORDER BY 列, 列; 指定排序方向 使用DESC关键字，作用于位于前面的列名 SELECT 列, 列, 列 FROM 表 ORDER BY 列 DESC; SELECT 列, 列, 列 FROM 表 ORDER BY 列 DESC, 列; 过滤数据WHERE子句SELECT 列, 列 FROM 表 WHERE 列 = 值; WHERE 子句操作符 操作符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 在指定的两个值之间 检查单个值 SELECT 列, 列 FROM 表 WHERE 列 = 值; SELECT 列, 列 FROM 表 WHERE 列 &lt; 值; SELECT 列, 列 FROM 表 WHERE 列 &lt;= 值; 不匹配检查 SELECT 列, 列 FROM 表 WHERE 列 &lt;&gt; 值; SELECT 列, 列 FROM 表 WHERE 列 != 值; 范围值检查 SELECT 列, 列 FROM 表 WHERE 列 BETWEEN 值 AND 值; 空值检查 SELECT 列 FROM 表 WHERE 列 IS NULL;","categories":[{"name":"编程","slug":"编程","permalink":"https://shiokiri.com/categories/编程/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://shiokiri.com/tags/MySQL/"},{"name":"SQL","slug":"SQL","permalink":"https://shiokiri.com/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"https://shiokiri.com/tags/数据库/"}]},{"title":"C++Qt局域网聊天工具 开发记录","slug":"2022-06-27-cpp-qt","date":"2022-06-27T11:46:49.000Z","updated":"2025-03-21T00:48:10.489Z","comments":true,"path":"2022-06-27-cpp-qt/","link":"","permalink":"https://shiokiri.com/2022-06-27-cpp-qt/","excerpt":"更新于：A.D.2022.06.27","text":"更新于：A.D.2022.06.27 配置环境配置Qt开发环境：https://www.qt.io/download 准备工作建立GitHub仓库 https://github.com/Shiokiri/Qt-LAN-Chat 阅读Qt官方文档 https://doc.qt.io/qt-6/classes.html 开发过程参考了《Qt及Qt Quick开发实战精解》书籍中的实现方法。 配置.pro文件首先配置qmake的相关配置 QT += core gui greaterThan(QT_MAJOR_VERSION, 4): QT += widgets CONFIG += c++17 # You can make your code fail to compile if it uses deprecated APIs. # In order to do so, uncomment the following line. #DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the APIs deprecated before Qt 6.0.0 ICONS += SOURCES += \\ main.cpp \\ tcpclient.cpp \\ tcpserver.cpp \\ widget.cpp HEADERS += \\ tcpclient.h \\ tcpserver.h \\ widget.h FORMS += \\ tcpclient.ui \\ tcpserver.ui \\ widget.ui # Default rules for deployment. qnx: target.path = /tmp/$${TARGET}/bin else: unix:!android: target.path = /opt/$${TARGET}/bin !isEmpty(target.path): INSTALLS += target QT += network RESOURCES += \\ Images.qrc 绘制UI通过Qt Creator的设计模式进行绘制，参考上述书籍。 选取ICON图标在 iconfont-阿里巴巴矢量图标库 选取图标。 编写头文件变量的命名和使用需要和设计模式中命名一致，参考上述书籍。 部分槽函数的建立需要通过设计模式进行，参考上述书籍。 widget.h#ifndef WIDGET_H #define WIDGET_H #include &lt;QWidget&gt; #include &lt;QColorDialog&gt; #include &lt;QTextCharFormat&gt; class QUdpSocket; class TcpServer; QT_BEGIN_NAMESPACE namespace Ui { class Widget; } QT_END_NAMESPACE enum MessageType { Message, // 消息 NewParticipant, // 新用户加入 ParticipantLeft, // 用户退出 FileName, // 文件名 Refuse, // 拒绝接收文件 }; class Widget : public QWidget { Q_OBJECT public: Widget(QWidget * parent = nullptr); ~Widget(); protected: void newParticipant(QString username, QString localHostName, QString ipAddress); void participantLeft(QString userName, QString localHostName, QString time); void sendMessage(MessageType type, QString serverAddress = &quot;&quot;); QString getIP(); QString getUserName(); QString getMessage(); void hasPendingFile(QString userName, QString serverAddress, QString clientAddress, QString fileName); bool saveFile(const QString &amp;fileName); void closeEvent(QCloseEvent *); private: Ui::Widget *ui; QUdpSocket * udpSocket; qint64 port; QString fileName; TcpServer * server; QColor color; private slots: void processPendingDatagrams(); void on_sendButton_clicked(); void getFileName(QString); void on_sendToolBtn_clicked(); void on_fontComboBox_currentFontChanged(const QFont &amp;f); void on_sizeComboBox_currentTextChanged(const QString &amp;arg1); void on_boldToolBtn_clicked(bool checked); void on_italicToolBtn_clicked(bool checked); void on_underlineToolBtn_clicked(bool checked); void on_colorToolBtn_clicked(); void currentFormatChanged(const QTextCharFormat &amp;format); void on_saveToolBtn_clicked(); void on_clearToolBtn_clicked(); void on_exitButton_clicked(); }; #endif // WIDGET_H tcpserver.h#ifndef TCPSERVER_H #define TCPSERVER_H #include&lt;QDialog&gt; #include&lt;QTcpServer&gt; #include&lt;QFile&gt; #include&lt;QTcpSocket&gt; #include&lt;QTime&gt; #include&lt;QFileDialog&gt; #include&lt;QString&gt; #include&lt;QCloseEvent&gt; #include&lt;QWidget&gt; #include&lt;QKeyEvent&gt; #include&lt;QHostAddress&gt; #include&lt;QElapsedTimer&gt; QT_BEGIN_NAMESPACE namespace Ui { class TcpServer; } QT_END_NAMESPACE class QTcpServer; class QTcpSocket; class TcpServer : public QDialog { Q_OBJECT public: explicit TcpServer(QWidget *parent = nullptr); ~TcpServer(); void initServer(); void refused(); protected: void closeEvent(QCloseEvent *); signals: void sendFileName(QString ); private slots: void on_serverOpenBtn_clicked(); void on_serverSendBtn_clicked(); void on_serverCloseBtn_clicked(); void sendMessage(); void updateClientProgress(qint64); private: Ui::TcpServer *ui; QTcpServer *tcpServer; QTcpSocket *clientConnection; qint16 tcpPort; QFile *localFile ; qint64 payloadSize ; qint64 TotalBytes ; qint64 bytesWritten ; qint64 bytestoWrite; QString theFileName; QString fileName; QElapsedTimer elapsedTimer; QByteArray outBlock; }; #endif tcpclient.h#ifndef TCPCLIENT_H #define TCPCLIENT_H #include &lt;QDialog&gt; #include &lt;QTcpServer&gt; #include &lt;QFile&gt; #include &lt;QTcpSocket&gt; #include &lt;QTime&gt; #include &lt;QFileDialog&gt; #include &lt;QString&gt; #include &lt;QCloseEvent&gt; #include &lt;QHostAddress&gt; #include &lt;QElapsedTimer&gt; namespace Ui { class TcpClient; } class TcpClient : public QDialog { Q_OBJECT public: explicit TcpClient(QWidget *parent = nullptr); ~TcpClient(); void setFileName(QString fileName); void setHostAddress(QHostAddress address); void closeEvent(QCloseEvent *); QFile *localFile; private slots: void on_tcpClientCloseBtn_clicked(); void readMessage(); void displayError(QAbstractSocket::SocketError); void newConnect(); void on_tcpClientCancelBtn_clicked(); private: Ui::TcpClient *ui; QTcpSocket *tcpClient; qint16 tcpPort ; QHostAddress hostAddress; qint64 TotalBytes ; qint64 bytesReceived; qint64 fileNameSize ; qint64 blockSize; QString fileName; QElapsedTimer time; QByteArray inBlock; }; #endif // TCPCLIENT_H 编写源文件变量的命名和使用需要和设计模式中命名一致，参考上述书籍。 部分槽函数的建立需要通过设计模式进行，参考上述书籍。 main.cpp#include &quot;widget.h&quot; #include &lt;QApplication&gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); Widget w; w.show(); return a.exec(); } widget.cpp#include &quot;widget.h&quot; #include &quot;ui_widget.h&quot; #include &quot;tcpserver.h&quot; #include &quot;tcpclient.h&quot; #include &lt;QFileDialog&gt; #include &lt;QUdpSocket&gt; #include &lt;QHostInfo&gt; #include &lt;QMessageBox&gt; #include &lt;QscrollBar&gt; #include &lt;QDateTime&gt; #include &lt;QNetworkInterface&gt; #include &lt;QProcess&gt; Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget) { ui -&gt; setupUi(this); udpSocket = new QUdpSocket(this); port = 45454; udpSocket -&gt; bind(port, QUdpSocket::ShareAddress | QUdpSocket::ReuseAddressHint); connect(udpSocket, SIGNAL(readyRead()), this, SLOT(processPendingDatagrams())); sendMessage(NewParticipant); server = new TcpServer(this); connect(server, SIGNAL(sendFileName(QString)), this, SLOT(getFileName(QString))); } Widget::~Widget() { delete ui; } void Widget::sendMessage(MessageType type, QString serverAddress) { QByteArray data; QDataStream out(&amp;data, QIODevice::WriteOnly); QString localHostName = QHostInfo::localHostName(); QString address = getIP(); out &lt;&lt; type &lt;&lt; getUserName() &lt;&lt; localHostName; switch(type) { case Message: { if(ui -&gt; messageTextEdit -&gt; toPlainText() == &quot;&quot;) { QMessageBox::warning(0, tr(&quot;警告&quot;), tr(&quot;发送内容不能为空&quot;), QMessageBox::Ok); return; } out &lt;&lt; address &lt;&lt; getMessage(); ui -&gt; messageBrowser -&gt; verticalScrollBar() -&gt; setValue(ui -&gt; messageBrowser -&gt; verticalScrollBar() -&gt; maximum()); break; } case NewParticipant: { out &lt;&lt; address; break; } case ParticipantLeft: { break; } case FileName: { int row = ui -&gt; userTableWidget -&gt; currentRow(); QString clientAddress = ui -&gt; userTableWidget -&gt; item(row, 2) -&gt; text(); out &lt;&lt; address &lt;&lt; clientAddress &lt;&lt; fileName; break; } case Refuse: { out &lt;&lt; serverAddress; break; } } udpSocket -&gt; writeDatagram(data, data.length(), QHostAddress::Broadcast, port); } void Widget::processPendingDatagrams() { qDebug() &lt;&lt; &quot;processPendingDatagrams&quot;; while(udpSocket -&gt; hasPendingDatagrams()) { QByteArray datagram; datagram.resize(udpSocket -&gt; pendingDatagramSize()); udpSocket -&gt; readDatagram(datagram.data(), datagram.size()); QDataStream in(&amp;datagram, QIODevice::ReadOnly); int messageType; in &gt;&gt; messageType; QString userName, localHostName, ipAddress, message; QString time = QDateTime::currentDateTime() .toString(&quot;yyyy-MM-dd hh:mm:ss&quot;); switch(messageType) { case Message: { in &gt;&gt; userName &gt;&gt; localHostName &gt;&gt; ipAddress &gt;&gt; message; ui -&gt; messageBrowser -&gt; setTextColor(Qt::blue); ui -&gt; messageBrowser -&gt; setCurrentFont(QFont(&quot;Times New Roman&quot;, 12)); ui -&gt; messageBrowser -&gt; append(&quot;[ &quot; + userName + &quot; ] &quot; + time); ui -&gt; messageBrowser -&gt; append(message); break; } case NewParticipant: { in &gt;&gt; userName &gt;&gt; localHostName &gt;&gt; ipAddress; newParticipant(userName, localHostName, ipAddress); break; } case ParticipantLeft: { in &gt;&gt; userName &gt;&gt; localHostName; participantLeft(userName, localHostName, time); break; } case FileName: { qDebug() &lt;&lt; &quot;FileName1&quot;; in &gt;&gt; userName &gt;&gt; localHostName &gt;&gt; ipAddress; QString clientAddress, fileName; in &gt;&gt; clientAddress &gt;&gt; fileName; qDebug() &lt;&lt; &quot;FileName2&quot;; hasPendingFile(userName, ipAddress, clientAddress, fileName); qDebug() &lt;&lt; &quot;FileName end&quot;; break; } case Refuse: { in &gt;&gt; userName &gt;&gt; localHostName; QString serverAddress; in &gt;&gt; serverAddress; QString ipAddress = getIP(); if(ipAddress == serverAddress) { server -&gt; refused(); } break; } } } } void Widget::newParticipant(QString userName, QString localHostName, QString ipAddress) { qDebug() &lt;&lt; &quot;newParticipant&quot;; bool isEmpty = ui -&gt; userTableWidget -&gt; findItems(localHostName, Qt::MatchExactly).isEmpty(); if(isEmpty) { QTableWidgetItem * user = new QTableWidgetItem(userName); QTableWidgetItem * host = new QTableWidgetItem(localHostName); QTableWidgetItem * ip = new QTableWidgetItem(ipAddress); ui -&gt; userTableWidget -&gt; insertRow(0); ui -&gt; userTableWidget -&gt; setItem(0, 0, user); ui -&gt; userTableWidget -&gt; setItem(0, 1, host); ui -&gt; userTableWidget -&gt; setItem(0, 2, ip); ui -&gt; messageBrowser -&gt; setTextColor(Qt::gray); ui -&gt; messageBrowser -&gt; setCurrentFont(QFont(&quot;Microsoft YaHei UI&quot;, 10)); ui -&gt; messageBrowser -&gt; append(tr(&quot;%1在线！&quot;).arg(userName)); ui -&gt; userNumLabel -&gt; setText(tr(&quot;在线人数：%1&quot;) .arg(ui -&gt; userTableWidget -&gt; rowCount())); sendMessage(NewParticipant); } } void Widget::participantLeft(QString userName, QString localHostName, QString time) { int rowNum = ui -&gt; userTableWidget -&gt; findItems(localHostName, Qt::MatchExactly).first() -&gt; row(); ui -&gt; userTableWidget -&gt; removeRow(rowNum); ui -&gt; messageBrowser -&gt; setTextColor(Qt::gray); ui -&gt; messageBrowser -&gt; setCurrentFont(QFont(&quot;Microsoft YaHei UI&quot;, 10)); ui -&gt; messageBrowser -&gt; append(tr(&quot;%1于%2离开！&quot;).arg(userName).arg(time)); ui -&gt; userNumLabel -&gt; setText(tr(&quot;在线人数：%1&quot;) .arg(ui -&gt; userTableWidget -&gt; rowCount())); } QString Widget::getIP() { QList&lt;QHostAddress&gt; list = QNetworkInterface::allAddresses(); foreach(QHostAddress address, list) { if(address.protocol() == QAbstractSocket::IPv4Protocol) return address.toString(); } return 0; } QString Widget::getUserName() { QStringList environment = QProcess::systemEnvironment(); QStringList userNameList = environment.filter(&quot;USERNAME&quot;); foreach(QString string, userNameList) { QStringList stringList = string.split(&#39;=&#39;); if(stringList.size() == 2 &amp;&amp; stringList.at(0) == &quot;USERNAME&quot;) { return stringList.at(1); break; } } return &quot;unknown&quot;; } QString Widget::getMessage() { QString msg = ui -&gt; messageTextEdit -&gt; toHtml(); ui -&gt; messageTextEdit -&gt; clear(); ui -&gt; messageTextEdit -&gt; setFocus(); return msg; } void Widget::on_sendButton_clicked() { sendMessage(Message); } void Widget::getFileName(QString name) { qDebug() &lt;&lt; &quot;getFileName&quot;; fileName = name; sendMessage(FileName); } void Widget::on_sendToolBtn_clicked() { if(ui -&gt; userTableWidget -&gt; selectedItems().isEmpty()) { QMessageBox::warning(0, tr(&quot;选择用户&quot;), tr(&quot;请先从用户列表选择要传送的用户！&quot;), QMessageBox::Ok); return; } server -&gt; show(); server -&gt; initServer(); } void Widget::hasPendingFile(QString userName, QString serverAddress, QString clientAddress, QString fileName) { qDebug() &lt;&lt; &quot;hasPendingFile&quot;; QString ipAddress = getIP(); if(ipAddress == clientAddress) { int btn = QMessageBox::information(this, tr(&quot;接收文件&quot;), tr(&quot;来自%1(%2)的文件：%3，是否接收？&quot;) .arg(userName).arg(serverAddress).arg(fileName), QMessageBox::Yes, QMessageBox::No); if(btn == QMessageBox::Yes) { qDebug() &lt;&lt; &quot;hasPendingFile Yes&quot;; QString name = QFileDialog::getSaveFileName(0, tr(&quot;保存文件&quot;), fileName); if(!name.isEmpty()) { TcpClient * client = new TcpClient(this); client -&gt; setFileName(name); client -&gt; setHostAddress(QHostAddress(serverAddress)); client -&gt; show(); } } else { sendMessage(Refuse, serverAddress); } } qDebug() &lt;&lt; &quot;hasPendingFile end&quot;; } void Widget::on_fontComboBox_currentFontChanged(const QFont &amp;f) { ui -&gt; messageTextEdit -&gt; setCurrentFont(f); ui -&gt; messageTextEdit -&gt; setFocus(); } void Widget::on_sizeComboBox_currentTextChanged(const QString &amp;size) { ui -&gt; messageTextEdit -&gt; setFontPointSize(size.toDouble()); ui -&gt; messageTextEdit -&gt; setFocus(); } void Widget::on_boldToolBtn_clicked(bool checked) { if(checked) { ui -&gt; messageTextEdit -&gt; setFontWeight(QFont::Bold); } else { ui -&gt; messageTextEdit -&gt; setFontWeight(QFont::Normal); } ui -&gt; messageTextEdit -&gt; setFocus(); } void Widget::on_italicToolBtn_clicked(bool checked) { ui -&gt; messageTextEdit -&gt; setFontItalic(checked); ui -&gt; messageTextEdit -&gt; setFocus(); } void Widget::on_underlineToolBtn_clicked(bool checked) { ui -&gt; messageTextEdit -&gt; setFontUnderline(checked); ui -&gt; messageTextEdit -&gt; setFocus(); } void Widget::on_colorToolBtn_clicked() { color = QColorDialog::getColor(color, this); if(color.isValid()) { ui -&gt; messageTextEdit -&gt; setTextColor(color); ui -&gt; messageTextEdit -&gt; setFocus(); } } void Widget::currentFormatChanged(const QTextCharFormat &amp;format) { ui -&gt; fontComboBox -&gt; setCurrentFont(format.font()); if(format.fontPointSize() &lt; 10) { ui -&gt; sizeComboBox -&gt; setCurrentIndex(3); } else { ui -&gt; sizeComboBox -&gt; setCurrentIndex(ui -&gt; sizeComboBox -&gt; findText(QString::number(format.fontPointSize()))); } ui -&gt; boldToolBtn -&gt; setChecked(format.font().bold()); ui -&gt; italicToolBtn -&gt; setChecked(format.font().italic()); ui -&gt; underlineToolBtn -&gt; setChecked(format.font().underline()); color = format.foreground().color(); } void Widget::on_saveToolBtn_clicked() { if(ui -&gt; messageBrowser -&gt; document() -&gt; isEmpty()) { QMessageBox::warning(0, tr(&quot;警告&quot;), tr(&quot;聊天记录为空，无法保存！&quot;), QMessageBox::Ok); } else { QString fileName = QFileDialog::getSaveFileName(this, tr(&quot;保存聊天记录&quot;), tr(&quot;聊天记录&quot;), tr(&quot;文本(*.txt);;All File(*.*)&quot;)); if(! fileName.isEmpty()) { saveFile(fileName); } } } bool Widget::saveFile(const QString &amp;fileName) { QFile file(fileName); if(! file.open(QFile::WriteOnly | QFile::Text)) { QMessageBox::warning(this, tr(&quot;保存文件&quot;), tr(&quot;无法保存文件%1:\\n%2&quot;) .arg(fileName).arg(file.errorString())); return false; } QTextStream out(&amp;file); out &lt;&lt; ui -&gt; messageBrowser -&gt; toPlainText(); return true; } void Widget::on_clearToolBtn_clicked() { ui -&gt; messageBrowser -&gt; clear(); } void Widget::on_exitButton_clicked() { close(); } void Widget::closeEvent(QCloseEvent * e) { sendMessage(ParticipantLeft); QWidget::closeEvent(e); } tcpserver.cpp#include &quot;tcpserver.h&quot; #include &quot;ui_tcpserver.h&quot; #include&lt;QHostInfo&gt; #include&lt;QMessageBox&gt; #include&lt;QDateTime&gt; #include&lt;QProcess&gt; #include&lt;QDataStream&gt; #include&lt;QScrollBar&gt; #include&lt;QFont&gt; #include&lt;QNetworkInterface&gt; #include&lt;QStringList&gt; #include&lt;QDebug&gt; #include&lt;QApplication&gt; #include&lt;QTime&gt; #include&lt;QElapsedTimer&gt; TcpServer::TcpServer(QWidget *parent) : QDialog(parent), ui(new Ui::TcpServer), localFile(nullptr), tcpServer(nullptr), clientConnection(nullptr) { ui-&gt;setupUi(this); //setFixedSize(350,180); tcpPort = 10006; tcpServer = new QTcpServer(this); initServer(); connect(tcpServer, SIGNAL(newConnection()), this, SLOT(sendMessage())); } TcpServer::~TcpServer() { delete ui; } void TcpServer::initServer() { payloadSize = 64 * 1024; TotalBytes = 0 ; bytestoWrite = 0; bytesWritten = 0; ui -&gt; serverStatusLabel -&gt; setText(tr(&quot;请选择要传送的文件&quot;)); ui -&gt; progressBar -&gt; reset(); ui -&gt; serverOpenBtn -&gt; setEnabled(true); ui -&gt; serverSendBtn -&gt; setEnabled(false); tcpServer -&gt; close(); } void TcpServer :: sendMessage() { qDebug() &lt;&lt; &quot;sendMessage&quot;; qDebug() &lt;&lt; &quot;TCP的链接已建立&quot;; ui -&gt; serverSendBtn -&gt; setEnabled(false); clientConnection = tcpServer -&gt; nextPendingConnection(); connect(clientConnection, SIGNAL(bytesWritten(qint64)), this, SLOT(updateClientProgress(qint64))); ui -&gt; serverStatusLabel -&gt; setText(tr(&quot;开始传送文件:\\n %1!&quot;).arg(theFileName)); localFile = new QFile(fileName); if(!localFile -&gt; open(QFile::ReadOnly)){ QMessageBox::warning(this, tr(&quot;应用程序&quot;), tr(&quot;无法读取文件 %1:\\n%2&quot;).arg(fileName) .arg(localFile -&gt; errorString())); return; } TotalBytes = localFile -&gt; size(); QDataStream sendOut(&amp;outBlock, QIODevice::WriteOnly); sendOut.setVersion(QDataStream::Qt_4_0); elapsedTimer.start(); QString currentFile = fileName.right(fileName.size() - fileName.lastIndexOf(&#39;/&#39;) - 1); sendOut &lt;&lt; qint64(0) &lt;&lt; qint64(0) &lt;&lt; currentFile; TotalBytes += outBlock.size(); sendOut.device() -&gt; seek(0); sendOut &lt;&lt; TotalBytes &lt;&lt; qint64((outBlock.size() - sizeof(qint64)*2)); bytestoWrite = TotalBytes - clientConnection -&gt; write(outBlock); outBlock.resize(0); } void TcpServer::updateClientProgress(qint64 numBytes) { qDebug() &lt;&lt; &quot;updateClientProgress&quot;; qApp -&gt; processEvents(); bytesWritten += (int) numBytes; if(bytestoWrite &gt; 0) { outBlock = localFile -&gt; read(qMin(bytestoWrite,payloadSize)); bytestoWrite -= (int)clientConnection -&gt; write(outBlock); outBlock.resize(0); } else { localFile -&gt; close(); } ui-&gt;progressBar -&gt; setMaximum(TotalBytes); ui-&gt;progressBar -&gt; setValue(bytesWritten); float useTime = elapsedTimer.elapsed(); qDebug() &lt;&lt; &quot;uerTime:&quot; &lt;&lt; useTime; double speed = bytesWritten / useTime; ui-&gt;serverStatusLabel-&gt;setText(tr(&quot;已发送 %1MB( %2MB/s)&quot; &quot;\\n共%3MB 已用时:%4秒\\n估计剩余时间:%5秒&quot;) .arg(bytesWritten / (1024*1024)) .arg(speed * 1000 /(1024*1024),0,&#39;f&#39;,2) .arg(TotalBytes /(1024*1024)) .arg(useTime/1000,0,&#39;f&#39;,0) .arg(TotalBytes/speed/1000 - useTime/1000,0,&#39;f&#39;,0)); if(bytesWritten == TotalBytes) { localFile-&gt;close(); tcpServer-&gt;close(); ui-&gt;serverStatusLabel-&gt;setText(tr(&quot;传送文件: %1成功&quot;).arg(theFileName)); } } void TcpServer::on_serverOpenBtn_clicked() { fileName = QFileDialog::getOpenFileName(this); if(!fileName.isEmpty()) { theFileName = fileName.right(fileName.size()-fileName.lastIndexOf(&#39;/&#39;)-1); qDebug() &lt;&lt; &quot;文件名&quot; &lt;&lt; theFileName; ui-&gt;serverStatusLabel-&gt;setText(tr(&quot;要发送的文件为:%1&quot;).arg(theFileName)); ui-&gt;serverSendBtn-&gt;setEnabled(true); ui-&gt;serverOpenBtn-&gt;setEnabled(false); } qDebug() &lt;&lt; &quot;openbtn end&quot; &lt;&lt; theFileName; } void TcpServer::on_serverSendBtn_clicked() { if(! tcpServer -&gt; listen(QHostAddress::Any, tcpPort)) { qDebug() &lt;&lt; &quot;send btn error&quot; &lt;&lt; theFileName; //qDebug() &lt;&lt; tcpServer -&gt; errorString() &lt;&lt; &quot;ERROR&quot;; close(); return; } qDebug() &lt;&lt; &quot;send btn 1&quot; &lt;&lt; theFileName; ui -&gt; serverSendBtn -&gt; setEnabled(false); ui -&gt; serverStatusLabel -&gt; setText(tr(&quot;等待对方的接受......&quot;)); qDebug() &lt;&lt; &quot;send btn 2&quot; &lt;&lt; theFileName; emit sendFileName(theFileName); qDebug() &lt;&lt; &quot;send btn end&quot; &lt;&lt; theFileName; } void TcpServer::on_serverCloseBtn_clicked() { qDebug() &lt;&lt; &quot;关闭&quot; ; if(tcpServer-&gt;isListening()) { qDebug() &lt;&lt; &quot;点击了关闭按钮&quot;; tcpServer-&gt;close(); if(localFile != nullptr) { if(localFile -&gt; isOpen()) { localFile -&gt; close(); } } clientConnection-&gt;abort(); } close(); ui-&gt;~TcpServer(); } void TcpServer::refused() { qDebug() &lt;&lt; &quot;TcpServer::refused()&quot;; tcpServer-&gt;close(); ui-&gt;serverStatusLabel-&gt;setText(tr(&quot;对方拒绝接受!&quot;)); } void TcpServer::closeEvent(QCloseEvent *) { qDebug() &lt;&lt; &quot;退出了server&quot;; on_serverCloseBtn_clicked(); } tcpclient.cpp#include &quot;tcpclient.h&quot; #include &quot;ui_tcpclient.h&quot; #include &lt;QMessageBox&gt; TcpClient::TcpClient(QWidget *parent) : QDialog(parent), tcpClient(nullptr), localFile(nullptr), ui(new Ui::TcpClient) { ui-&gt;setupUi(this); TotalBytes = 0; bytesReceived = 0; fileNameSize = 0; tcpClient = new QTcpSocket(this); tcpPort = 10006; connect(tcpClient, SIGNAL(readyRead()), this, SLOT(readMessage())); //connect(tcpClient, SIGNAL(QAbstractSocket::SocketError), // this, SLOT(Dialog(QAbstractSocket::SocketError))); } TcpClient::~TcpClient() { delete ui; } void TcpClient::setFileName(QString fileName) { localFile = new QFile(fileName); } void TcpClient::setHostAddress(QHostAddress address) { hostAddress = address; newConnect(); } void TcpClient::newConnect() { blockSize = 0; tcpClient-&gt;abort(); tcpClient-&gt;connectToHost(hostAddress,tcpPort); time.start(); } void TcpClient::readMessage() { qDebug() &lt;&lt; &quot;readMessage&quot;; QDataStream in(tcpClient); in.setVersion(QDataStream::Qt_4_0); float useTime = time.elapsed(); if(bytesReceived &lt;= sizeof(qint64)*2) { if((tcpClient -&gt; bytesAvailable() &gt;= sizeof(qint64)*2) &amp;&amp; (fileNameSize ==0)) { in &gt;&gt; TotalBytes &gt;&gt; fileNameSize; bytesReceived += sizeof(qint64)*2; } if((tcpClient -&gt; bytesAvailable() &gt;= fileNameSize) &amp;&amp; (fileNameSize!=0)) { in &gt;&gt; fileName; bytesReceived += fileNameSize; if(! localFile -&gt; open(QFile::WriteOnly)) { QMessageBox::warning(this,tr(&quot;应用程序&quot;),tr(&quot;无法读取文件 %1:\\n%2.&quot;) .arg(fileName) .arg(localFile-&gt;errorString())); return ; } else return ; } } if(bytesReceived &lt; TotalBytes) { bytesReceived += tcpClient-&gt;bytesAvailable(); inBlock = tcpClient-&gt;readAll(); localFile -&gt; write(inBlock); inBlock.resize(0); } ui -&gt; progressBar -&gt; setMaximum(TotalBytes); ui -&gt; progressBar -&gt; setValue(bytesReceived); double speed = bytesReceived / useTime; ui-&gt;tcpClientStatusLabel-&gt;setText(tr(&quot;已接收 %1MB( %2MB/s)&quot; &quot;\\n共%3MB 已用时:%4秒\\n估计剩余时间:%5秒&quot;) .arg(bytesReceived / (1024*1024)) .arg(speed *1000/(1024*1024),0,&#39;f&#39;,2) .arg(TotalBytes / (1024*1024)) .arg(useTime/1000,0,&#39;f&#39;,0) .arg(TotalBytes/speed/1000 - useTime/1000,0,&#39;f&#39;,0 )); if(bytesReceived == TotalBytes) { localFile -&gt; close(); tcpClient-&gt; close(); ui-&gt;tcpClientStatusLabel -&gt; setText(tr(&quot;接收文件: %1完毕&quot;).arg(fileName)); } } void TcpClient::displayError(QAbstractSocket::SocketError sockError) { switch (sockError) { case QAbstractSocket::RemoteHostClosedError: break; default: qDebug() &lt;&lt; tcpClient -&gt; errorString(); } } void TcpClient::on_tcpClientCancelBtn_clicked() { tcpClient -&gt; abort(); if(localFile -&gt; isOpen()) { localFile -&gt; close(); } close(); ui -&gt; ~TcpClient(); } void TcpClient::on_tcpClientCloseBtn_clicked() { on_tcpClientCancelBtn_clicked(); } void TcpClient::closeEvent(QCloseEvent *) { on_tcpClientCloseBtn_clicked(); } 处理报错参考 Qt项目升级到Qt6吐血经验总结 将QTime类更换为QElapsedTimer类 程序测试测试消息传输功能：部分UDP丢包导致消息收取不到。 测试文件传输功能：给自身IP地址发送文件会导致卡死。 绘制图表系统功能模块图 用户流程图 UML类图 打包封装参考 Qt之程序发布以及打包成exe安装包 以 Release 方式编译生成 exe 程序运行成功后，如果勾选了 “shadow build” 将源码路径和构建路径分开，那么将在 build 文件夹下生成 exe 文件； 否则在源码工程目录下的 release 文件夹下生成 exe 文件。 将exe程序拷贝到别的文件夹中。 生成dll动态链接库在开始菜单的Qt文件夹中找到Qt 6.3.0 (MinGW 11.2.0 64-bit)，打开后进入exe文件目录，输入 windeployqt 程序名.exe Qt 就会自动把该程序所需要的所有 dll 拷贝过来。 这样即可成功运行，但不能保证dll数量最小化，程序体积可能较大。 在GitHub上发布Releasehttps://github.com/Shiokiri/Qt-LAN-Chat/releases/tag/v1.0","categories":[{"name":"编程","slug":"编程","permalink":"https://shiokiri.com/categories/编程/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://shiokiri.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"https://shiokiri.com/tags/Qt/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://shiokiri.com/tags/计算机网络/"}]},{"title":"C++11学习笔记","slug":"2022-04-01-cpp-11","date":"2022-04-01T13:41:25.000Z","updated":"2022-04-01T14:01:59.359Z","comments":true,"path":"2022-04-01-cpp-11/","link":"","permalink":"https://shiokiri.com/2022-04-01-cpp-11/","excerpt":"更新于：A.D.2022.04.01","text":"更新于：A.D.2022.04.01 参考资料 《C++ Primer Plus》 《C++ Primer》 https://zh.cppreference.com C++11功能新类型long long unsigned long long char16_t char32_t 原始字符串 统一的初始化缩窄std::initializer_list声明autodecltype返回类型后置模板别名：using=nullptr智能指针异常规范方面的修改作用域内枚举对类的修改显式转换运算符explicit 类内成员初始化模板和STL方面的修改基于范围的for循环int p[5] = {1,2,3,4,5}; for(int x : p) std::cout &lt;&lt; x &lt;&lt; std::endl; for(auto x : p) std::cout &lt;&lt; x &lt;&lt; std::endl; //--- std::vector&lt;int&gt; v(10); for(auto &amp; x : v) x = 1; 右值引用&amp; 左值引用 &amp;&amp; 右值引用 移动语义和右值引用新的类功能Lambda函数[](int x) { return x/2; } auto div2 = [](int x) { return x/2; } //--- [](double x) -&gt; double{ int y = x; return x - y; } //--- int x = 0; [&amp;x](int a) { x += a; } //--- int x = 0, y = 0; [&amp;](int a) { x += a; y += a; } 包装器可变参数模板其他新功能","categories":[{"name":"编程","slug":"编程","permalink":"https://shiokiri.com/categories/编程/"}],"tags":[{"name":"C++11","slug":"C-11","permalink":"https://shiokiri.com/tags/C-11/"}]},{"title":"游戏《递归的边界线Recursive Boundary》开发记录","slug":"2022-04-01-unity","date":"2022-04-01T13:04:25.000Z","updated":"2022-04-12T15:10:31.163Z","comments":true,"path":"2022-04-01-unity/","link":"","permalink":"https://shiokiri.com/2022-04-01-unity/","excerpt":"更新于：A.D.2022.04.12","text":"更新于：A.D.2022.04.12 括号内的英文为Unity内置概念 剧情编写与游戏流程设计剧本编写构思了游戏主要设定，编写了游戏剧情文本，分为五个部分，分别在五个场景中计划进行应用 递归的边界线 游戏流程设计设计了游戏流程： Unity引擎操作与C#脚本编写渲染管线选取与美术资源预处理可编程渲染管线是一个瘦 API 层，允许使用 C# 脚本来调度和配置渲染命令。Unity 将这些命令传递给它的低级图形架构，后者随后将指令发送给图形 API。Unity 的可编程渲染管线 (Scriptable Render Pipeline, SRP) 是一项可以通过 C# 脚本来控制渲染的功能。SRP 技术可以强化通用渲染管线 (URP) 和高清渲染管线 (HDRP)。 本次项目选用了通用渲染管线（Universal Render Pipeline），首先通过Unity对美术素材中的Shader升级为URP格式，并手动处理升级失败的Shader。 为树木材质升级失败的场景手动摆放了不同风格的树木，为场景选择了天空盒（Skybox），并调整了场景太阳光点光源设置，调整了URP渲染管线的配置。 人物模型制作与数据格式转换使用人形模型生成软件VRoid Studio进行角色设计，通过数位板（设备：Wocam CTL672）对贴图进行绘画，选择合适三角形面数导出为VRM数据格式，通过GitHub下载Blender Python插件cats-blender-plugin-0-19-0并安装，转换VRM数据格式为通用数据格式FBX，并对模型网格（Mesh），骨骼（Skeleton）等内容进行修复。 在动画网站https://www.mixamo.com/上传模型，并根据具体模型选取动画，并调整网站动画参数，减少穿模，错位，最后下载动画数据FBX文件，并导入Unity。 导入FBX模型文件进入Unity，设置模型动画格式为人形（Humanoid），选择合适的材质球（Material）格式。 第三人称控制系统与动画系统通过Unity官方资源Starter Assets获取基本人形控制器，替换人形的模型与骨骼，替换脚本控制器为当前人物的控制器，通过Unity动画状态机（Animator）完善了默认的走路、跑动、跳跃、静止四种基本状态的状态转换路线。 配置了瞄准动画的动画状态机设置，并通过检测鼠标右键点击切换动画状态，使用了遮罩（Mask）和IK Pass实现了动画转换，制作了选取头部、颈部、与上肢的骨骼遮罩，使瞄准动画的上体动作不在受到基本动画状态的影响。 第三人称射击系统与粒子特效通过光线投射方法计算当前屏幕中心点在场景模型中的投影，并通过投影点与子弹发出点的坐标计算欧拉角，对子弹使用实例化方法，实例一发子弹沿欧拉角方向射出，给出初始速度，并且使子弹完全沿光线方向射出，不受重力影响。 配置了子弹的材质（Material）光效，使得子弹模型显示为红色，并在击中目标后显示绿色粒子光效，未击中目标时显示红色粒子光效。 在瞄准时将虚拟摄像机切换瞄准虚拟摄像机（VirtualCamera），使得人物模型在视野中心偏右，并通过调整图片Alpha值的方法控制UI中心准星的显示，取消瞄准时切换到常规虚拟摄像机，并禁止子弹发出。 调整了常规和瞄准的视角，常规状态时鼠标可环绕，而模型不会转动方向，瞄准状态时模型随鼠标环绕而转动方向。 射中目标后，通过子弹附着的代码，检测刚体碰撞，并获取碰撞物体的对象，通过对象附着的代码暴露出的setter修改射中物体对象的私有属性血量。 通过泛型应用单例设计模式对游戏管理器（GameManager）和场景管理器（SceneController）的代码设计采用单例的设计模式，使整个游戏过程中代码挂载的对象只产生一份。 设计工具类Singleton类并编写虚函数和方法，通过泛型继承Singleton类实现这一设计模式。 场景异步加载与跨场景人物传送通过C#协程（Coroutines）方法，调用UnityEngine继承类中的异步（Asynchronous）加载方法，对场景实行多线程加载。 设计代码，使用枚举数据类型，在O(n)的时间复杂度下找到对应标签的传送地点，并通过GameManager的单例方法删除原场景中的人物，并使用单例方法在新场景中通过玩家预制体（Prefab）生成玩家（Player） 通过URP Shader制作传送门特效，为传送门挂载脚本，将传送门保存为预制体（Prefab），在所有场景中摆放传送门并设置传送门自身标签与传送目的标签。 人物属性数据设计与存储系统对人物设计了最大血量，当前血量，最大子弹，当前子弹4种私有数据存储于数据类中。 通过另一个接口类的公有方法对其他类暴露，并通过C#语法糖为变量设置了getter setter。 游戏操作界面UI设计通过对人物模型附着子物体摄像机，将摄像机画面输出到渲染管线纹理（RenderPipeline Texture），将渲染管线纹理输出到材质球（Material），将材质球输出到UI的image对象中，调整UI中image对象的位置，实现了实时头像的显示。 通过一张图片作为底色，控制一张图片的长度实现血量条和子弹条。 开发计划完成游戏整体设计对按照现有整体游戏控制框架，进一步完善游戏内容： 设计游戏主界面UI，并编写代码完成UI系统 设计游戏总流程的状态机，编写代码控制对话系统。 设计敌人的行为树，并编写代码与完善模型与动画资源，完成敌人系统。 设计数据存储结构，完成数据存档系统。 完成编写实现风格化渲染的Unity Shader对至少完成对人物模型的Unity Shader编写，实现二维卡通渲染效果，凸出表现阴影和高光部分。","categories":[{"name":"杂项","slug":"杂项","permalink":"https://shiokiri.com/categories/杂项/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://shiokiri.com/tags/Unity/"},{"name":"Blender","slug":"Blender","permalink":"https://shiokiri.com/tags/Blender/"},{"name":"C#","slug":"C","permalink":"https://shiokiri.com/tags/C/"},{"name":"VRoid Studio","slug":"VRoid-Studio","permalink":"https://shiokiri.com/tags/VRoid-Studio/"}]},{"title":"「计算几何」","slug":"2022-04-01-computational-geometry","date":"2022-04-01T12:43:25.000Z","updated":"2022-04-01T12:50:13.925Z","comments":true,"path":"2022-04-01-computational-geometry/","link":"","permalink":"https://shiokiri.com/2022-04-01-computational-geometry/","excerpt":"更新于：A.D.2022.04.01","text":"更新于：A.D.2022.04.01 参考资料 1.授课PDF 2.OI-Wiki 几何定理欧拉公式对于一个平面图$G=\\left \\langle V,E,C,F \\right \\rangle$，有$|V|$个顶点，$|E|$条连边，$|C|$个（弱）连通分量，$|F|$个区域（包含无限域），则 |F|+|V|-|E|=|C|+1皮克公式对于一个定点都位于格点上的多边形，设其面积为$S$，多边形非边界内部的点数为$a$，多边形边界上的点数为$b$，则 2S=2a+b-2二维几何向量类（V vector）class V { protected: double x, y; public: V() { x = y = 0; } V(double _x, double _y) : x(_x), y(_y) {} //... }; 点类（P point）class P : public V { protected: int i; public: P() { x = y = 0; } P(double _x, double _y, int _i = -1): V(_x, _y), i(_i) {} //... }; 线段类（S segment） class S { protected: P u, v; public: S() {} S(P _u, P _v) : u(_u), v(_v) {} //... }; 直线类（L line）class L : public S { protected: public: L() {} L(P _u, P _v) : S(_u, _v) {} //... }; 圆类（C circle）class C { protected: P o; double r; public: C() {} C(P _o, double _r) : o(_o), r(_r) {} //... }; 凸包类（CH convex_hull）凸包是对于给定点集而言的，凸包是包含给定点集的最小凸多边形的边界点的集合。 一个多边形是凸的，当且仅当其内部任意两点的连线都被该多边形所包含。 class CH { //逆时针方向给出点 protected: int n; P* p; public: CH() : n(0), p(NULL) {} CH(int _n) : n(0) { p = (P*)calloc(_n, sizeof(P)); } //... }; 常用函数符号函数与比实数大小const double eps = 1e-8; int sgn(double a) { return a &lt; -eps ? -1 : a &gt; eps; } int cmp(double a, double b) { return sgn(a - b); } 平方函数double sqr(double x) { return x * x; } 向量的加减乘除V operator + (const V&amp; o) const { return V(x + o.x, y + o.y); } V operator - (const V&amp; o) const { return V(x - o.x, y - o.y); } V operator * (double k) const { return V(x * k, y * k); } V operator / (double k) const { return V(x / k, y / k); } 取出向量的某一分量double operator [](int i) const { return i == 0 ? x : y; } 向量的模与辐角 整型绝对值: abs(x) \\\\ 浮点型绝对值: fabs(x) \\\\ atan2(y,x)=\\arctan(\\frac{y}{x})double norm2() const { return sqr(x) + sqr(y); } //模长的平方 double norm() const { return sqrt(norm2()); } //模长 double arg() const { return atan2(y, x); } //辐角 向量的单位方向向量V operator ~() const { return *this / norm(); } 两向量的点乘和叉乘friend double dot(const V&amp; a, const V&amp; b) { return a.x * b.x + a.y * b.y; } friend double det(Const V&amp; a, const V&amp; b) { return a.x * b.y - b.x * a.y; } 两向量的距离与夹角 \\mathbf{a}\\cdot \\mathbf{b}=|\\mathbf{a}||\\mathbf{b}| \\cos\\left \\langle \\mathbf{a},\\mathbf{b} \\right \\rangle \\\\ \\mathbf{a}\\times \\mathbf{b}=|\\mathbf{a}||\\mathbf{b}|\\sin\\left \\langle \\mathbf{a},\\mathbf{b} \\right \\rangle \\\\ atan2(\\mathbf{a}\\times \\mathbf{b},\\mathbf{a}\\cdot \\mathbf{b})=atan2(\\frac{\\mathbf{a}\\times \\mathbf{b}}{\\mathbf{a}\\cdot \\mathbf{b}})=atan2(\\tan\\left \\langle \\mathbf{a},\\mathbf{b} \\right \\rangle)=\\left \\langle \\mathbf{a},\\mathbf{b} \\right \\rangle \\\\friend double dis(const V&amp; a, const V&amp; b) { return (a - b).norm(); } friend double irad(const V&amp; a, const V&amp; b) { return atan2(det(a, b), dot(a, b)); } 旋转某向量（逆时针） \\mathbf{V} = \\begin{bmatrix} x \\\\ y \\end{bmatrix} \\\\ 旋转矩阵(向逆时针方向转\\alpha\\ rad)\\ \\mathbf{T} = \\begin{bmatrix} \\cos(\\alpha) & -\\sin(\\alpha) \\\\ \\sin(\\alpha) & \\cos(\\alpha) \\end{bmatrix} \\\\ \\mathbf{\\hat{V}}=\\mathbf{T}\\mathbf{V}V rot(double a) { return V(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a)); } 某向量的垂直向量（逆时针）V perp() const { return V(-y, x); } 两点间的位移向量V operator - (const P&amp; o) const { return V(x - o.x, y - o.y); } 点的位移P operator + (const V&amp; o) const { return P(x + o[0], y + o[1]); } 点的微小扰动void shake(double e = eps) { srand(time(0)); x += (rand() / (double)RAND_MAX - 0.5) * e; y += (rand() / (double)RAND_MAX - 0.5) * e; } 点到直线距离 P(x,y) \\quad l:uv\\\\ S=\\frac{1}{2}|uv|\\cdot d=\\frac{1}{2}|(u-p)\\times(v-p)| \\\\ d=\\frac{|(u-p)\\times(v-p)|}{|uv|}friend double dis(const L&amp; l, const P&amp; p) { return fabs(det(p - l[0], l[1] - l[0]) / l.len()); } 线段上定比分点friend P defpoint(const L&amp; l, double k) { return l[0] + l.dir() * k; } 点关于直线的投影点friend P proj(const L&amp; l, const P&amp; p) { return l[0] + ~l.dir() * dot(p - l[0], l[1] - l[0]) / l.len(); } 其他跨立实验判断两线段是否相交射线法判断点是否在多边形内部经典问题及算法二维凸包平面最远点对平面最近点对圆反演三维凸包进阶内容几何（计算机图形学）仿射变换射影几何算法自适应辛普森积分最左转线法三角剖分问题最小圆覆盖圆的面积并半平面交平面图转对偶图 &amp; 点定位题目圈奶牛Fencing the Cows /【模板】二维凸包简单实验了一下封装方法和C++11 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;iomanip&gt; #include &lt;cstdlib&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;ctime&gt; using std::cin; using std::cout; using std::endl; using std::swap; using std::sort; const double eps = 1e-8; int sgn(double a) { return a &lt; -eps ? -1 : a &gt; eps; } int cmp(double a, double b) { return sgn(a - b); } double sqr(double x) { return x * x; } class V { protected: double x, y; public: V() { x = y = 0; } V(double _x, double _y) : x(_x), y(_y) {} //... V operator + (const V&amp; o) const { return V(x + o.x, y + o.y); } V operator - (const V&amp; o) const { return V(x - o.x, y - o.y); } V operator * (double k) const { return V(x * k, y * k); } V operator / (double k) const { return V(x / k, y / k); } double operator [](int i) const { return i == 0 ? x : y; } double norm2() const { return sqr(x) + sqr(y); } double norm() const { return sqrt(norm2()); } double arg() const { return atan2(y, x); } V operator ~() const { return *this / norm(); } friend double dot(const V&amp; a, const V&amp; b) { return a.x * b.x + a.y * b.y; } friend double det(const V&amp; a, const V&amp; b) { return a.x * b.y - b.x * a.y; } friend double dis(const V&amp; a, const V&amp; b) { return (a - b).norm(); } friend double irad(const V&amp; a, const V&amp; b) { return atan2(det(a, b), dot(a, b)); } V rot(double a) { return V(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a)); } V perp() const { return V(-y, x); } }; class P : public V { protected: int i; public: P() { x = y = 0; } P(double _x, double _y, int _i = -1): V(_x, _y), i(_i) {} //... V operator - (const P&amp; o) const { return V(x - o.x, y - o.y); } P operator + (const V&amp; o) const { return P(x + o[0], y + o[1]); } bool operator &lt; (const P&amp; p) const { if(cmp(this-&gt;x, p.x) == 0) return cmp(this-&gt;y, p.y) == -1; else return cmp(this-&gt;x, p.x) == -1; } void shake(double e = eps) { srand(time(0)); x += (rand() / (double)RAND_MAX - 0.5) * e; y += (rand() / (double)RAND_MAX - 0.5) * e; } }; class S { protected: P u, v; public: S() {} S(P _u, P _v) : u(_u), v(_v) {} double len() const { return dis(u, v); } V dir() const { return u - v; } //... P operator [](int i) const { return i == 0 ? u : v; } }; class L : public S { protected: public: L() {} L(P _u, P _v) : S(_u, _v) {} //... friend double dist(const L&amp; l, const P&amp; p) { return fabs(det(p - l[0], l[1] - l[0]) / l.len()); } friend P defpoint(const L&amp; l, double k) { return l[0] + l.dir() * k; } friend P proj(const L&amp; l, const P&amp; p) { return l[0] + ~l.dir() * dot(p - l[0], l[1] - l[0]) / l.len(); } }; class C { protected: P o; double r; public: C() {} C(P _o, double _r) : o(_o), r(_r) {} //... }; class CH { protected: int n; P* p; public: CH() : n(0), p(NULL) {} CH(int _n) : n(0) { p = (P*)calloc(_n, sizeof(P)); } //... P operator [](int i) const { return p[i]; } void push_back(const P&amp; _p) { p[n++] = _p; } void pop_back() { n--; } int size() { return n; } double sumPointDist() { double sum = dis(p[n-1], p[0]); for(int i = 1; i &lt; n; i++) sum += dis(p[i], p[i-1]); return sum; } }; CH graham(int n, P p[]) { int b = 0; for(int i = 1; i &lt; n; i++) { if(p[i] &lt; p[b]) { b = i; } } swap(p[0], p[b]); sort(p + 1, p + n, [&amp;p](const P&amp; u, const P&amp; v) { return sgn(det(u - *p, v - *p)) &gt; 0 || (sgn(det(u - *p, v - *p)) == 0 &amp;&amp; sgn(dis(u, *p) - dis(v, *p)) &lt; 0); }); CH ch(n); ch.push_back(p[0]), ch.push_back(p[1]); for(int i = 2; i &lt; n; i++) { int ls = ch.size() - 1; while(ls &gt; 0 &amp;&amp; sgn(det(p[i] - ch[ls - 1], ch[ls] - ch[ls - 1])) &gt;= 0) { ch.pop_back(), --ls; } ch.push_back(p[i]); } return ch; } int main() { int n; cin &gt;&gt; n; P* p = new P[n]; for(int i = 0; i &lt; n; i++) { double x, y; cin &gt;&gt; x &gt;&gt; y; p[i] = P(x, y, i); } CH ch = graham(n, p); cout &lt;&lt; std::setiosflags(std::ios::fixed); cout &lt;&lt; std::setprecision(2) &lt;&lt; ch.sumPointDist() &lt;&lt; endl; return 0; } Beauty Contest G /【模板】旋转卡壳","categories":[{"name":"数学","slug":"数学","permalink":"https://shiokiri.com/categories/数学/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://shiokiri.com/tags/计算几何/"},{"name":"C++11","slug":"C-11","permalink":"https://shiokiri.com/tags/C-11/"}]},{"title":"VRoid Studio->Blender->Unity制作人物模型","slug":"2022-04-01-vroid-studio","date":"2022-04-01T07:04:25.000Z","updated":"2022-04-01T13:39:37.318Z","comments":true,"path":"2022-04-01-vroid-studio/","link":"","permalink":"https://shiokiri.com/2022-04-01-vroid-studio/","excerpt":"更新于：A.D.2022.04.01","text":"更新于：A.D.2022.04.01 VRoid Studio下载与安装插件首先在Steam下载，然后安装以下两个插件 【汉化】VRoidStudio正式版 中文汉化 【插件】VRoid Studio 扩展插件 VRoidXYTool v0.3 导出VRM文件导出时适当降低多边形面数 Blender安装Blender通过Steam下载 转换VRM文件为FBX文件删除以下三个物体 从此处导入VRM模型 安装插件 cats-blender-plugin 选安装，再选择插件的zip文件，最后勾选图中的3D View: Cats Blender Plugin 按1 2 3的顺序点击（保证不选Combine Same Materials） 按照1 2的顺序点击 保持默认属性导出FBX文件 最终生成一个FBX文件，一个贴图文件夹 Unity寻找动画素材在该网站上寻找到合适的动画素材后，将FBX文件上传至网站，并通过调整网站提供的参数，使得动作符合模型，避免穿模、错位情况出现，下载动画文件时选择FBX for Unity格式 mixamo.com 导入Unity将FBX文件和贴图文件夹同时导入Unity Assets中 更改模型Rig-Animation Type为Humanoid（人形），Rig-Avatar Definition为Create From This Model 未编写Shader时使用临时Shader保证显示正常（从一个Unity的vrm插件中获取） 导入时自动生成材质球（Matertial），为材质球选择Shader即可 Shader &quot;UniGLTF/UniUnlit&quot; { Properties { _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {} _Color (&quot;Main Color&quot;, COLOR) = (1,1,1,1) _Cutoff (&quot;Alpha Cutoff&quot;, Range(0, 1)) = 0.5 [HideInInspector] _BlendMode (&quot;_BlendMode&quot;, Float) = 0.0 [HideInInspector] _CullMode (&quot;_CullMode&quot;, Float) = 2.0 [HideInInspector] _VColBlendMode (&quot;_VColBlendMode&quot;, Float) = 0.0 [HideInInspector] _SrcBlend (&quot;_SrcBlend&quot;, Float) = 1.0 [HideInInspector] _DstBlend (&quot;_DstBlend&quot;, Float) = 0.0 [HideInInspector] _ZWrite (&quot;_ZWrite&quot;, Float) = 1.0 // VertexColor } SubShader { Tags { &quot;RenderType&quot;=&quot;Opaque&quot; } LOD 100 Pass { Cull [_CullMode] Blend [_SrcBlend] [_DstBlend] ZWrite [_ZWrite] ZTest LEqual BlendOp Add, Max CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile_fog #pragma multi_compile _ _ALPHATEST_ON _ALPHABLEND_ON #pragma multi_compile _ _VERTEXCOL_MUL #include &quot;UnityCG.cginc&quot; struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; #if defined(_VERTEXCOL_MUL) fixed4 color : COLOR; #endif UNITY_VERTEX_INPUT_INSTANCE_ID }; struct v2f { float4 vertex : SV_POSITION; float2 uv : TEXCOORD0; UNITY_FOG_COORDS(1) #if defined(_VERTEXCOL_MUL) fixed4 color : COLOR; #endif UNITY_VERTEX_OUTPUT_STEREO }; sampler2D _MainTex; float4 _MainTex_ST; half4 _Color; half _Cutoff; v2f vert (appdata v) { v2f o; UNITY_SETUP_INSTANCE_ID(v); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o); o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); UNITY_TRANSFER_FOG(o,o.vertex); #if defined(_VERTEXCOL_MUL) o.color = v.color; #endif return o; } fixed4 frag (v2f i) : SV_Target { fixed4 col = tex2D(_MainTex, i.uv) * _Color; #if defined(_VERTEXCOL_MUL) col *= i.color; #endif #if defined(_ALPHATEST_ON) clip(col.a - _Cutoff); #endif #if !defined(_ALPHATEST_ON) &amp;&amp; !defined(_ALPHABLEND_ON) col.a = 1.0; #endif UNITY_APPLY_FOG(i.fogCoord, col); return col; } ENDCG } } Fallback &quot;Unlit/Texture&quot; }","categories":[{"name":"技术","slug":"技术","permalink":"https://shiokiri.com/categories/技术/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://shiokiri.com/tags/Unity/"},{"name":"Blender","slug":"Blender","permalink":"https://shiokiri.com/tags/Blender/"},{"name":"VRoid Studio","slug":"VRoid-Studio","permalink":"https://shiokiri.com/tags/VRoid-Studio/"}]},{"title":"使用Gmail进行域名邮箱邮件收发","slug":"2022-02-12-domain-mail","date":"2022-02-12T15:48:00.000Z","updated":"2025-03-21T00:51:09.471Z","comments":true,"path":"2022-02-12-domain-mail/","link":"","permalink":"https://shiokiri.com/2022-02-12-domain-mail/","excerpt":"更新于：A.D.2025.03.21","text":"更新于：A.D.2025.03.21 以下内容作废，推荐使用Zoho。 准备1.域名 2.Gmail账号 收取根据域名服务商不同，设置也有所不同，我是使用的是Namesilo 设置域名服务商DNS检查DNS设置中是否有MX配置 若没有，从下方选项中添加Email Forwarding默认配置（点击红色区域按钮） 设置域名服务商邮件转发填写域名邮箱地址 填写转发到邮箱地址 发送获取Google应用专用密码https://myaccount.google.com/security 1.打开 两步验证 2.点击 应用专用密码 3.填写 选择应用-邮件 选择设备-其他（自定义名称） 4.填写 域名邮箱地址（方便分辨） 5.获得16位应用专用密码，保存密码后续使用 设置Gmail邮箱SMTP服务点击 用这个地址发送邮件：添加其他电子邮件地址 填写Gmail中邮件地址的显示名称与域名邮箱地址，点击下一步 SMTP服务器 填写 smtp.gmail.com 用户名 填写 去除@gmail.com的gmail邮件地址 密码 填写 前文保存的应用专用密码 端口选择587 选择使用TLS的安全连接 点击添加账号，从Gmail中收取确认邮件并点击确认链接 最后，可以选择是否作为默认发信地址，选择回复邮件时的方式，设置选项在 用这个地址发送邮件 中 测试测试收取邮件使用域名邮箱和Gmail邮箱外的一个邮箱 1.向域名邮箱发送一封邮件，并测试是否发送成功及送达速度 2.使用Gmail收取邮件后，检查收件人，邮送域，署域，安全性是否正确 测试发送邮件使用Gmail发送一封邮件到其他邮箱 1.测试是否发送成功及送达速度 2.检查是否为域名邮箱并显示从Gmail邮箱代发","categories":[{"name":"技术","slug":"技术","permalink":"https://shiokiri.com/categories/技术/"}],"tags":[{"name":"域名邮箱","slug":"域名邮箱","permalink":"https://shiokiri.com/tags/域名邮箱/"},{"name":"Gmail","slug":"Gmail","permalink":"https://shiokiri.com/tags/Gmail/"}]},{"title":"后端开发学习","slug":"2022-01-30-backend","date":"2022-01-29T20:24:25.000Z","updated":"2022-04-01T12:53:08.925Z","comments":true,"path":"2022-01-30-backend/","link":"","permalink":"https://shiokiri.com/2022-01-30-backend/","excerpt":"更新于：A.D.2022.03.31","text":"更新于：A.D.2022.03.31 Java主要学习SpringBoot、Shiro、MySql、JPA、AOP面向切面编程、IOC架构、设计模式等 环境配置1.安装IntelliJ IDEA 2021.2.3，用于Java开发 2.安装Navicat Premium 15，用于图形化查看MySQL数据 3.安装MySQL Workbench，用于数据库管理 4.安装Postman，用于接口测试 5.配置MySQL，用于数据库环境 6.配置Maven，用于项目管理 Maven XML配置pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;&lt;/name&gt; &lt;description&gt;&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 在dependencies中添加依赖项 数据库配置src/…/resources/application.yml server: port: 8080 spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/DataBaseName username: root password: password jpa: hibernate: ddl-auto: update show-sql: true properties: hibernate: jpa:hibernate:ddl-auto create： 每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop ： 每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 update： 最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。 validate ： 每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 常用注解@SpringBootApplication @Entity @Id @GeneratedValue @Column @PathVariable @RequestParam @___Mapping @RestController @Getter @Setter HTTP协议请求类型GET PUT POST DELETE JPA关系映射@OneToOne @OneToMany @ManyToOne @ManyToMany Jpa接口extends JpaRepository Shiro框架Golang环境配置1.配置Golang编译器，环境变量与VSCode开发环境，用于学习语法 2.安装GoLand 2021.2.2，用于Golang开发 3.配置Gin框架环境 Hello wolrdpackage main import &quot;github.com/gin-gonic/gin&quot; func main() { r := gin.Default() r.GET(&quot;/&quot;, func(c *gin.Context) { c.String(200, &quot;Hello world!&quot;) }) r.Run() }","categories":[{"name":"编程","slug":"编程","permalink":"https://shiokiri.com/categories/编程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://shiokiri.com/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"https://shiokiri.com/tags/MySQL/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://shiokiri.com/tags/SpringBoot/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://shiokiri.com/tags/SpringMVC/"},{"name":"Golang","slug":"Golang","permalink":"https://shiokiri.com/tags/Golang/"}]},{"title":"电子产品评测","slug":"2022-01-30-electronics","date":"2022-01-29T20:23:12.000Z","updated":"2022-06-23T18:28:23.019Z","comments":true,"path":"2022-01-30-electronics/","link":"","permalink":"https://shiokiri.com/2022-01-30-electronics/","excerpt":"更新于：A.D.2022.3.19","text":"更新于：A.D.2022.3.19 这里简单评测一些我用过的电子设备 台式机2017年购买，i5-7500+GTX1050Ti的配置，8GB内存 256GB SSD，3TB HDD，ASUS刻录机 屏幕是飞利浦1080P 60hz的一款曲面屏 用了五年多了，上一台电脑是2006年的（，有了这台电脑才开始能玩游戏…… 笔记本机械革命 Umi Pro 32021年购买，i7-11800H+RTX3060的配置，16GB内存 512GB SSD，加装了1TB的西部数据sn550（更换缓外前的版本） 优点：2021年暑假有货，同配置最轻薄模具，液金散热到位，满血RTX3060，屏幕色域色准2k165hz 缺点：内部做工略显粗糙，满载噪音极大（可以人工调整风扇转速），16:9屏幕，双显卡续航1.5~2h 耳机铁三角 ATH-CLR1002018年购买，比起30元左右的耳机，清晰度有所改善，低音音量大小有所改善，不会过吵。 耳机线特别细，比较容易坏。 绿色配色比较好看。 飞利浦 SHP95002021年购买，耳机解析度比较清晰，能很好地分辨出一些细微的声音。分层较好，能明显听出多种乐器声的分层。声场不是太好，不太能听出来乐器位置。 大单元动圈开放式耳机，声音比较通透。人声比较明亮，高音突出，低音较弱。 不夹头，材质偏向塑料，手感比较硬，不是太好。 AirPods 22021年获得，苹果附赠的产品，总体来说外形很不错，比较圆润，音质中规中矩。 如果没有苹果设备，实际上连接体验并不是太好。 SONY WH1000-XM42022年购买，降噪效果比较好，可以隔绝大部分低频噪音，稍稍降低人声。 4代比起3代来说不夹头，受力要小一些。 智能免摘功能很好用，主动说话时就会切换到收音状态 平板iPad Pro 20212021年购买，玩原神用的，顺带看点epub电子书，批注pdf扫描版纸质书 还能看知乎，B站，记手写笔记和3d扫描…… Apple Pencil2021年购买，记笔记还是能用用的，画画不如数位板舒服 手机小米11 Pro2021年购买，人生第二个手机或许是因为我一直喜欢小米 屏幕很好2k 120hz 100%P3 比较喜欢GN2摄像头这样就能夜视了 UFS3.1存储明显快了太多太多，apk安装速度提升极其明显 骁龙888实在是不好，日常使用温感明显常常过热，原神全高掉帧明显 曲面屏我不是太喜欢，比较喜欢iPhone那种有棱角的造型 红米 Note52018年购买，人生第一个手机，在当时那个价位全面屏屏幕真的很漂亮 使用了3年时间，期间加装了128GB闪存卡，后期日常使用也完全不卡，但是64GB存储不太够用 骁龙636陪我玩了刺激战场等等游戏，最后陪我玩了半年原神相当卡 因为过度使用，电池损耗量很大，存储读写速度明显下降 鼠标罗技G5022021年购买，无极滚轮很好用，功能很全面，重量稍重 罗技G3042021年购买，握感很好，无线连接延迟也很小，耗电量不大，电池半年一换，重要主要在电池上 数位板Wacom CTL6722020年购买，总体来说使用体验比iPad好很多，能感受到比较细微的压感，适合作为入门级别产品使用 键盘iKBC C104 白色 青轴2018年购买，第一次体验机械键盘，当时买的时候还比较早，机械键盘才刚刚比较流行。 键盘104键，有线，轴是Cherry的青轴，很有段落感，咔哒咔哒的感觉。键帽是PBT键帽，确实不会打油。后来被我换了几十一套的淘宝蓝色渐变键帽。 iKBC W200 绿色 红轴2021年购买，2.4G无线版本的iKBC键盘，有一个小接收器，配套笔记本使用的，87键，Cherry红轴。整体使用来说轴体触发位置比较靠上，力度较轻，不用摁到底，比较适合长时间写作、敲代码。 入门价位还是比较推荐的，做工没有太大的问题。 VROculus Quest 2真正感受元宇宙的最便宜解决方案 2021年购买，Facebook的产品，购买的话最好从美国亚马逊购买，第一次开机折腾起来相当费劲，最好有比较新可以刷固件的路由器，会节省很多麻烦，否则可能需要笔记本的虚拟网卡开热点，和能代理到网络层的方法，不可以用socks5这种代理到会话层的协议。 内向外四摄像头 + 物理运动定位，定位很准确，绝对不会丢定位，这点比Pico Neo 3好太多。 屏幕4k120hz，实际使用中难以避免纱窗效应，比显示器画质差太多，但有时纱窗效应不是很明显，刷新率很好，不会因为刷新率而感到眩晕。 观看了Youtube全景视频 使用《SKYBOX》通过局域网传输，模拟了电影院播放电影，重温《HELLO WORLD》。 通过SideQuest安装破解版，体验了一体机的节奏光剑《Beat Saber》，燥热《SUPERHOT》，滑翔伞模拟《RUSH》、真实乒乓球《Eleven Table Tennis》、攀岩2《The Climb 2》 使用SteamVR，通过WIFI串流，体验了《Half-Life Alyx》、《The Lab》、《VRChat》 插图1 - VRChat - 在中文吧自拍 家居用品米家台灯2017年购买，台灯是最早的版本，很漂亮，比较喜欢这种简洁的设计，小红线很和谐 光线可以接受，可以连接局域网，使用米家app控制台灯 小米80W无线充电2022年购买，接入67W的充电器可以实现对小米11 Pro功率50W的充电 外形很漂亮，很有设计感，适合作为桌面摆件 穿戴设备小米手环32018年购买，黑白界面，可以计步数，检测睡眠等一些小功能 小米手环42019年购买，彩色界面还挺好看的，换了一些彩色的腕带，主要还是用于看时间，睡眠情况的 游戏机Nintendo Switch OLED2022年购买，OLED屏幕比较大，色彩也还可以，频闪对于我来说没有太大的影响 首先玩了期待已久的《十三机兵防卫圈》，很喜欢 糖豆人也免费了，当然，还可以玩Apex 插图2 - 十三机兵防卫圈 - 冬坂五百里","categories":[{"name":"杂项","slug":"杂项","permalink":"https://shiokiri.com/categories/杂项/"}],"tags":[{"name":"评测","slug":"评测","permalink":"https://shiokiri.com/tags/评测/"},{"name":"电子产品","slug":"电子产品","permalink":"https://shiokiri.com/tags/电子产品/"}]},{"title":"Python网络爬虫学习","slug":"2022-01-12-python-web-crawler","date":"2022-01-11T17:01:20.000Z","updated":"2022-03-30T15:00:48.714Z","comments":true,"path":"2022-01-12-python-web-crawler/","link":"","permalink":"https://shiokiri.com/2022-01-12-python-web-crawler/","excerpt":"更新于：A.D.2022.2.13","text":"更新于：A.D.2022.2.13 按模块学习urllib库json库按功能学习下载HTML源代码from urllib.request import urlopen import sys html = urlopen( &quot;url&quot; ).read().decode(&#39;utf-8&#39;) if sys.getdefaultencoding() == &#39;ascii&#39;: sys.stdout = open(&quot;2.输出html.html&quot;, &quot;w&quot;, encoding = &#39;gb2312&#39;) else: sys.stdout = open(&quot;2.输出html.html&quot;, &quot;w&quot;, encoding = &#39;utf-8&#39;) print(html) 下载网页图片from urllib.request import urlopen import urllib.parse import sys import re import os def getHtml(url): html = urlopen(url).read().decode(&#39;utf-8&#39;) return html def printImg(imgList, url): for i in imgList: imgName = i.split(&quot;/&quot;)[-1] imgPicture = urlopen(url + i) File = open(&#39;\\\\image\\\\&#39; + imgName, &#39;wb&#39;) File.write(imgPicture.read()) File.close() def downloadImg(url): html = getHtml(url) rule_1 = r&#39;&lt;img src=&quot;([^&quot;]+\\.png)&quot;&#39; rule_2 = r&#39;&lt;img src=&quot;([^&quot;]+\\.jpg)&quot;&#39; imgList_1 = re.findall(rule_1, html) printImg(imgList_1, url) imgList_2 = re.findall(rule_2, html) printImg(imgList_2, url) if __name__ == &#39;__main__&#39;: url = &quot;url&quot; downloadImg(url) 下载通知from urllib.request import urlopen import sys import re def getHtml(url): html = urlopen(url).read().decode(&#39;utf-8&#39;) return html def printList(list_1, list_2, list_3): if sys.getdefaultencoding() == &#39;ascii&#39;: sys.stdout = open(&quot;4.爬取通知.txt&quot;, &quot;w&quot;, encoding = &#39;gb2312&#39;) else: sys.stdout = open(&quot;4.爬取通知.txt&quot;, &quot;w&quot;, encoding = &#39;utf-8&#39;) for i in range(0, len(list_1)): print(&#39;#%d&#39; % (i+1)) print(&#39;标题：&#39; + list_2[i]) print(&#39;日期：&#39; + list_3[i]) print(&#39;网址：&#39; + &#39;url&#39; + list_1[i]) print(&#39;&#39;) def download(url): html = getHtml(url) rule_1 = r&#39;&lt;a target=&quot;_blank&quot; href=&quot;([^&quot;]+\\.htm)&quot;&gt;&#39; List_1 = re.findall(rule_1, html) rule_2 = r&#39;&lt;a target=&quot;_blank&quot; href=.*?&gt;(.*?)&lt;/a&gt;&#39; List_2 = re.findall(rule_2, html) rule_3 = r&#39;&lt;font color=&quot;#3a6399&quot;&gt;&amp;nbsp;&amp;nbsp;(.*?)&lt;/font&gt;&#39; List_3 = re.findall(rule_3, html) printList(List_1, List_2, List_3) if __name__ == &#39;__main__&#39;: url = &quot;url&quot; download(url) 下载任意页数通知from urllib.request import urlopen import sys import re def getHtml(url): html = urlopen(url).read().decode(&#39;utf-8&#39;) return html def printList(list_1, list_2, list_3): if sys.getdefaultencoding() == &#39;ascii&#39;: sys.stdout = open(&quot;5.爬取任意页数通知.txt&quot;, &quot;w&quot;, encoding = &#39;gb2312&#39;) else: sys.stdout = open(&quot;5.爬取任意页数通知.txt&quot;, &quot;w&quot;, encoding = &#39;utf-8&#39;) print(&#39;通知页数：第&#39; + pageNumber + &#39;页&#39;) print(&#39;&#39;) for i in range(0, len(list_1)): print(&#39;#%d&#39; % (i+1)) print(&#39;标题：&#39; + list_2[i]) print(&#39;日期：&#39; + list_3[i]) print(&#39;网址：&#39; + &#39;url&#39; + list_1[i]) print(&#39;&#39;) def download(url): html = getHtml(url) rule_1 = r&#39;&lt;a target=&quot;_blank&quot; href=&quot;([^&quot;]+\\.htm)&quot;&gt;&#39; List_1 = re.findall(rule_1, html) rule_2 = r&#39;&lt;a target=&quot;_blank&quot; href=.*?&gt;(.*?)&lt;/a&gt;&#39; List_2 = re.findall(rule_2, html) rule_3 = r&#39;&lt;font color=&quot;#3a6399&quot;&gt;&amp;nbsp;&amp;nbsp;(.*?)&lt;/font&gt;&#39; List_3 = re.findall(rule_3, html) printList(List_1, List_2, List_3) if __name__ == &#39;__main__&#39;: print(&#39;请输入需要爬取的通知页数：&#39;) pageNumber = input() url = &quot;url&quot; + pageNumber + &quot;.html&quot; download(url) Bilibili-Favorites-Download用于下载B站个人收藏夹信息 https://github.com/ShioKiri/Bilibili-Favorites-Download 因为调用一个外部网站API查询了失效视频且没有处理失败情况，目前因为API有一定问题，不能稳定运行，可以自行删去处理失效视频的代码使用 没有使用数据库和图形界面，直接保存为TXT或者CSV文件 生成TXT文件按照一定格式保存为TXT，推荐使用编辑器打开TXT避免速度过慢 from urllib.request import urlopen import json import re import time import sys import logging # -*- coding: UTF-8 -*- bilibili_uid = 0 aFavVideoCnt = 0 totVideoCnt = 0 totVideoNum = 0 def initUid(): global bilibili_uid bilibili_uid = int(input()) def getJsonUrl(url): Data = urlopen(url).read().decode(&#39;utf-8&#39;) jsonData = json.loads(Data) return jsonData def getFavoriteList(uid): global totVideoNum favoriteListUrl = &#39;https://api.bilibili.com/medialist/gateway/base/created?pn=1&amp;ps=100&amp;up_mid={uid}&amp;is_space=0&amp;jsonp=jsonp&#39;.format(uid=uid) favoriteListData = getJsonUrl(favoriteListUrl) listInfo = favoriteListData[&#39;data&#39;][&#39;list&#39;] favNum = len(listInfo) for i in range(0, favNum): totVideoNum += listInfo[i][&#39;media_count&#39;] for i in range(0, favNum): print(&#39;收藏夹编号:#%d 名称:%s 视频数量:%d\\n&#39; % (i+1, listInfo[i][&#39;title&#39;], listInfo[i][&#39;media_count&#39;])) getFavListVideo(uid, listInfo[i][&#39;fid&#39;]) def getFavListVideo(uid, fid): global aFavVideoCnt, totVideoCnt, totVideoNum aFavVideoCnt = 0 favPageUrl = &#39;https://api.bilibili.com/x/space/fav/arc?vmid={uid}&amp;ps=30&amp;fid={fid}&amp;tid=0&amp;keyword=&amp;pn={page}&amp;order=fav_time&amp;jsonp=jsonp&#39;.format(uid=uid,fid=fid,page=1) favPageDate = getJsonUrl(favPageUrl) printVideoInfo(favPageDate[&#39;data&#39;][&#39;archives&#39;]) pageCount = favPageDate[&#39;data&#39;][&#39;pagecount&#39;] for i in range(2, pageCount+1): favPageUrl = &#39;https://api.bilibili.com/x/space/fav/arc?vmid={uid}&amp;ps=30&amp;fid={fid}&amp;tid=0&amp;keyword=&amp;pn={page}&amp;order=fav_time&amp;jsonp=jsonp&#39;.format(uid=uid,fid=fid,page=i) favPageDate = getJsonUrl(favPageUrl) printVideoInfo(favPageDate[&#39;data&#39;][&#39;archives&#39;]) def printInfo(Info): print(&#39;投稿时间:&#39; + time.strftime(&quot;%Y-%m-%d-%H:%M:%S&quot;, time.gmtime(Info[&#39;pubdate&#39;]))) print(&#39;描述:%s&#39; % (Info[&#39;desc&#39;])) print(&#39;分区:%s&#39; % (Info[&#39;tname&#39;])) print(&#39;标签:%s&#39; % (Info[&#39;dynamic&#39;])) print(&#39;up主用户名:%s up主uid:%s&#39; % (Info[&#39;owner&#39;][&#39;name&#39;], Info[&#39;owner&#39;][&#39;mid&#39;])) print(&#39;播放:%s 弹幕:%s 回复:%s 收藏:%s 硬币:%s 分享:%s 喜欢:%s&#39; % (Info[&#39;stat&#39;][&#39;view&#39;], Info[&#39;stat&#39;][&#39;danmaku&#39;], Info[&#39;stat&#39;][&#39;reply&#39;], Info[&#39;stat&#39;][&#39;favorite&#39;], Info[&#39;stat&#39;][&#39;coin&#39;], Info[&#39;stat&#39;][&#39;share&#39;], Info[&#39;stat&#39;][&#39;like&#39;],)) print(&#39;收藏时间:&#39; + time.strftime(&quot;%Y-%m-%d-%H:%M:%S&quot;, time.gmtime(Info[&#39;fav_at&#39;]))) print() def printVideoInfo(aPageInfo): global aFavVideoCnt, totVideoCnt, totVideoNum for i in range(0, len(aPageInfo)): aFavVideoCnt += 1 totVideoCnt += 1 if totVideoCnt % 10 == 0 or totVideoCnt == totVideoNum: logging.info(&#39;已经完成了{num1}/{num2}个视频...&#39;.format(num1 = totVideoCnt,num2 = totVideoNum)) Info = aPageInfo[i] video_id = Info[&#39;aid&#39;] if Info[&#39;title&#39;] == &#39;已失效视频&#39;: getInvalidVideoInfo(video_id, Info) else: print(&#39;视频编号:#%d AV号:%d 视频标题:%s&#39; % (aFavVideoCnt, Info[&#39;aid&#39;], Info[&#39;title&#39;])) print(&#39;封面图片:%s&#39; % (Info[&#39;pic&#39;])) printInfo(Info) biliplusApiCnt = 0 runTime = 0 def getInvalidVideoInfo(video_id, Info): global aFavVideoCnt, biliplusApiCnt, runTime biliplusApiCnt += 1 while biliplusApiCnt / ((time.time() - runTime) / 60.0) &gt;= 5: time.sleep(1) url = &#39;https://www.biliplus.com/api/view?id={vid}&#39;.format(vid = video_id) InvVideoInfo = getJsonUrl(url) if &#39;code&#39; in InvVideoInfo: print(&#39;视频编号:#%d [已失效][BiliplusApi数据缺失] AV号:%d 视频标题:已失效视频&#39; % (aFavVideoCnt, video_id)) print(&#39;封面图片:%s&#39; % (Info[&#39;pic&#39;])) printInfo(Info) else: print(&#39;视频编号:#%d [已失效][BiliplusApi获得标题与封面图片] AV号:%d 视频标题:%s&#39; % (aFavVideoCnt, video_id, InvVideoInfo[&#39;title&#39;])) print(&#39;封面图片:%s&#39; % (InvVideoInfo[&#39;pic&#39;])) printInfo(Info) def start(): # for cmd global totVideoNum, runTime logging.basicConfig(level=logging.DEBUG) if sys.getdefaultencoding() == &#39;ascii&#39;: sys.stdout = open(&quot;FavoriteVideoList.txt&quot;, &quot;w&quot;, encoding = &#39;gb2312&#39;) else: sys.stdout = open(&quot;FavoriteVideoList.txt&quot;, &quot;w&quot;, encoding = &#39;utf-8&#39;) initUid() runTime = time.time() getFavoriteList(bilibili_uid) print(&#39;你的收藏夹共有%d个视频&#39; % (totVideoNum)) logging.info(&#39;已完成！&#39;) # def windowMain(Uid, filePath): # for window ui if __name__ == &#39;__main__&#39;: # cmd start() 生成CSV文件生成可以用Excel打开的逗号分隔值文件，因为Unicode(UTF-8)文件头没有BOM编码会导致编码错误（后期会处理），可以使用Notepad++修改Unicode(UTF-8)为ANSI，或者修改为带BOM编码格式的Unicode(UTF-8)文件。 from urllib.request import urlopen import json import re import time import sys import logging # -*- coding: UTF-8 -*- bilibili_uid = 0 aFavVideoCnt = 0 totVideoCnt = 0 totVideoNum = 0 def initUid(): global bilibili_uid bilibili_uid = int(input()) def getJsonUrl(url): Data = urlopen(url).read().decode(&#39;utf-8&#39;) jsonData = json.loads(Data) return jsonData def getFavoriteList(uid): global totVideoNum print(&#39;收藏夹编号,收藏夹名称,收藏夹视频数量,视频编号,AV号,视频状态,视频标题,封面图片,投稿时间,描述,分区,标签,up主用户名,up主uid,播放,弹幕,回复,收藏,硬币,分享,喜欢,收藏时间,&#39;) favoriteListUrl = &#39;https://api.bilibili.com/medialist/gateway/base/created?pn=1&amp;ps=100&amp;up_mid={uid}&amp;is_space=0&amp;jsonp=jsonp&#39;.format(uid=uid) favoriteListData = getJsonUrl(favoriteListUrl) listInfo = favoriteListData[&#39;data&#39;][&#39;list&#39;] favNum = len(listInfo) for i in range(0, favNum): totVideoNum += listInfo[i][&#39;media_count&#39;] for i in range(0, favNum): favInformation = &#39;#{x1},{x2},{x3}&#39;.format(x1=i+1, x2=listInfo[i][&#39;title&#39;], x3=listInfo[i][&#39;media_count&#39;]) getFavListVideo(uid, listInfo[i][&#39;fid&#39;], favInformation) def printInfo(Info): print(time.strftime(&quot;%Y-%m-%d-%H:%M:%S&quot;, time.gmtime(Info[&#39;pubdate&#39;])), end=&#39;,&#39;) print(&#39;&quot;%s&quot;&#39; % (Info[&#39;desc&#39;]), end=&#39;,&#39;) print(&#39;&quot;%s&quot;&#39; % (Info[&#39;tname&#39;]), end=&#39;,&#39;) print(&#39;&quot;%s&quot;&#39; % (Info[&#39;dynamic&#39;]), end=&#39;,&#39;) print(&#39;&quot;%s&quot;,&quot;%s&quot;&#39; % (Info[&#39;owner&#39;][&#39;name&#39;], Info[&#39;owner&#39;][&#39;mid&#39;]), end=&#39;,&#39;) print(&#39;%s,%s,%s,%s,%s,%s,%s&#39; % (Info[&#39;stat&#39;][&#39;view&#39;], Info[&#39;stat&#39;][&#39;danmaku&#39;], Info[&#39;stat&#39;][&#39;reply&#39;], Info[&#39;stat&#39;][&#39;favorite&#39;], Info[&#39;stat&#39;][&#39;coin&#39;], Info[&#39;stat&#39;][&#39;share&#39;], Info[&#39;stat&#39;][&#39;like&#39;],), end=&#39;,&#39;) print(time.strftime(&quot;%Y-%m-%d-%H:%M:%S&quot;, time.gmtime(Info[&#39;fav_at&#39;])), end=&#39;,&#39;) print() def getFavListVideo(uid, fid, favInfo): global aFavVideoCnt, totVideoCnt, totVideoNum aFavVideoCnt = 0 favPageUrl = &#39;https://api.bilibili.com/x/space/fav/arc?vmid={uid}&amp;ps=30&amp;fid={fid}&amp;tid=0&amp;keyword=&amp;pn={page}&amp;order=fav_time&amp;jsonp=jsonp&#39;.format(uid=uid, fid=fid, page=1) favPageDate = getJsonUrl(favPageUrl) printVideoInfo(favPageDate[&#39;data&#39;][&#39;archives&#39;], favInfo) pageCount = favPageDate[&#39;data&#39;][&#39;pagecount&#39;] for i in range(2, pageCount+1): favPageUrl = &#39;https://api.bilibili.com/x/space/fav/arc?vmid={uid}&amp;ps=30&amp;fid={fid}&amp;tid=0&amp;keyword=&amp;pn={page}&amp;order=fav_time&amp;jsonp=jsonp&#39;.format(uid=uid, fid=fid, page=i) favPageDate = getJsonUrl(favPageUrl) printVideoInfo(favPageDate[&#39;data&#39;][&#39;archives&#39;], favInfo) def printVideoInfo(aPageInfo, favInfo): global aFavVideoCnt, totVideoCnt, totVideoNum for i in range(0, len(aPageInfo)): print(favInfo, end=&#39;,&#39;) aFavVideoCnt += 1 totVideoCnt += 1 if totVideoCnt % 10 == 0 or totVideoCnt == totVideoNum: logging.info(&#39;已经完成了{num1}/{num2}个视频...&#39;.format(num1=totVideoCnt, num2=totVideoNum)) Info = aPageInfo[i] video_id = Info[&#39;aid&#39;] if Info[&#39;title&#39;] == &#39;已失效视频&#39;: getInvalidVideoInfo(video_id, Info) else: print(&#39;#%d,%d,[有效],&quot;%s&quot;,&quot;%s&quot;&#39; % (aFavVideoCnt, Info[&#39;aid&#39;], Info[&#39;title&#39;], Info[&#39;pic&#39;]), end=&#39;,&#39;) printInfo(Info) biliplusApiCnt = 0 runTime = 0 def getInvalidVideoInfo(video_id, Info): global aFavVideoCnt, biliplusApiCnt, runTime biliplusApiCnt += 1 while biliplusApiCnt / ((time.time() - runTime) / 60.0) &gt;= 5: time.sleep(1) url = &#39;https://www.biliplus.com/api/view?id={vid}&#39;.format(vid = video_id) InvVideoInfo = getJsonUrl(url) if &#39;code&#39; in InvVideoInfo: print(&#39;#%d,%d,[失效][BiliplusApi数据缺失],已失效视频,(·w·)&#39; % (aFavVideoCnt, Info[&#39;aid&#39;]), end=&#39;,&#39;) printInfo(Info) else: print(&#39;#%d,%d,有效,&quot;%s&quot;,&quot;%s&quot;&#39; % (aFavVideoCnt, Info[&#39;aid&#39;], InvVideoInfo[&#39;title&#39;], InvVideoInfo[&#39;pic&#39;]), end=&#39;,&#39;) printInfo(Info) def start(): # for cmd global totVideoNum, runTime logging.basicConfig(level=logging.DEBUG) if sys.getdefaultencoding() == &#39;ascii&#39;: sys.stdout = open(&quot;FavoriteVideoList.csv&quot;, &quot;w&quot;, encoding = &#39;gb2312&#39;) else: sys.stdout = open(&quot;FavoriteVideoList.csv&quot;, &quot;w&quot;, encoding = &#39;utf-8&#39;) initUid() runTime = time.time() getFavoriteList(bilibili_uid) print(&#39;你的收藏夹共有%d个视频&#39; % (totVideoNum)) logging.info(&#39;已完成！&#39;) # def windowMain(Uid, filePath): # for window ui if __name__ == &#39;__main__&#39;: # cmd start()","categories":[{"name":"编程","slug":"编程","permalink":"https://shiokiri.com/categories/编程/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://shiokiri.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://shiokiri.com/tags/爬虫/"}]},{"title":"「观测者轻语」杂谈","slug":"2021-08-08-talk-1","date":"2021-08-08T02:18:09.000Z","updated":"2025-03-21T01:54:14.800Z","comments":true,"path":"2021-08-08-talk-1/","link":"","permalink":"https://shiokiri.com/2021-08-08-talk-1/","excerpt":"更新于：A.D.2025.03.21","text":"更新于：A.D.2025.03.21 1. 关于编程学习1.1 信息资源的获取有问题尽量使用谷歌，学会查找阅读文档，出现bug也可以尝试用stackoverflow搜索，很多时候使用英文搜素更可能找到有用的解决方案。 1.2 各种工具的用法熟悉git和github的用法，可以先自己搭一个hexo博客试试，然后可以学习使用各种现代ide和编辑器，一开始学习可以使用ide（编辑器要配置不同语言的开发环境），但是一些依赖项的环境配置还是很难避免的。实际编程肯定也会使用更多的辅助工具，比如数据库的图形化显示。 1.3 学习顺序与学习内容我推荐先学习C++，这样可以建立对常用编程语言的快速学习能力，使用C++语言学习数据结构和算法，因为一来招聘会考算法，二来这方面会建立一些实际编程中一般性的思路。之后可以看CS的基础内容（操作系统，计算机组成，计算机网络，编译原理），学一些语言（Python、C#、Java）和开发框架（例如Spring Boot、Flutter），写一些实际项目（例如Windows桌面应用，Unity或者UE4游戏，网页前后端等），学习设计模式等软件开发的内容。 2. 关于电子游戏电子游戏作为一个近代的产物，具有极大的争议，不过具有成瘾性的游戏或许并不是一个有意义的游戏，我对此的理解为游戏作为一种事物的存在形式，一个合理且富有存在意义的电子游戏应该是至少具有一下三种性质中其中一种的通过电子计算机与计算机网络运行的交互程序。 2.1 艺术性图像、音乐、视频、文本可以作为一种游戏的子集。 正如文本可以构造剧情，图像可以表现艺术，音乐可以显露和谐，视频可以记录实际，这四种艺术形式在合理的运用下可以表现出独特的效果，那么游戏则可以包容不同艺术独特的优点，例如视觉小说。 2.2 游戏性一定规则的游戏可以作为竞技的手段，这类游戏与电子计算机出现之前的棋牌类游戏有一定的相似之处，只不过规则与算法复杂化了，例如反恐精英，DOTA2。 一定规则的游戏可以作为发挥个人创造能力的空间，满足非专业设计的创造满足感，例如模拟经营类游戏戴森球计划，沙盒游戏我的世界。 2.3 抽象性游戏也可以作为对现实世界的抽象，无论是3D建模还是物理引擎的设计都是基于现实世界的真实数学物理模型所做的简化操作，我们不可能通过模拟每一个原子的运动来建构一个世界，但可以通过对宏观现象的简化性描述来开始进行建构新的一个世界的起点。 例如开放世界游戏GTA5，看门狗2 Jason Gregory.游戏引擎架构[M]北京：电子工业出版社，2014.","categories":[{"name":"随笔","slug":"随笔","permalink":"https://shiokiri.com/categories/随笔/"}],"tags":[{"name":"编程学习","slug":"编程学习","permalink":"https://shiokiri.com/tags/编程学习/"},{"name":"电子游戏","slug":"电子游戏","permalink":"https://shiokiri.com/tags/电子游戏/"}]},{"title":"落影汐雾的记录集","slug":"2021-08-01-record_set","date":"2021-07-31T20:33:26.000Z","updated":"2025-03-21T01:05:08.748Z","comments":true,"path":"2021-08-01-record_set/","link":"","permalink":"https://shiokiri.com/2021-08-01-record_set/","excerpt":"更新于：A.D.2025.03.21 这篇文章大概就是用来在网页上看看的……\\ (￣︶￣\\ *))","text":"更新于：A.D.2025.03.21 这篇文章大概就是用来在网页上看看的……\\ (￣︶￣\\ *)) 网站历史 日期 字符串 2019.6 搭建了此博客 2019.9.12 购买了域名66ccff.xyz（已抛弃） 2019.9.22 用HTML5 up模板制作个人主页并使用域名66ccff.xyz，Blog改为二级域名blog.66ccff.xyz 2019.9.22 往主域名下加了几个网页游戏 2019.11.04 创建了Virtual Dimension页面 2020.8.16 购买了域名lyxw.xyz 生活随想 日期 字符串 2019.6 知乎看到了三个词语时光 岁月 年华 2019.9.7 读完了《白鹿原》 2019.9.8 吃了一颗柠檬 2019.9.10 学习了套接字 2019.9.14 看完了刀剑神域Animation的SAO篇 2019.9.15 打了第一场Codeforces和AtCoder 歌词 Lyrics Song 每一个梦都是个旋律 漫天回忆该如何去聆听 Step on your heart -心印-(Album ver) Luna Safari 晨风中的一缕光 折射梦想的宽广 Trii - Feel Your Dream 2018 如果还能找到你 就让风儿告诉你 Artificial Emotions 虚和实的叠重 光和影的交错 触摸流云和清风勾勒的美梦 寻遍星空 夜雾里去闪烁 光年外去诉说 让星辉照耀我浩瀚的宇宙 寻遍星空 风 将我的思绪打乱 也看不清未来 梦 穿越过人山人海 快要醒来 化尘旅行 阳光斜照进窗台，记忆皆化作尘埃 化尘旅行 将漂浮的声音都吞没 描绘着贝壳上的轮廓 趁暮色未干枯 让泪水藏匿那 未曾见过的颜色 涟漪 纵流光如水逝尽千年的河川 一梦又脉脉涨满 流光逝梦 曙神星的尘埃 镶嵌漆黑缎带 它们各自旋转 轨迹精密切开 尘降 琴瑟愿与 共沐春秋 滢溪潺潺 炊烟悠悠 白石溪 唱 你给我的梦想 在天空中回荡 就像那风一样 吹向四面八方 唱给雅音宫羽Ⅱ 没有叹息的别离 飘散在 十一月的秋风里 浔阳江 至少此刻我们的心意相连 愿那片纯蓝天空一般高远 纯蓝 寻觅着 风的波折 世末歌者 初夏的蝉鸣声 轻轻掠过耳边的风 火花 夏露秋霜，匆匆十载 记忆里的人都裁开 梨花泽泽远山远 踏上未知列车 一直飞到云层最高空 一日都市 在屏幕那边 天涯般遥远 心跳同步的时光 穿越过浩瀚星间 经历过无数世界 看时光交替更迭 星愿StarWish 接一片 落雪在温热掌心 街道光斑交映 排列节日的讯息 冬去春来再尽年 その日、眺めていた校庭は 薄く青い空が染みていて Euphoria 偏离了航道 任黑夜吞噬 安静等待轨迹的放逐 坠落星空 觥筹恍惚交杯 劝留几小杯 棋逢红颜一醉 千军万马退 苏幕遮 寻寻觅觅 冷冷清清 月落乌啼月牙落孤井 声声慢 未实现的誓言 穿过似水华年 没写完的诗篇 应该如何重现 不存在的夏天 横平竖直点捺勾折皆变化 笔走龙蛇墨书春秋尽潇洒 横竖撇点折 聊以数笔写遍古今的繁华 出经入典顾自将历史传达 横竖撇点折 当火焰划破夜空 我落入银河雨中 当所有人抬起头 凝望着短暂的梦 倒数到零 天山千里雪 伸手拦一拦 花雕敬一盏 请为我开颜 不问天 若不是《浣溪沙》把《秋夜月》儿掩 我怎会困守《牧羊关》 繁华唱遍 我自那 皑皑冰川经行过 笔尖被霜雪尽然覆没 烈火灼冰 渐渐 渐渐 渐渐 我也将追逐遥远 循着八月的思恋 夏日延长战 曾经在天空绽放过的刹那烟火 熄灭后会落在城市的哪个角落 刹那烟火，落尽清凉 人设Vocaloid 名称A 名称B 归属 $\\color{rgb(102,204,255)}{洛天依}$ Luo Tianyi 天矢禾念 $\\color{rgb(238,0,0)}{乐正绫}$ Yuezheng Ling 天矢禾念 $\\color{rgb(0,255,204)}{言和}$ Yan He 天矢禾念 $\\color{rgb(153,153,255)}{ 星尘Stardust }$ Stardust 平行四界 $\\color{rgb(238,130,238)}{心华}$ Xin Hua 上海望乘 $\\color{rgb(255,192,203)}{IA}$ イア 1st PLACE $\\color{rgb(57,197,187)}{初音未来}$ 初音ミク Crypton Synthesizer V 名称 代表物 团体 / 归属 赤羽 正四面体 五维介质 / 平行四界 苍穹 正八面体 五维介质 / 平行四界 诗岸 六面体 五维介质 / 平行四界 海伊 二十面体 五维介质 / 平行四界 星尘Minus 梅塔特隆立方体（星形八面体） 五维介质 / 平行四界 虚拟偶像 名称A 名称B 团体 / 归属 嘉然(Diana) 嘉然今天吃什么 A-SOUL / 乐华娱乐 &amp; 字节跳动 永远酱 永远永远酱w 独立Vup 阿梓(Azusa) 阿梓从小就很可爱 VirtuaReal Link 新科娘 心萪 CCTV新科动漫 鸠羽伦 鳩羽つぐ 独立VTuber 七海Nana7mi 010 VirtuaReal 白神遥 Shirakami Haruka Project SP ACGN作品动画 名称 开始日期 ~ 完成日期 Re：从零开始的异世界生活 2016.10 ~ 2016.12 埃罗芒阿老师 2017.4 ~ 2017.6 BLACK★ROCK SHOOTER OVA 2015.5 ~ 2017.7 非人哉 2019.1 ~ 2019.2 刀剑神域 第一季 2019.9 ~ 2019.9.30 月色真美 2017.4 ~ 2019.10.4 云之彼端，约定的地方 2019.10 ~ 2019.11 Charlotte 2020.7 ~ 2020.8 Angel Beats! 2017.10 ~ 2020.8 我的妹妹不可能那么可爱 第一季 2013.7 ~2020.8 我的妹妹不可能那么可爱 第二季 2013.7 ~ 2020.8 魔法少女小圆 2017 ~ 2021.9 玉子市场 2020.1 ~ 摇曳百合 2017.9 ~ 境界的彼方 2019.9 ~ 轻音少女 2018 ~ 中二病也要谈恋爱 2017 ~ 凉宫春日的忧郁 2020.8 ~ 稻荷恋之歌 2020.1 ~ 冰菓 2021 ~ 樱花庄的宠物女孩 2019 ~ 动画电影 名称 完成日期 大鱼海棠 2016.7 你的名字 2017.10 声之形 2019.8 天气之子 2019.11.2 HELLO WORLD 你好世界 2020.3 视觉小说Visual Novel 名称 开始日期 ~ 完成日期 NEKOPARA Vol.0/1/2 2016 ~ 2017.4 妄想症：Deliver Me . ~ 2018.8 美少女万华镜 1 2017 ~ 2018.11 KARAKARA 1 2017 ~ 2019.7 千恋*万花 2019.8 ~ 2020.1 魔女的夜宴 2019.8 ~ 2020.2 沙耶の唄 2013.7 ~ 2020.2 Doki Doki Literature Club! 2019 ~ 2020.2 君と彼女と彼女の恋 . ~ 2020.2 Narcissu 1st . ~ 2020.3 Ever17 —the out of infinity— 2019 ~ 2020.3 しゅがてん!-sugarfull tempering- 2020.1 ~ 恋×シンアイ彼女 2020.1 ~ 2021.10 Summer Pockets 2020.1 ~ eden* 2020.2 ~ 三色绘恋 Tricolour Lovestory 2020.1 ~ Riddle Joker 2020.2 ~ 枝江往事 2021.7 ~ 恋爱绮谭~不存在的夏天~ 2019 ~ 2021.7 LOOPERS 2021.6 ~ 2021.9 青空下的加缪 2021.1 ~ Clover Day’s 2021.1 ~ 轻小说 名称 完成日期 [伏见つかさ].我的妹妹不可能那么可爱 2020.8 [谷川流].第1卷 凉宫春日的忧郁 2020.8 视频Bilibili Macro Link-Visual Release 2019 【⚡️ 热 爱 1 0 5 ° C 的 然 然⚡️ 】 【嘉然/100W庆祝】“我们只是朋友？”𝓕𝓻𝓲𝓮𝓷𝓭𝓼【MMD/PV】 “想把夏天的橘子汽水，卖给颜料用完的梵高。” 【4K/完整版】","categories":[{"name":"杂项","slug":"杂项","permalink":"https://shiokiri.com/categories/杂项/"}],"tags":[{"name":"记录","slug":"记录","permalink":"https://shiokiri.com/tags/记录/"}]},{"title":"2021夏日小日记","slug":"2021-07-29-diary","date":"2021-07-29T02:18:09.000Z","updated":"2025-03-21T01:53:10.613Z","comments":true,"path":"2021-07-29-diary/","link":"","permalink":"https://shiokiri.com/2021-07-29-diary/","excerpt":"更新于：A.D.2021.09.01 以此或多或少记录下一点暑假的生活 \\ (￣︶￣\\ *))","text":"更新于：A.D.2021.09.01 以此或多或少记录下一点暑假的生活 \\ (￣︶￣\\ *)) 6.7-6.106.7第一天上午语文没什么特殊的地方，中规中矩弄完，十分幸运地在文言文翻译提笔忘字，诗歌看不太懂写了一堆废话（大概是寄了😭，发现选择也错了），考完感觉就……还挺正常的。 中午食堂的饭挺好吃的，也不想多聊天。 下午好热，考试的时候特别焦燥，数学选择第八题把概念弄错了，然后第十二题匆匆看完AB选项选了一个不太想接着做了，接着……第四个填空第二个空算错好几次，最后还把n写成k了日。这时候已经快开考一个小时了，心里开始很慌张，第三个大题写成了$cos(A)=cos(\\pi-A)$😅，第四个大题把底面画错了，虽然后面做对了可都错了靠前的步骤，第五第六个大题就剩了15分钟，匆匆写了一问，圆锥联立韦达了一下，导数考的东西学得也不太会。考完出来就烦得要命，还特别热……想了想也很无奈，不过我同桌勇敢和对答案发现比我更惨，不想说什么了。 晚上想了想发现填空第四题公式写错了字母……心态有点不太好。 第二天上午来了聊聊天，课间出去走了走，心里估计可能只能上600分了（事实也是这样）。 下午英语的难度刚好能让我看懂，到时间刚刚写完作文，挺正常的。这两天搬到了实验室，圆凳真是坐得让人腰疼得要死🥵。心态还算好，希望化学别裂开。 第三天物理前面都还好，最后一题出个弹簧一直都不太会，估计没分了。化学单选都记不清知识点，多选后两个依然不会，有机倒是倒推完，就能全写出来了，最后一题发挥想象力编了几个空上去。 晚上一直在想考完怎么玩半天没睡着…… 最后一天考试的时候下起来了雨，感觉很期待结束，但是也不着急。生物多选后四个可能都单选了，遗传就会前三个空，基因工程一个不会，猜了一个酶切位点和用想象力写满了这个题，考完两个大题只会三个空，都不好说什么了。挺难受的……最有把握的数学就这么寄了😥。出来还下大雨，淋了半天才出校门😰。 出了成绩感觉和想象的差不多，最后……专业没去什么天坑🥰，我真是感恩戴德。 6.10 - 6.306月10日中午天晴了，去河边转了转，下午回去收拾了教室。很怅然若失吗？ 6月23日去了毕业典礼，去了机房，也是最后一次回高中。 7.1 - 7.28考了科目一，玩游戏，买了csgo深海复仇的ak47皮肤，又买了只狼、死亡细胞、undertale、恋爱绮谭，报志愿，查录取结果，买了电脑和ipad。 7.29台风到了但是雨下得不是特别大，早晨起来先给域名续了费，namesilo买的xyz域名，第一年0.99美元，续费9.29美元，namesilo用起来还是挺靠谱的。 现在早上要去练车，不过下雨了难得放个假，早饭先去吃了一包火鸡面，依旧是等录取通知书的一天。 终于收集够了原神雪山的80个绯红玉髓，因为我想要那个翅膀…… 今天把台式机上的博客源文件之类的东西用局域网转移到笔记本上来了。 晚上和同学打csgo和gta5，麦克风又出了点小问题，调了半天。 7.30今天上午接着练车，倒车入库…… 中午apple pencil到了，ems还要签收签字，不得不说ems送件员工的工作态度是真的好。 好像要下周三才能发录取通知书了= =真是绝了。 中午雨过天晴后难得有这么清澈的阳光啊了，天很蓝。 又睡了一下午，不怎么想玩了，随便翻翻书了，晚上想看看K-On，或许是因为看到了某虚拟偶像的事。 不知不觉就快到八月了。 7.31上午练车，其余时间睡觉。 8.1睡觉，拿ems快递，试水airpods听听歌，漫无止境的八月到了。 8.2中午把node.js环境之类的东西配一下，设置一下github的ssh密钥，调整了一下blog。 8.3光猫坏了……等明天来修，出去骑车转转。 8.4今天不用练车，录取通知书终于发货了，ems应该明天就能到。 8.5中午通知书到了，开箱。 下午找同学玩，交流一番，有可爱的猫猫和狗，喝了咖啡豆磨的咖啡。 8.6在家，无事，阅读CSAPP，浏览bilibili、zhihu等网络平台 8.7立秋，下午试了试基岩版我的世界光线追踪，晚上和同学出去聊天，回忆高中生活。 8.8晨起，写一点东西。 下午去工商银行改一下预留信息…… 买了ipad保护套。 8.9睡了一天觉，买了《心庭荧彩》 8.10中午看了一点CSAPP，下午和同学玩你画我猜，接龙模式笑死了。买了个四级的题看看。 8.11 - 8.25开箱ipad，用ipad试试看了一点网络的书。看了一点数字电路 20号去考了科目二，好累…… 和同学出去吃火锅 收拾了开学物品 8.26初中同学聚会 8.27来报到，去领了好多小礼品 8.28早上去工商银行补办了因为曾用名问题没有随录取通知书寄送的银行卡 8.30上午下雨，下午开学典礼，躺平 8.31军训，下大雨，躺平 9.1军训，去海边拉练，听各种讲座，本篇至此结束","categories":[{"name":"随笔","slug":"随笔","permalink":"https://shiokiri.com/categories/随笔/"}],"tags":[{"name":"回忆录","slug":"回忆录","permalink":"https://shiokiri.com/tags/回忆录/"}]},{"title":"MMD制作简介","slug":"2020-08-19-mmd","date":"2020-08-19T14:22:39.000Z","updated":"2025-03-21T01:14:32.507Z","comments":true,"path":"2020-08-19-mmd/","link":"","permalink":"https://shiokiri.com/2020-08-19-mmd/","excerpt":"更新于：A.D.2020.08.19 刚刚做的：【MMD/洛天依】你是分割我人生的线 又将它们相连~勾指起誓 [1080p60fps]","text":"更新于：A.D.2020.08.19 刚刚做的：【MMD/洛天依】你是分割我人生的线 又将它们相连~勾指起誓 [1080p60fps] 做了一个MMD 先写一下用到的所有内容 模型：TDA 改变学院风洛天依.pmx by 星空下の轩雨 动作：勾指起誓-柔美版-动作数据.vmd by-2TIGers（呆喵挠琴） 镜头：(Camera DL) 勾指起誓.vmd by SakuraHayato 场景：skura no ame.pmx by 挽挽姌School_Desk_Chair_TypeA.pmx by 下校 MME：Rui_cg：ray-mmd-1.5.0そぼろ：AutoLuminous4,Diffusion7おたもん：likelooksBYビームマンP：Sakura_v2_32_64_MMMiKeno,RedialC：ikClut_RCikeno：ikBokeh 工具：Miku Miku DanceAdobe Premiere ProAdobe After Effects 简单讲一下制作步骤 获取软件及资源并学习如果制作一个MMD主要需要场景、人物模型、动作数据等，如果我们需要用到别人制作好的内容时，在作者允许使用的情况下注明原作者，即写清借物表。如果选择自己制作，可以制作其中的一项数据，比如使用3D建模软件例如Blender等制作场景及人物模型，在MMD中编辑动作数据等。 软件获取我提供一个 https://pan.baidu.com/s/1yJnCEJI6fSHhH3IkNHM4nA pnx9 资源获取善用搜索引擎可以解决大部分问题 介于之后需要访问大量墙掉的网站，需要准备某些工具，并且需要会在GitHub网页上进行阅读及操作和在大量日文网站上进行操作，所以还需要一个带有翻译功能的浏览器。 参考：https://web.archive.org/web/20160622040846/http://konobaka.com/post/400994_16e51be (已删除，使用wayback machine查看，需要某些工具) https://xywiki.com/MMD https://blog.csdn.net/NSJim/article/details/105743730 以上是几篇对各种内容介绍比较全的文章 这是MME的资源站点：https://w.atwiki.jp/vpvpwiki/pages/272.html 你会经常访问到的网站：https://seiga.nicovideo.jp/ https://www.nicovideo.jp/ https://bowlroll.net/ 一些MME资源：https://onedrive.live.com/?id=EF581C37A4524EDA%21108&amp;cid=EF581C37A4524EDA （注意是onedrive，需要使用工具） 我提供一些，东西挺多的：https://pan.baidu.com/s/1whV2t1uWZHxvq63K3McKkg i5b1 学习软件及MME使用出现问题善用搜索引擎 参考：https://www.bilibili.com/read/cv135853 https://space.bilibili.com/11831050 https://www.bilibili.com/read/cv2529911 进行MMD制作并导出原始文件 注意看一下上面的界面，首先除音频外所有内容都可以直接拖拽进入程序内，左下角第二栏是切换.pmx文件控制的内容的，在模型操作栏内切换到照明一栏时，在附件操作栏内可以切换.x文件控制的内容，右上角MMEffect控制部分MME的功能。其余内容不复杂，可以用b站或搜索引擎简要学习，或者说哪里需要使用就学习哪个部分。 导出时帧率选择60fps，录制范围选择0~结束帧，不要勾选导出音频，可能出现bug，在后期编辑的时候加入音频。 注意选择空余较大的硬盘分区，一分钟1080p60fps原始视频会占用大约30G空间。 后期处理及压制后期处理后期编辑时我们需要使用编辑软件加入音频，进行剪辑以及其他操作，推荐使用Pr和Ae。 我们看一下Pr的界面。 我们可以直接把需要的资源拖拽到左侧一栏中，在右侧下方一栏，下方四条轨道是音轨，我们把音频拖拽到上方，然后可以选择顶栏的音频一项进行调整。上方四条轨道是四个图层，上方的图层可以覆盖下方的图层，并且可以新建图层，这里我们把视频放在V1图层并且把视频和音频轨道对齐，多个视频也要对其，上方的图层可以增加特效和字幕，这里我用Ae制作字幕，V4轨道的字幕在右侧，V3轨道的字幕在左侧，在导出时一定要注意选择视频码率和音频码率及采样率，选择H.264即mp4格式，注意分辨率帧率保持与原视频一致。如果需要不被b站二压的话视频码率不能超过6000 KB/s，音频码率不能超过320 KB/s，并且采样率一定要为44100 Hz。 参考b站官方的规定： http://www.bilibili.com/read/cv311112 http://www.bilibili.com/read/cv527957 Pr Ae的导出快捷键都是Ctrl+M，这里看一下导出界面，一定注意红框内的内容是否正确。 然后我们看一下Ae的这个字幕是怎么做的。 首先单击新建合成，注意接下来弹出的合成设置，将分辨率和帧速率设置成与你的视频相同，持续时间我们选10s。 接下来看下图，我们先单击1箭头指向的按钮，使画面变为透明，然后使用2箭头的工具在视频中选择合适的位置书写字幕。 之后在右侧一栏中调整字体等内容。最后我们制作特效。 选择菜单栏-窗口-效果和预设，之后在右侧出现这一栏内容，选择其中的*动画预设-Text-Blurs-蒸发拖动到字幕上，当然也可以是其他内容。这个效果仅有出场效果，所以我们点击字幕，按下u键，找到动画的关键帧，两个关键帧分别为动画开始与动画结束。接下来用鼠标拖动选中两个关键帧并移动位置，之后按下复制快捷键复制两个关键帧，而后移动箭头，然后按下粘贴快捷键粘贴到前方，这时交换前方两个关键帧的位置，后方两个关键帧保持不变，这样前方的动画就变成了入场效果。最后调整这四个关键帧的位置，并且选择上方的第二行的按钮进行切片。 最后进行导出，按下Ctrl+M，按123步骤操作下图界面。 步骤1：如图进行调整，如果没有安装QuickTime就去安装。步骤2：选择输出路径。步骤3：点击渲染。 最后将输出好的mov文件拖拽进入Pr进行对轨操作即可，如果有重合的部分可以用两条轨道交错放置字幕。 压制参考：https://www.bilibili.com/read/cv954478/ 使用小丸工具箱即可，可以先压制再在Pr中进行编辑。","categories":[{"name":"技术","slug":"技术","permalink":"https://shiokiri.com/categories/技术/"}],"tags":[{"name":"MMD","slug":"MMD","permalink":"https://shiokiri.com/tags/MMD/"}]},{"title":"烦躁沉寂的八月","slug":"2020-08-16-august","date":"2020-08-16T14:03:37.000Z","updated":"2025-03-21T01:51:53.071Z","comments":true,"path":"2020-08-16-august/","link":"","permalink":"https://shiokiri.com/2020-08-16-august/","excerpt":"更新于：A.D.2020.08.16 蝉时雨 化成淡墨渲染暮色","text":"更新于：A.D.2020.08.16 蝉时雨 化成淡墨渲染暮色 喜出望外（概率之中）地获得了20天假期，它被一如既往地在虚幻中无情地消耗殆尽而不留一点痕迹。在大量的睡梦中，这些假期被我无情的浪费了。计划好好写的作业只有物理生物语文都好好写了，罢了，已经没有什么耐心了。总之，时间过得如此之快，在还没有觉察之前它就已经悄然消逝了。 八月的前几天是如此的燥热，空气沉闷得让人无法呼吸，我们只好打开空调以求得一丝舒适的机会。而后十几天却开始了大量的降雨，在北方这和往年是一样的，只不过比起去年来说下雨的次数频繁些，降雨量小些。 天气从那时开始便一天比一天凉爽了，这样忙里偷闲日子也终将结束。 放假以来我发现我对游戏完全失去了兴趣，没有任何欲望在可以趋使我打开那些各式各样的游戏。其他时间，我看了看动画片，这是个挺有趣的事，毕竟我之前几年很少看什么动画之类的东西。还有便是看了看C#和unity罢了，其他时间也没干什么。 毕竟只是自己在寻找这什么意义而已吧，毕竟这样压抑的生活就没什么有趣的。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://shiokiri.com/categories/随笔/"}],"tags":[{"name":"回忆录","slug":"回忆录","permalink":"https://shiokiri.com/tags/回忆录/"}]},{"title":"使用jsDelivr+PicGo对图片进行cdn加速","slug":"2020-08-16-cdn","date":"2020-08-15T23:45:15.000Z","updated":"2025-03-21T01:14:36.561Z","comments":true,"path":"2020-08-16-cdn/","link":"","permalink":"https://shiokiri.com/2020-08-16-cdn/","excerpt":"更新于：A.D.2020.08.16 GitHub Pages上图片的访问速度不佳，而且使用不便，现在来用GitHub+jsDelivr+PicGo解决这个问题。","text":"更新于：A.D.2020.08.16 GitHub Pages上图片的访问速度不佳，而且使用不便，现在来用GitHub+jsDelivr+PicGo解决这个问题。 一、新建GitHub仓库 二、生成token，保存 三、下载PicGo，安装使用手册：https://picgo.github.io/PicGo-Doc/zh 四、配置PicGo 五、使用直接引用使用方法：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 如果不写版本号，将直接引用最新版 其它：如果需要使用版本号就在release发布，一次不超过50MB。","categories":[{"name":"技术","slug":"技术","permalink":"https://shiokiri.com/categories/技术/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://shiokiri.com/tags/Blog/"},{"name":"jsDelivr","slug":"jsDelivr","permalink":"https://shiokiri.com/tags/jsDelivr/"}]},{"title":"一些metagame的介绍与评价（无剧透）","slug":"2020-05-18-metagame","date":"2020-05-18T15:53:35.000Z","updated":"2025-03-21T01:49:47.089Z","comments":true,"path":"2020-05-18-metagame/","link":"","permalink":"https://shiokiri.com/2020-05-18-metagame/","excerpt":"更新于：A.D.2021.07.31 meta这个概念最早源于元小说（Metafiction），比如乔斯坦·贾德的《苏菲的世界》就属于这一类小说。","text":"更新于：A.D.2021.07.31 meta这个概念最早源于元小说（Metafiction），比如乔斯坦·贾德的《苏菲的世界》就属于这一类小说。 后设小说（英语：Metafiction）又称元小说、超小说，是一种小说类型，透过自我意识的觉醒，刻意凸显书中虚构的错觉。威廉·加斯在1970年〈哲学与小说形式〉一文中首度提出“后设小说”的说法。典型的写作技巧包括将原先的剧情设定为一件文学作品，随后揭露故事的“真相”。后设小说透过讽刺和自我反省等手法，引导读者思考小说与现实之间的关联，进而有意识、有组织地探讨小说本身的虚构性。出自：https://zh.wikipedia.org/wiki/%E5%BE%8C%E8%A8%AD%E5%B0%8F%E8%AA%AA meta游戏与元小说类似，都会与现实中的读者或游玩者产生一定的交互，如同元小说会突出小说本身的虚构性，meta游戏也会着重显明自身世界的编程程序性或与该世界与玩家世界的关联性（我会将其分为程序代码型和平行世界型两种类型）并引导真实世界的游玩者通过游戏程序机制来获取到游戏世界本身并不具有的能力以此来改变游戏剧情，最终模糊虚拟和现实的边界。 程序代码型的游戏会和计算机本身产生一定的交互，并需要通过游戏程序以外的计算机内部操作完成游戏剧情的推进，或（且）会明确游戏本身是程序运行的结果。 平行世界型的游戏不会对计算机产生交互，但你可以通过自己的外部操作（存档/读档）改变平行世界的剧情走向，或（且）会明确游戏本身是独立于程序存在的一个世界，但程序可以改变此世界的一些时间线。 一般来说虽然meta游戏中你都可以完全操控主角的操作，但程序代码型会倾向于使你对游戏本身产生更多的操作，同时从前期就开始就强调主角和游玩者是两个不同的角色，而平行世界型一般会在后期点明游玩者的介入性，并强调主角对游玩者的操控性，但不会着重强调这两个角色的区分性和发挥的不同作用。 meta游戏的最主要特点是将真实世界中的游戏玩家作为游戏内容本身的参与者而不是游戏角色的操控者，也常常会有种说法指明meta游戏打破了第四面墙（显示器屏幕）。 Ever17 —the out of infinity— 时空轮回 平行世界型 AVG/galgame，科幻悬疑，设定不是非常非常科学但还是很有科学因素的，前期流程非常冗长无趣，主要体验最后解密快感。强烈推荐优先游玩此游戏，可以说此游戏也十分独特，且不存在惊吓和血腥内容。 Doki Doki Literature Club 心跳文学部 程序代码型 AVG/galgame，剧情简短明确，流程在2h左右，主要体验比较独特的吓人方式，游戏制作方不建议心理承受能力差及13岁以下人群游玩。 君と彼女と彼女の恋 程序代码型 AVG/galgame，部分精神污染极其严重，不要轻易尝试，有画面反色，文件修改等内容。前期的画面非常不错，淡色且偏水彩风格，适合看风景，前期一些设定让你一度以为这是个科幻故事，我倒是挺希望偏向一个科幻来叙事的，但是最后还是说归结到了计算机和程序这种设定上。总的来说也是很独特的游戏，这种风格的游戏几乎找不出第二个了。 Undertale 平行世界型 RPG游戏，总体来说也非常新奇，有很独特的地方，值得一玩。 Oneshot 程序代码型 冒险解谜游戏，一周目通关，部分解谜方式很新颖，会和你的计算机本身有所交互，没有在别的游戏里见过。二周目的剧情比较完善，也令人有所感动。缺点在于寻找东西的解谜就略显枯燥。 艾希 Icey 程序代码型 横版动作游戏，没有玩过，偏重于计算机方面的设定，平面砍杀，类似于空洞骑士。 史丹利的寓言 The Stanley Parable 程序代码型 冒险解谜游戏，有一些场景会有不安的感觉，本身内容不算太多，一共有十几个左右的结局。 恋爱绮谭~不存在的夏天~ 平行世界型 这部游戏的meta成分很少，寥寥几句话，但在国产galgame中是我见过的最新奇的一部作品了。整个题材融合了虚拟主播、都市怪谈、中国传统灵异设定、MtF、校园恋爱、悬疑以及部分科学性的解释、各种让人会心一笑的梗、一些故事和哲学的讨论、结尾的meta元素也不显突兀。不存在的夏天这一游戏名也一语双关，玩到后期我才明白这个名字的巧妙之处。总体来说虽然分离的故事在一开始关联性不强，但在最后给出的解释都比较合理，串联起了不同人的故事，各种悬疑也都在后期给出逻辑上并不问题的答案，对于悬疑性的体验还是不错的。我个人比较喜欢这种能融合各种现实元素的游戏，只得一提的便是游戏创新性设计的手机系统、前后文字位置的变化和声字不同的设计都显示出了这部游戏设计的独特之处，可以肯定这款游戏代表了国产galgame的一流水平。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://shiokiri.com/categories/随笔/"}],"tags":[{"name":"metagame","slug":"metagame","permalink":"https://shiokiri.com/tags/metagame/"},{"name":"galgame","slug":"galgame","permalink":"https://shiokiri.com/tags/galgame/"}]},{"title":"我接触与学习编程及OI的经历","slug":"2020-02-29-about-program","date":"2020-02-29T02:18:09.000Z","updated":"2025-03-21T01:51:27.967Z","comments":true,"path":"2020-02-29-about-program/","link":"","permalink":"https://shiokiri.com/2020-02-29-about-program/","excerpt":"更新于：A.D.2025.03.21","text":"更新于：A.D.2025.03.21 想来自己接触编程的时间真的不算短了，也是三年多了，但是没有学会太多的知识，其原因一是没有坚持在闲暇的时候学习，自己也一直缺少主观的动力去努力学习，二是自己实践得少，没有全面的知识体系，解决问题的过程中编程容易陷入困难以至于放弃。虽然自己知识浅薄，但是编程的确是我一直喜欢的一项事物，在这里我简单写写这几年的编程学习经历吧。 20162016年快要到了末尾，初中同学总是与我聊起些计算机方面的话题，不过仅限于些PC硬件，PS之类的平淡无奇的东西罢了，我也没什么动力去学习编程，尽管前几年一直对此方面非常感兴趣，也有意向去尝试，可我的确是不敢勇于尝试，也就是不愿跨出第一步去接触新事物罢了。 不过有一天，一位同学给我看了一本书：《零基础学C语言》，据他所说仅仅是在书店买了一本，我看了看觉得不算很难，正巧当时在知乎看了一些编程的问题，也有兴趣学C语言，就顺理成章的买了一本，的确算不上一流的教材，不过庆幸的是我没有选择谭浩强之类的时代产物，也没有去看至于到诸如《C Primer Plus》等可能略微劝退我的书籍。现在依稀记得对于反码补码之类的东西理解有一些难度，不过还是很有兴趣的看完了，也写出了第一个Hello world，当时我很少写代码，大部分时间花都在翻翻书，还觉得程序框图挺有趣的，记得书上写了一些五子棋之类的游戏，当时也没全看懂。 2017书自然是看完了，可是会写多少了吗？恐怕不是的。而后呢？自然没有多大的兴趣，只记得自己把书看懂了，后来也没有写过几次C语言罢了，曾经安装过Python环境，也没有怎么写过。 暑假的时候，在一些事情的影响下决定想学一学OI，自然开始看C++，因为比较底层的内容比如指针和二进制编码理解的还比较好所以几乎没什么阻力，当然没有看多少OOP的知识，然后就开始写写简单的OI题，看看数论，算法之类的，但是的确是非常水，贡献了很多时间给MC和B站之类的，于是到11月连DFS也写不熟练。就是这样去普及组水了个一等奖，当然本身也得顾及课内学习，况且是开学后才开始学算法的。 之后我对编程迅速失去兴趣，又开始玩电子游戏，半年没写代码。主要原因是没什么学习目的，也没接去接触开源社区，不太明白怎么用网络学习新技术。大概还是动力和兴趣不足。 2018从四月开始到年底的时间都花在了OI上，主要是学了大量的算法和数据结构，以及一些C++。最后11月提高组喜获二等奖，这一年没什么想法，除了C++别的语言几乎没有写过，不过上网时间倒是出奇的长，看了很多个人博客和知乎…… 其实虽然我不是特别讨厌算法竞赛，但是确实没什么非常喜欢学习算法的感觉，就像是随波逐流地而来一样。而且说真的只要一个算法满足在数学形式上复杂或者抽象程度上高的话，我在学习它的时候就会遇到极大的困难，非常难以凭借自学的能力克服。 2019今年主要还是学习OI，五月份的时候搭了搭博客，然后这时候觉得科学上网还是方便一些，时间不太允许自己搭，于是找了个机场，才开始真正用上了一些有价值的工具。 暑假开始便觉得OI只能拿个联赛一等奖，加上一直算法学习难度对我而言也是比较大，逐渐也就失去了热情，放弃了联赛之上比赛内容的学习。主要是保持每天做一些动态规划的题，学了一些自己喜欢的算法，不是联赛内容的算法看明白后写一写，就放弃继续做题了。 在学校剩下的时间便用来学一点点C++、C#和Python，大部分时间都在改博客的样式和学一些前端和Node.js基础知识，看了一些计算机的基础理论比如计网之类的，不过重心肯定在OI上，这些只作为了一些消遣般的活动，投入时间也不多，所以知识水平并不高。当然，知乎也看了不少…… 最后11月喜获联赛的一等奖，基本是我真实水平，没什么好说的……退役后闲暇时间学了一些CSAPP和x86汇编，但是没有自己写过。 2020现在可能不会再有太多时间写代码了，放假的时候作为消遣应该还是会看看编程相关的内容。 突发疫情，也不用去学校，现在主要想学学C++，C#、Python也想看一看。倒是有兴趣去学一些Unity，不过这些事肯定得放在放假的时候去做，因为上网课的时候还要先玩游戏…… 结尾事到如今所有事都已成定局了，学OI也给我的算法水平带来了很大的提升吧，当然上网时间多了也接触到了更多编程相关的内容和技术。 那么看来如果要保持长时间对编程的学习的话，适度的兴趣和合适的方法论是不可或缺的。兴趣的话就例如对于一些有趣事物的实现亦或是对科学知识的那种好奇心，方法论来说就是一些自学的方法诸如快速地获取并筛选信息、对一些语言知识和实践的综合运用和遇到问题时解决错误的步骤此类的问题。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://shiokiri.com/categories/随笔/"}],"tags":[{"name":"编程学习","slug":"编程学习","permalink":"https://shiokiri.com/tags/编程学习/"},{"name":"OI学习","slug":"OI学习","permalink":"https://shiokiri.com/tags/OI学习/"}]},{"title":"Windows软件指南","slug":"2019-10-28-software","date":"2019-10-27T09:44:02.000Z","updated":"2025-03-21T01:14:47.978Z","comments":true,"path":"2019-10-28-software/","link":"","permalink":"https://shiokiri.com/2019-10-28-software/","excerpt":"更新于：A.D.2019.10.28","text":"更新于：A.D.2019.10.28 断断续续写了一点自己了解过的软件，会一直更新 IDE及编辑器Visual Studio Code：编辑器，可以安装插件，实现对多种语言的支持 Visual Studio：大型IDE，主要用于C++开发，对C#、Visual Basic支持较好 Notepad++：高配版记事本，速度快，适合编辑多种文件，支持代码高亮 Subline：编辑器，支持插件 Vim：编辑器，独特的键盘指令及操作可以提高效率 Eclipse：IDE，用于Java开发，可以安装插件支持其他语言 Atom：GitHub开发的编辑器，比较漂亮，支持插件 JetBrains系列：IntelliJ、CLion、PyCharm 系统安全及工具火绒：比较舒服的安全工具，没有流氓行为 Mem Reduct：清理内存 CCleaner：清理硬盘垃圾文件 DiskGenius：复杂分区操作，磁盘修复 文件管理Listary：全硬盘文件搜索，界面类型及功能多样，适合日常使用 Everything：全硬盘文件搜索，功能更加专一，适合复杂文件操作 7-Zip：最好用的压缩软件，算法一流 FastCopy：快速拷贝文件，比Windows系统快 系统美化及桌面整理Fences：桌面整理，效果很漂亮，支持扩展出多桌面 Rolan：桌面轻量级收纳工具 Startisback：让任务栏透明吧 WallpaperEngine：让桌面壁纸动起来吧 SAO-Utils：模拟刀剑神域的界面 Live2dViewerEX：让live2d小人站在桌面上吧 TrafficMonitor：显示网速、CPU及内存的悬浮窗，支持更换皮肤 IM（即时通讯）TIM：QQ简化版本 Telegram：电报桌面版 Skype：微软的软件 硬件检测卡硬工具箱：常用的各种工具都包括了，例如CPU-Z，GPU-Z，SSD测速，硬盘检测等 aida64：硬件检测工具 工作及生活Chrome：Google开发的浏览器 Firefox：火狐浏览器 potplayer：音视频播放器，可以更换皮肤，清爽流畅 Bandicam：录屏软件 Vieas：图片查看器，打开速度更快，还可简单编辑图片 OneNote：记笔记神器，功能全面，网页剪取较好用 OneDrive：微软云盘，存点随时用的文档 印象笔记：经典笔记软件 文本排版和数学Typora：Markdown编辑器 Moeditor：Markdown编辑器 LaTeX：排版及数学公式工具 Matlab：数学计算及数学 Mathematica：数学计算及数学 GraphViz：图论 geogebra：数学 几何画板：几何 游戏Steam：Valve的游戏发行平台 Uplay：育碧发行平台 origin：EA发行平台 SSTap：用于境外服务器线路加速 Fraps：显示帧数 BakaXL：好看的MC启动器 梯子及暗网Shadowsocks：ss ShadowsocksR：ssr V2Ray Brook Tor浏览器：洋葱浏览器 编程工具terminus：很漂亮的一个终端 Git：版本控制 以下内容待更新 微软系列Word、 Adobe系列Photoshop： 艺术设计工具C4D： Blender： ACGNMMD： Vocaloid：","categories":[{"name":"计算机","slug":"计算机","permalink":"https://shiokiri.com/categories/计算机/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://shiokiri.com/tags/软件/"}]},{"title":"PyQt5上手指南","slug":"2019-10-25-pyqt","date":"2019-10-25T11:50:55.000Z","updated":"2025-03-21T01:14:50.372Z","comments":true,"path":"2019-10-25-pyqt/","link":"","permalink":"https://shiokiri.com/2019-10-25-pyqt/","excerpt":"更新于：A.D.2019.10.25","text":"更新于：A.D.2019.10.25 学习前提是需要对Python有一定的基础。 首先我们需要安装。 打开powershell输入： pip install pyqt5-tools 安装完毕后输入： designer 稍等，会弹出页面，如图所示： 现在创建一个MainWindow窗口，并进行编辑，如图所示： 默认的编辑模式是： 这是用来拖动控件的，上方的TextLabel是显示信息用的Label控件，空白的地方是用来输入信息或者显示信息的Text Edit控件，PushButton是能对点击操作发出信号的Push Button控件。 左侧的其他控件可以试试并查询功能。 控件上面的文本和窗口标题文本都可以通过右侧的此窗口修改： 现在我们切换到信号操作上： 试一试点击一个控件后拖动，这是你可以选择信号发送到其他控件或者是窗口本身。 因为信号所对应的命令还需要我们自己书写，所以我们随便指定一个命令： 这个操作的含义是当点击时关闭窗口。 现在是这样的，那么我们保存一下编辑好的界面。 打开VSCode，进入保存文件的路径，我们需要把保存的.ui文件转换成.py文件以便接下来的操作。 在终端里运行： pyuic5 FileName.ui -o FileName.py 现在我们重新配置一下settings.js文件以避免一些插件检测语法上的错误 settings.js{ &quot;python.pythonPath&quot;: &quot;C:/Users/UserName/AppData/Local/Programs/Python/Python37-32/python.exe&quot;,//选择安装路径 &quot;python.linting.pylintArgs&quot;: [ &quot;--extension-pkg-whitelist=PyQt5&quot;, &quot;--disable=W,C&quot;, &quot;--generate-members&quot; ]//避免错误报错 } 现在新建一个文件： import sys import FileName from PyQt5.QtWidgets import QApplication, QMainWindow if __name__ == &#39;__main__&#39;: app = QApplication(sys.argv) MainWindow = QMainWindow() ui = FileName.Ui_MainWindow() ui.setupUi(MainWindow) MainWindow.show() sys.exit(app.exec_()) 运行此文件，即可看到我们刚才制作的窗口。 下面的问题就是要添加对应的功能，我们打开刚才制作好的FileName.py进行修改。","categories":[{"name":"编程","slug":"编程","permalink":"https://shiokiri.com/categories/编程/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"https://shiokiri.com/tags/PyQt/"},{"name":"Python","slug":"Python","permalink":"https://shiokiri.com/tags/Python/"}]},{"title":"VSCode配置Python环境及Python入门学习","slug":"2019-10-17-python","date":"2019-10-17T08:46:37.000Z","updated":"2025-03-21T01:14:52.155Z","comments":true,"path":"2019-10-17-python/","link":"","permalink":"https://shiokiri.com/2019-10-17-python/","excerpt":"更新于：A.D.2019.10.17","text":"更新于：A.D.2019.10.17 大概七月份花了一天的时间把python的基础语法看了一遍，十月份再花了一点时间学习，主要用于写绘制数据图片、网页爬虫、图形界面。 如果你会C++的话，我在这里就写一下如何以最快的速度看完语法，并且学会调用一些基本的库，尽量写到最简，不熟悉的语法和库可以直接查文档或者Google解决。 配置环境首先去官网下载合适版本并安装 https://www.python.org/ 安装时 记得勾选上Add Python 3.x to PATH再进行安装，这样不用自行配置环境变量 在cmd或者powershell下输入python 出现 Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)] on win32 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; 即代表安装成功 在VSCode中安装 这个插件 按下Ctrl+Shift+P选择Python: 选择解析器 Python: Select Interpreter填写python解析器路径C:/Users/UserName/AppData/Local/Programs/Python/Python37-32/python.exe（默认安装路径是这个） 检查并设置.vscode文件夹下的文件 launch.json{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Python&quot;, &quot;type&quot;: &quot;python&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${file}&quot;, &quot;console&quot;: &quot;integratedTerminal&quot; } ] } settings.json{ &quot;python.pythonPath&quot;: &quot;C:\\\\Users\\\\UserName\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37-32\\\\python.exe&quot;, } 右键-在终端中运行python文件 调试-启动调试 调试-在不调试的情况下启动 都可以运行，调试可以设置断点 在cmd或者powershell下输入python进入交互环境 使用python 文件名.py运行python文件 使用pip install 库名称安装库 使用pip list查看已安装的库 基础语法变量在赋值时被创建 数字int整型 float浮点型 complex复数 类型转换：int(x) float(x) complex(x,y) 字符串使用’’或””创建，下标从零开始 转义字符：和C++类似 运算：+连接 *重复 []获取字符 [:]截取，左闭右开 &gt;&gt;&gt;a = &quot;12345&quot; &gt;&gt;&gt;a[1:4] 234 格式化输出：print(“XXX%sXXX%dXXX” % (‘xxx’, 10)) 占位符和C++相同 运算符** 幂 / 除 // 整除 &gt;&gt;&gt;2**3 8 &gt;&gt;&gt;21/10 2.1 &gt;&gt;&gt;21//10 2 C++ Python $$ and &#124;&#124; or ! not in 在序列中找到值返回True 否则返回False not in 相反 其余和C++相同 数据结构下标从0开始 列表list类似C++中的vector l = [&#39;A&#39;, &#39;B&#39;, 2019, 2020] print(l[0]) #第0个 print(l[-2]) #倒数第2个 print(l[1:3]) #第1到第2个 del l[1] #删除第一个 print(l) list.append(2021) #在末尾添加新对象 print(l) --- 输出： A 2019 [&#39;B&#39;,2019] [&#39;A&#39;, 2019, 2020] [&#39;A&#39;, 2019, 2020, 2021] 剩余内容待更新 调用库剩余内容待更新 练习随便练习写了写的东西，但是tkinter不方便也不好看，所以我要再学一下PyQt，也方便以后学习C++的Qt 使用b站视频av号查询数据调用了b站的api 使用了tkinter最简单的功能 import tkinter as tk import json import re from urllib.request import urlopen def GetDict(date, keys, default=None): keys_list = keys.split(&#39;.&#39;) if isinstance(date,dict): dictionary = dict(date) for i in keys_list: try: if dictionary.get(i) != None: dict_values = dictionary.get(i) elif dictionary.get(i) == None: dict_values = dictionary.get(int(i)) except: return default dictionary = dict_values return dictionary Videojson = &quot;&quot; def WebRequest(id): global Videojson Videojson = urlopen(&quot;https://api.bilibili.com/x/article/archives?ids=&quot;+id).read().decode(&#39;utf-8&#39;) Data = json.loads(Videojson) return Data window = tk.Tk() window.title(&#39;哔哩哔哩数据查询&#39;) window.geometry(&#39;485x475&#39;) def insert_point(): VideoId = ScanId.get() VideoData = WebRequest(VideoId) ViewTextWindow.delete(0.0, &#39;end&#39;) TitleTextWindow.delete(0.0, &#39;end&#39;) FavoriteTextWindow.delete(0.0, &#39;end&#39;) DanmuTextWindow.delete(0.0, &#39;end&#39;) ReplyTextWindow.delete(0.0, &#39;end&#39;) CoinTextWindow.delete(0.0, &#39;end&#39;) JsonTextWindow.delete(0.0, &#39;end&#39;) ViewTextWindow.insert(&#39;insert&#39;, str(GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.stat.view&quot;))) TitleTextWindow.insert(&#39;insert&#39;, GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.title&quot;)) FavoriteTextWindow.insert(&#39;insert&#39;, str(GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.stat.favorite&quot;))) DanmuTextWindow.insert(&#39;insert&#39;, str(GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.stat.danmaku&quot;))) ReplyTextWindow.insert(&#39;insert&#39;, str(GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.stat.reply&quot;))) CoinTextWindow.insert(&#39;insert&#39;, str(GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.stat.coin&quot;))) JsonTextWindow.insert(&#39;insert&#39;, Videojson) tk.Label(window, text=&quot;输入视频AV号&quot;).place(x=350, y=10, anchor=&#39;nw&#39;) ScanId = tk.Entry(window) ScanId.place(x=320, y=45, anchor=&#39;nw&#39;) query = tk.Button(window, text=&quot;查询&quot;, width=6, height=1, command=insert_point) query.place(x=370, y=70, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;标题&quot;).place(x=10, y=10, anchor=&#39;nw&#39;) TitleTextWindow = tk.Text(window,height=1,width=35) TitleTextWindow.place(x=45, y=15, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;播放&quot;).place(x=10, y=40, anchor=&#39;nw&#39;) ViewTextWindow = tk.Text(window,height=1,width=35) ViewTextWindow.place(x=45, y=45, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;收藏&quot;).place(x=10, y=70, anchor=&#39;nw&#39;) FavoriteTextWindow = tk.Text(window,height=1,width=35) FavoriteTextWindow.place(x=45, y=75, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;弹幕&quot;).place(x=10, y=100, anchor=&#39;nw&#39;) DanmuTextWindow = tk.Text(window,height=1,width=35) DanmuTextWindow.place(x=45, y=105, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;回复&quot;).place(x=10, y=130, anchor=&#39;nw&#39;) ReplyTextWindow = tk.Text(window,height=1,width=35) ReplyTextWindow.place(x=45, y=135, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;硬币&quot;).place(x=10, y=160, anchor=&#39;nw&#39;) CoinTextWindow = tk.Text(window,height=1,width=35) CoinTextWindow.place(x=45, y=165, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;json&quot;).place(x=10, y=190, anchor=&#39;nw&#39;) JsonTextWindow = tk.Text(window,height=20,width=60) JsonTextWindow.place(x=45, y=195, anchor=&#39;nw&#39;) window.mainloop() 获取b站视频总播放排名并绘制柱状图需要matplotlib库 使用https://www.kanbilibili.com的数据，获取更多数据需要写js对网页进行交互，等待python学习以及前端学习来进行改善 from urllib.request import urlopen import json import re import matplotlib.pyplot as plt import numpy as np import requests # -*- coding: UTF-8 -*- def get_dict_value(date, keys, default=None): keys_list = keys.split(&#39;.&#39;) if isinstance(date,dict): dictionary = dict(date) for i in keys_list: try: if dictionary.get(i) != None: dict_values = dictionary.get(i) elif dictionary.get(i) == None: dict_values = dictionary.get(int(i)) except: return default dictionary = dict_values return dictionary videoData = urlopen(&quot;https://www.kanbilibili.com/rank/videos&quot;).read().decode(&#39;utf-8&#39;) videoAvList = re.findall(r&#39;href=&quot;/video/av(.*?)&quot;&#39;, videoData) # &lt;a href=&quot;/video/av36570707&quot; videoVisit = {} cnt = 0 Y = [] for i in range(0, len(videoAvList)): video_id = videoAvList[i] if(video_id in videoVisit): continue videoVisit[video_id] = 1 jsonData = urlopen( &quot;https://api.bilibili.com/x/article/archives?ids=&quot; + video_id ).read().decode(&#39;utf-8&#39;) Data = json.loads(jsonData) cnt += 1 Y.append(get_dict_value(Data, &quot;data.&quot;+video_id+&quot;.stat.view&quot;)) print(&#39;rank: %d | av: %s | 播放数：%s&#39; % (cnt, video_id, get_dict_value(Data, &quot;data.&quot;+video_id+&quot;.stat.view&quot;))) print(&#39;标题：%s&#39; % get_dict_value(Data, &quot;data.&quot;+video_id+&#39;.title&#39;)) n = cnt X = np.arange(n) plt.bar(X, Y) plt.bar(X, Y, facecolor=&#39;#66ccff&#39;, edgecolor=&#39;white&#39;) plt.xlim((-0.5, 99)) plt.ylim((1, 100000000)) plt.xlabel(&#39;Rank&#39;) plt.ylabel(&#39;View&#39;) new_ticks1 = np.linspace(0, 100000000, 11) plt.yticks(new_ticks1) new_ticks = np.linspace(0, 99, 100) plt.xticks(new_ticks) plt.show()","categories":[{"name":"编程","slug":"编程","permalink":"https://shiokiri.com/categories/编程/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://shiokiri.com/tags/Python/"}]},{"title":"Github Pages+HTML5 up制作个人主页及绑定二级域名","slug":"2019-09-23-html5-up","date":"2019-09-23T10:31:38.000Z","updated":"2025-03-21T01:15:06.937Z","comments":true,"path":"2019-09-23-html5-up/","link":"","permalink":"https://shiokiri.com/2019-09-23-html5-up/","excerpt":"更新于：A.D.2019.09.23 好看是第一生产力​qwq","text":"更新于：A.D.2019.09.23 好看是第一生产力​qwq 单个GitHub帐号下添加多个GitHub Pages的相关问题| 我很好奇 首先我们要知道GitHub Pages可以有多个，项目名为YourGitHubName.github.io的Pages使用这个域名访问，新添加一个项目ProjectName并设置为Pages项目后，使用YourGitHubName.github.io/ProjectName进行访问，那么我们可以使用一个Pages托管Hexo博客，一个Pages托管个人主页. 这里介绍一个网站提供了很多个人主页的模板https://html5up.net我们选择并下载其中一个，直接修改即可，有一定HTML和CSS基础都可以很轻松的修改，你需要一个浏览器并会使用控制台以及抓取元素和一个编辑器例如vscode即可开始编写. 那么你还需要会使用git并把这个网站的源代码上传到GitHub的repo上，不会上网找个教程吧. 那然后就是域名绑定了，如果你用域名绑定过GitHub Pages的话，你就知道域名的DNS设置要设置几个A选项，这里不讲那是啥玩意了，总之这个选项是设置GitHub的ip地址的，有空我再找链接吧，自己去查GitHub的文档就行。然后你要设置一个CNAME，设置YoutGitHubName.github.io，然后在Github的repo里添加一个CNAME文件内容是你的域名全称并且不带https，www这样的前缀. 那么现在有两个页面，我们可以把主域名解析到个人主页上，使用blog二级域名解析到博客上，具体设置就是在域名DNS设置里设置二级域名并且同样解析到YoutGitHubName.github.io上，然后分别在个人主页的CNAME里设置域名和博客的CNAME里设置blog.域名，记得打开GitHub Pages绑定个人域名的https. 现在等一会DNS解析生效和GitHub的https证书申请完毕应该就没什么问题了.","categories":[{"name":"技术","slug":"技术","permalink":"https://shiokiri.com/categories/技术/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://shiokiri.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://shiokiri.com/tags/CSS/"}]},{"title":"「莫比乌斯反演」","slug":"2019-09-23-mobius","date":"2019-09-23T01:40:00.000Z","updated":"2025-03-21T01:15:02.025Z","comments":true,"path":"2019-09-23-mobius/","link":"","permalink":"https://shiokiri.com/2019-09-23-mobius/","excerpt":"更新于：A.D.2019.09.23","text":"更新于：A.D.2019.09.23 参考资料：莫比乌斯反演-让我们从基础开始莫比乌斯反演_cnblogs_peng-ymP2257 YY的GCD 题解容斥原理 与 莫比乌斯反演整除分块_peng-ymOI生涯中的各种数论算法的证明 整除分块公式求： \\sum_{i=1}^{n}\\lfloor\\frac{n}{i}\\rfloor对于每个$\\lfloor\\frac{n}{i}\\rfloor$值相同的区间$[l,r]$有$r=n/(n/l)$，即对于$\\forall x\\in [i,n/(n/i)]$有$x=\\lfloor\\frac{n}{i}\\rfloor$. 时间复杂度$O(\\sqrt{n})$ 代码for(int l = 1, r; l &lt;= n; l = r + 1) { r = n / (n / l); ans += (r - l + 1) * (n / l); } 数论函数满足$f(ab)=f(a)f(b),gcd(a,b)=1$的数论函数称为积性函数满足$f(ab)=f(a)f(b)$的数论函数称为完全积性函数 积性函数$\\varphi(n)$：欧拉函数，表示小于n的正整数中与n互质的数的数目 \\varphi(x)=x\\prod_{i=1}^{n}\\left(1-\\frac{1}{p_i}\\right)$\\mu(n)$：莫比乌斯函数$\\sigma(n)$：因子和函数，表示n的正因子和$d(n)​$：因子个数函数，表示n的正因数个数 完全积性函数$\\epsilon(n)=[n=1]$：单位函数$id(n)=n$：恒等函数$1(n)=1$：常函数 狄利克雷卷积对于数论函数$f(n),g(n)$定义Dirichlet卷积为 (f\\times g)(n)=\\sum_{d\\mid n}f(d)g(\\frac{n}{d})若$f,g$为积性函数，$f*g,f\\times g$为积性函数 常用的狄利克雷卷积 id=\\varphi\\times 1\\quad n=\\sum_{d\\mid n}\\varphi(d) \\epsilon = \\mu \\times 1 \\quad \\epsilon(n) = \\sum_{d\\mid n}\\mu(d) \\varphi = \\mu \\times id \\quad \\varphi(n)=\\sum_{d\\mid n}d\\mu(\\frac{n}{d})=\\sum_{d\\mid n}\\mu(d)\\frac{n}{d}莫比乌斯函数 \\mu(d) = \\left\\{\\begin{matrix}1,d=1 \\\\ (-1)^n,d=\\prod_{i=1}^{n}p_i^{k_i} , \\forall p_i, k_i=1 \\\\ 0,d=\\prod_{i=1}^{n}p_i^{k_i} , \\exists p_i, k_i\\geqslant 2 \\end{matrix}\\right.线性筛求莫比乌斯函数void sieve() { mu[1] = 1; for(int i = 2; i &lt;= N; i++) { if(!vis[i]) prime[++cnt] = i, mu[i] = -1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; } } } 性质由$\\mu \\times 1 = \\epsilon$得 \\sum_{d|n}\\mu(d)=[n=1]莫比乌斯反演对于函数 f=g\\times 1有 g=\\mu \\times f即对于 f(n)=\\sum_{d\\mid n}g(d)有 g(n)=\\sum_{d\\mid n}\\mu(d)f(\\frac{n}{d})ProblemP2303 [SDOI2012]Longge的问题 \\sum_{i=1}^{n}gcd(i,n)\\\\ =\\sum_{d\\mid n}d\\times\\sum_{i=1}^{n}[gcd(i,n)=d]\\\\ =\\sum_{d \\mid n}d \\times \\sum_{i=1}^{\\frac{n}{d}}[gcd\\left ( i,\\frac{n}{d}\\right)=1]\\\\ =\\sum_{d \\mid n} d \\cdot \\varphi\\left ( \\frac{n}{d} \\right )P2257 YY的GCD原式 =\\sum_{k=1}^{min(n,m)}\\sum_{i=1}^{n}\\sum_{j=1}^{m}[gcd(i,j)=k](k\\in prime)由 \\sum_{d|n}\\mu(d)=[n=1]得 \\sum_{d|gcd(i,j)}\\mu(d)=[gcd(i,j)=1]原式 =\\sum_{k=1}^{min(n,m)}\\sum_{i=1}^{\\lfloor{\\frac{n}{k}}\\rfloor}\\sum_{j=1}^{\\lfloor{\\frac{m}{k}}\\rfloor}\\sum_{d|gcd(i,j)}\\mu(d)(k\\in prime) =\\sum_{k=1}^{min(n,m)}\\sum_{d=1}^{\\lfloor{\\frac{n}{k}}\\rfloor}\\mu(d){\\lfloor{\\frac{n}{kd}}\\rfloor}{\\lfloor{\\frac{m}{kd}}\\rfloor})(k\\in prime)设$T=kd$有原式 =\\sum_{k=1}^{min(n,m)}\\sum_{d=1}^{\\lfloor{\\frac{n}{k}}\\rfloor}\\mu(d){\\lfloor{\\frac{n}{T}}\\rfloor}{\\lfloor{\\frac{m}{T}}\\rfloor}(k\\in prime) =\\sum_{T=1}^{min(n,m)}{\\lfloor{\\frac{n}{T}}\\rfloor}{\\lfloor{\\frac{m}{T}}\\rfloor}\\sum_{k|T,k\\in prime}\\mu(\\frac{T}{k})#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int _ = 10000005, N = 10000000; int T, n, m, cnt; int vis[_], prime[_], mu[_], f[_], sum[_]; void sieve() { mu[1] = 1; for(int i = 2; i &lt;= N; i++) { if(!vis[i]) prime[++cnt] = i, mu[i] = -1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; } } for(int i = 1; i &lt;= cnt; i++) for(int j = 1; prime[i] * j &lt;= N; j++) f[j * prime[i]] += mu[j]; for(int i = 1; i &lt;= N; i++) sum[i] = sum[i - 1] + f[i]; } int main() { sieve(); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if(n &gt; m) swap(n, m); long long ans = 0; for(int l = 1, r = 0; l &lt;= n; l = r + 1) { r = min(n / (n / l), m / (m / l)); ans += 1LL * (n / l) * (m / l) * (sum[r] - sum[l - 1]); } printf(&quot;%lld\\n&quot;, ans); } return 0; } P3455 [POI2007]ZAP-Queries \\sum_{i=1}^n\\sum_{j=1}^m[gcd(i,j)=k] =\\sum_{i=1}^{\\lfloor{\\frac{n}{k}}\\rfloor}\\sum_{j=1}^{\\lfloor{\\frac{m}{k}}\\rfloor}[gcd(i,j)=1] =\\sum_{i=1}^{\\lfloor{\\frac{n}{k}}\\rfloor}\\sum_{j=1}^{\\lfloor{\\frac{m}{k}}\\rfloor}\\sum_{d\\mid gcd(i,j)} \\mu(d) =\\sum_{d=1}^{min(n,m)}\\mu(d)\\lfloor{\\frac{n}{d}}\\rfloor\\lfloor{\\frac{m}{d}}\\rfloor#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int _ = 50005, N = 50000; int T, n, m, d; int vis[_], prime[_], mu[_], sum[_], cnt; void sieve() { mu[1] = 1; for(int i = 2; i &lt;= N; i++) { if(!vis[i]) prime[++cnt] = i, mu[i] = -1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; } } for(int i = 1; i &lt;= N; i++) sum[i] = sum[i - 1] + mu[i]; } int main() { sieve(); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;d); if(n &gt; m) swap(n, m); n /= d; m /= d; long long ans = 0; for(int l = 1, r = 0; l &lt;= n; l = r + 1) { r = min(n / (n / l), m / (m / l)); ans += 1LL * (n / l) * (m / l) * (sum[r] - sum[l - 1]); } printf(&quot;%lld\\n&quot;, ans); } return 0; } P2522 [HAOI2011]Problem b \\sum_{i=a}^b\\sum_{j=c}^d[gcd(i,j)=k] =\\sum_{i=1}^b\\sum_{j=1}^d[gcd(i,j)=k]-\\sum_{i=1}^{a-1}\\sum_{j=1}^d[gcd(i,j)=k]-\\sum_{i=1}^b\\sum_{j=1}^{c-1}[gcd(i,j)=k]+\\sum_{i=1}^{a-1}\\sum_{j=1}^{c-1}[gcd(i,j)=k] \\sum_{i=1}^n\\sum_{j=1}^m[gcd(i,j)=k] =\\sum_{i=1}^{\\lfloor{\\frac{n}{k}}\\rfloor}\\sum_{j=1}^{\\lfloor{\\frac{m}{k}}\\rfloor}[gcd(i,j)=1] =\\sum_{i=1}^{\\lfloor{\\frac{n}{k}}\\rfloor}\\sum_{j=1}^{\\lfloor{\\frac{m}{k}}\\rfloor}\\sum_{d\\mid gcd(i,j)} \\mu(d) =\\sum_{d=1}^{min(n,m)}\\mu(d)\\lfloor{\\frac{n}{d}}\\rfloor\\lfloor{\\frac{m}{d}}\\rfloor#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int _ = 50005, N = 50000; int T, a, b, c, d, k; int vis[_], prime[_], mu[_], sum[_], cnt; void sieve() { mu[1] = 1; for(int i = 2; i &lt;= N; i++) { if(!vis[i]) prime[++cnt] = i, mu[i] = -1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; } } for(int i = 1; i &lt;= N; i++) sum[i] = sum[i - 1] + mu[i]; } long long calc(int n, int m, int k) { long long ans = 0; n = n / k; m = m / k; for(int l = 1, r = 0; l &lt;= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); ans += 1LL * (n / l) * (m / l) * (sum[r] - sum[l - 1]); } return ans; } int main() { sieve(); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;k); long long ans = calc(b, d, k) - calc(a - 1, d, k) - calc(b, c - 1, k) + calc(a - 1, c - 1, k); printf(&quot;%lld\\n&quot;, ans); } return 0; }","categories":[{"name":"数学","slug":"数学","permalink":"https://shiokiri.com/categories/数学/"}],"tags":[{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://shiokiri.com/tags/莫比乌斯反演/"},{"name":"整除分块","slug":"整除分块","permalink":"https://shiokiri.com/tags/整除分块/"}]},{"title":"「后缀数组」","slug":"2019-09-23-sa","date":"2019-09-23T01:38:18.000Z","updated":"2025-03-21T01:14:56.618Z","comments":true,"path":"2019-09-23-sa/","link":"","permalink":"https://shiokiri.com/2019-09-23-sa/","excerpt":"更新于：A.D.2019.09.23","text":"更新于：A.D.2019.09.23 参考资料：1.后缀数组详解2.后缀数组-学习笔记3.后缀数组——处理字符串的有力工具 定义$SA$排名为$i$的后缀的位置$rk$位置为$i$的后缀的排名$tp$第二关键字的排名为$i$的后缀的位置，还被用作$rank$的暂存$tax$每个排名对应的后缀数量后缀数组就是为了求出$sa$和$rk$ 性质$rk[sa[i]]=i$ $sa[rk[i]]=i$ $LCP(x,y) $：字符串x与字符串y的最长公共前缀，在这里指x号后缀与与y号后缀的最长公共前缀 $height[i]=lcp ( sa[i],sa[i - 1] )$，即排名为$i$的后缀与排名为$i−1$的后缀的最长公共前缀 $H[i]：height[rak[i]]$，即$i$号后缀与它前一名的后缀的最长公共前缀 $H[i] \\geqslant H[i - 1] - 1$ 证明 $LCP(i,j)=LCP(j,i) $ $LCP(i,i)=len(sa[i])=n-sa[i]+1$ $LCP(i,k)=min\\left{height[j] \\right}(i+1&lt;=j&lt;=k)$ $S$不同的子串个数$\\dfrac{n(n+1)}{2} -\\sum_{i=1}^nheight[i]$ 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;string&gt; #define R register int using namespace std; const int N = 1000005; string s; /* sa[i]：排名为i的后缀的位置 rak[i]：从第i个位置开始的后缀的排名，下文为了叙述方便，把从第i个位置开始的后缀简称为后缀i tp[i]：基数排序的第二关键字，意义与sa一样，即第二关键字排名为i的后缀的位置 tax[i]：i号元素出现了多少次。辅助基数排序 s：字符串，s[i]表示字符串中第i个字符串*/ int n, m, sa[N], rk[N], tp[N], c[N]; void _sort() { for(R i = 1; i &lt;= m; ++i) c[i] = 0; for(R i = 1; i &lt;= n; ++i) c[rk[i]]++; for(R i = 1; i &lt;= m; ++i) c[i] += c[i - 1]; for(R i = n; i &gt;= 1; --i) sa[c[rk[tp[i]]]--] = tp[i]; } void SA() { m = 150; for(R i = 1; i &lt;= n; ++i) rk[i] = s[i - 1], tp[i] = i; _sort(); for(R w = 1, p = 0; p &lt; n &amp;&amp; w &lt;= n; m = p, w &lt;&lt;= 1) { p = 0; for(R i = 1; i &lt;= w; ++i) tp[++p] = n - w + i; for(R i = 1; i &lt;= n; ++i) if(sa[i] &gt; w) tp[++p] = sa[i] - w; _sort(); swap(tp, rk); rk[sa[1]] = p = 1; for(R i = 2; i &lt;= n; ++i) rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] &amp;&amp; tp[sa[i - 1] + w] == tp[sa[i] + w]) ? p : ++p; } } /*i号后缀：从i开始的后缀 lcp(x,y)：字符串x与字符串y的最长公共前缀，在这里指x号后缀与与y号后缀的最长公共前缀 height[i]：lcp(sa[i],sa[i-1])，即排名为i的后缀与排名为i-1的后缀的最长公共前缀 H[i]：height[rak[i]]，即i号后缀与它前一名的后缀的最长公共前缀*/ int Height[N]; void Get() { int j, k = 0; for(int i = 1; i &lt;= n; i++) { if(k) k--; j = sa[rk[i] - 1]; while(s[i + k - 1] == s[j + k - 1]) ++k; Height[rk[i]] = k; } } int main() { cin &gt;&gt; s; n = s.length(); SA(); for(R i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, sa[i]); cout &lt;&lt; endl; Get(); return 0; } ProblemP2408 不同子串个数 ans=\\dfrac{n(n+1)}{2}-\\sum height[i]#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;string&gt; #define R register int using namespace std; const int N = 1000005; string s; int n, m, sa[N], rk[N], tp[N], c[N]; void _sort() { for(R i = 1; i &lt;= m; ++i) c[i] = 0; for(R i = 1; i &lt;= n; ++i) c[rk[i]]++; for(R i = 1; i &lt;= m; ++i) c[i] += c[i - 1]; for(R i = n; i &gt;= 1; --i) sa[c[rk[tp[i]]]--] = tp[i]; } void SA() { m = 150; for(R i = 1; i &lt;= n; ++i) rk[i] = s[i - 1], tp[i] = i; _sort(); for(R w = 1, p = 0; p &lt; n &amp;&amp; w &lt;= n; m = p, w &lt;&lt;= 1) { p = 0; for(R i = 1; i &lt;= w; ++i) tp[++p] = n - w + i; for(R i = 1; i &lt;= n; ++i) if(sa[i] &gt; w) tp[++p] = sa[i] - w; _sort(); swap(tp, rk); rk[sa[1]] = p = 1; for(R i = 2; i &lt;= n; ++i) rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] &amp;&amp; tp[sa[i - 1] + w] == tp[sa[i] + w]) ? p : ++p; } } int Height[N];//H[i] = Height[rk[i]] void Get() { int j, k = 0; for(int i = 1; i &lt;= n; ++i) { if(k) k--; j = sa[rk[i] - 1]; while(s[i + k - 1] == s[j + k - 1]) ++k; Height[rk[i]] = k; } } int main() { cin &gt;&gt; n &gt;&gt; s; SA(); Get(); long long ans = 1LL * n * (n + 1) / 2; for(int i = 1; i &lt;= n; ++i) ans -= Height[rk[i]]; cout &lt;&lt; ans &lt;&lt; endl; return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://shiokiri.com/categories/算法/"}],"tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"https://shiokiri.com/tags/后缀数组/"}]},{"title":"「概率期望」","slug":"2019-09-23-probability","date":"2019-09-23T01:34:34.000Z","updated":"2025-03-21T01:14:58.552Z","comments":true,"path":"2019-09-23-probability/","link":"","permalink":"https://shiokiri.com/2019-09-23-probability/","excerpt":"更新于：A.D.2019.09.23","text":"更新于：A.D.2019.09.23 概率公式条件概率公式设$A,B$是两个事件，且$P(B)&gt;0$,则在事件$B$发生的条件下，事件$A$发生的条件概率为$P(A|B)=\\dfrac{P(AB)}{P(B)}$ 乘法公式1.由条件概率公式得$P(AB)=P(A|B)P(B)=P(B|A)P(A)$2.推广：对$\\forall n \\geq 2$当$P(A1A_2…A{n-1})&gt;0$时有 $P(A1A_2…A{n-1}A{n})=P(A1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1A_2…A{n-1})$ 全概率公式如果事件组$B1,B_2,…,B_n$满足1.$\\forall i\\neq j\\in \\left {1,2,\\cdots ,n \\right },B_i\\cap B_j = \\varnothing$2.$B_1\\cup B_2\\cup …\\cup B_n=\\Omega$则称事件组$B_1,B_2,…,B_n$是样本空间$\\Omega$的一个划分,或称为样本空间$\\Omega$的一个完备事件组。设事件组$\\left {B_i \\right }$是样本空间$\\Omega$的一个划分，且$P(B_i)&gt;0(i \\in \\left {1,2,\\cdots ,n \\right })$对任一事件$A$，有$P(A)=\\sum{i=1}^{n}P(B_i)P(A|B_i)$ 贝叶斯公式设事件组$\\left {Bi \\right }$是样本空间$\\Omega$的一个划分，则对任一事件$A(P(A)&gt;0)$,有$P(B_i|A)=\\dfrac{P(AB_i)}{P(A)}=\\dfrac{P(B_i)P(A|B_i)}{\\sum{j=1}^{n}P(B_j)P(A|B_j)}$上式即为贝叶斯公式，$B_i$常被视为导致试验结果$A$发生的”原因“，$P(B_i)(i\\in \\left {1,2,\\cdots ,n \\right })$表示各种原因发生的可能性大小，故称先验概率；$P(B_i|A)(i\\in \\left {1,2,\\cdots ,n \\right })$则反映当试验产生了结果$A$之后，再对各种原因概率的新认识，故称后验概率。 数学期望离散型随机变量$X$的取值为$x1,x_2,x_3,…,x{n}$，$p1,p_2,p_3,…,p{n}$为$X$对应取值的概率则称$E(X)=\\sum{i=1}^{n}p{i}x_{i}$为离散型随机变量$X$的数学期望性质：$E(aX+bY)=aE(X)+bE(Y)$ ProblemP4316 绿豆蛙的归宿设$F[x]$表示从$x$走到$N$期望长度$F[x]=\\frac{1}{k}\\sum{i=1}^{k}(F[y{i}]+z{i})$$F[N]=0$$Ans=F[1]$P1365 WJMZBMR打osu! / Easy设$f[x]$表示到$x$期望得分 $g[x]$表示以$x$结尾期望$o$序列长度$s[i]==x\\ f[i]=f[i-1],g[i]=0$$s[i]==o\\ f[i]=f[i-1]+2*g[i-1]+1,g[i]=g[i-1]+1$$s[i]==?\\ f[i]=f[i-1]+\\frac{(2g[i-1]+1)+0}{2},g[i]=\\frac{(g[i-1]+1)+0}{2}$$Ans=f[n]$P1654 OSU!$p[i]$表示$i$位置成功概率设$f[i]$表示到$i$期望得分 $x1[i]$以$i$结尾$1$序列期望长度 $x2[i]$表示以$i$结尾$1$序列期望长度平方$(x+1)^{3}=(x^{2}+2x+1)(x+1)=x^{3}+3x^{2}+3x+1$若第$i$次成功且有$f[i-1]=x^{3}则f[i]=f[i-1]+3x^{2}+3x+1$$x1[i]=(x1[i-1]+1)p[i]$$x2[i]=(x2[i-1]+2x1[i-1]+1)p[i]$$f[i]=f[i-1]+(3x2[i-1]+3x1[i-1]+1)p[i]$$Ans=f[n]$P1297 [国家集训队]单选错位$Ans=\\sum{i=1}^{n-1}\\frac{1}{max(ai,a{i+1})}+\\frac{1}{max(a_1,a_n)}$","categories":[{"name":"数学","slug":"数学","permalink":"https://shiokiri.com/categories/数学/"}],"tags":[{"name":"概率","slug":"概率","permalink":"https://shiokiri.com/tags/概率/"},{"name":"期望","slug":"期望","permalink":"https://shiokiri.com/tags/期望/"}]},{"title":"C++STL的OI常用内容","slug":"2019-09-23-cpp-stl","date":"2019-09-23T01:13:16.000Z","updated":"2025-03-21T01:15:09.442Z","comments":true,"path":"2019-09-23-cpp-stl/","link":"","permalink":"https://shiokiri.com/2019-09-23-cpp-stl/","excerpt":"更新于：A.D.2019.09.23","text":"更新于：A.D.2019.09.23 参考资料:STL 在 OI 中的应用[C++ STL]Set和Multiset Stackstack 后入先出（LIFO）栈头文件#include&lt;stack&gt; 定义stack&lt;int&gt; s; 函数 函数 功能 q.top() 获取栈顶元素（并不删除） q.pop() 删除栈顶元素 q.push(x) 向栈中加入元素 q.empty() 判断栈是否为空 Queuequeue 先入先出（FIFO）队列头文件#include&lt;queue&gt; 定义queue&lt;int&gt; q; 函数 函数 功能 q.front() 获取队首元素（并不删除） q.pop() 删除队首元素 q.push(x) 向队列中加入元素 q.empty() 判断队列是否为空 priority_queue 优先队列头文件#include&lt;queue&gt; 定义priority_queue&lt;int&gt; q; // 队头最大 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; 队头最小 函数 函数 功能 q.top() 获取优先队列中最大的元素（并不删除），其时间复杂度为$O(1)$ q.pop() 删除优先队列中最大元素，其时间复杂度为$O(log n)$ q.push(x) 向优先队列中加入元素，其时间复杂度为$O(log n)$ q.empty() 判断优先队列是否为空 Set 与 Multiset set不允许重复 multiset允许重复 例: set : 1 2 3 4 5 6 multiset : 1 2 2 3 3 3 头文件#include &lt;set&gt; 定义multiset&lt;int&gt; s[N];//定义 multiset&lt;int&gt;::iterator it;//迭代器 函数 操作 效果 s.size() 返回当前的元素数量 s.empty () 判断大小是否为零，等同于$0==size()$，效率更高 操作 效果 count (elem) 返回元素值为$elem$的个数 find(elem) 返回元素值为$elem$的第一个元素，如果没有返回$end()$ lower _bound(elem) 返回元素值$&gt;=elem$的第一个元素位置 upper _bound (elem) 返回元素值$&gt;elem$的第一个元素位置 操作 效果 s.begin() 返回一个随机存取迭代器，指向第一个元素 s.end() 返回一个随机存取迭代器，指向最后一个元素的下一个位置 操作 效果 s.insert(elem) 插入一个$elem$副本，返回新元素位置，无论插入成功与否。 s.erase(elem) 删除与$elem$相等的所有元素，返回被移除的元素个数。 s.erase(pos) 移除迭代器$pos$所指位置元素，无返回值。 s.clear() 移除所有元素，将容器清空 离散化std::unique功能：对有序的容器重新排列，将第一次出现的元素从前往后排，其他重复出现的元素依次排在后面返回值：返回迭代器，迭代器指向的是重复元素的首地址 std::lower_boundlower_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了第一个大于等于value 的值。ForwardIter lower_bound(ForwardIter first, ForwardIter last,const _Tp&amp; val)算法返回一个非递减序列[first, last)中的第一个大于等于值val的位置。 std::upper_boundupper_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了第一个大于value 的值。这两个函数为C++ STL内的函数。ForwardIter upper_bound(ForwardIter first, ForwardIter last, const _Tp&amp; val)算法返回一个非递减序列[first, last)中第一个大于val的位置。 std::sort(b + 1, b + cnt + 1); int *end = std::unique(b + 1, b + cnt + 1); for(int i = 1; i &lt;= n; i++) a[i] = lower_bound(b + 1, end, a[i]) - b;","categories":[{"name":"编程","slug":"编程","permalink":"https://shiokiri.com/categories/编程/"}],"tags":[{"name":"Queue","slug":"Queue","permalink":"https://shiokiri.com/tags/Queue/"},{"name":"Stack","slug":"Stack","permalink":"https://shiokiri.com/tags/Stack/"},{"name":"STL","slug":"STL","permalink":"https://shiokiri.com/tags/STL/"}]},{"title":"「分层图」","slug":"2019-09-23-layered-graph","date":"2019-09-23T01:10:16.000Z","updated":"2025-03-21T01:15:03.907Z","comments":true,"path":"2019-09-23-layered-graph/","link":"","permalink":"https://shiokiri.com/2019-09-23-layered-graph/","excerpt":"更新于：A.D.2019.09.23","text":"更新于：A.D.2019.09.23 问题在一个无向图$G=(V,E)$中，可以改变$k$条边的权值为$\\Delta w$，求单源最短路径。 分层图分层图的想法就是如果有$k$条边权值变为$\\Delta w$，就建$k+1$层图。 这个图实际上是这样的，对于每$1$层中相连的点对$(u,v)$连权值为$w$的无向边，对于每个在原图中相连的点对$(u,v)$由$k$层点$uk$向$k+1$层点$v{k+1}$以及$k$层点$vk$向$k+1$层点$u{k+1}$连权值为$\\Delta w$的有向边，方向是从$k$层向$k+1$层。这样构造完成一张分层图后，从第$1$层的起始点$s1$求单源最短路径，最终第$k + 1$层的终点$t{k+1}$的单源最短路径值即为答案所求。原理其实很简单，如果从$k$层图到$k+1$层图，有向边$(uk,v{k+1})$是一条$\\Delta w$权边，走这条边，相当于把$w$权边变成了$\\Delta w$权边，并且进入了$k+1$层。这样如果有$k+1$层图的话，相当于进行了$k$次这种操作，自然就在$k+1$层图求最短路中实现了$k$次改变边权的目标。 题目P2939 [USACO09FEB]改造路Revamping Trails#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int N = 1e4 + 5, M = 5e4 + 5, K = 105; int n, m, k; struct Edge { int Next, to, dis; }e[M * K * 2]; int head[N * K], num; void add(int from, int to, int dis) { e[++num].Next = head[from]; e[num].to = to; e[num].dis = dis; head[from] = num; } int dist[N * K], vis[N * K]; struct node { int u, d; bool operator &lt; (const node &amp;x) const { return d &gt; x.d; } }; priority_queue&lt;node&gt; q; void dijk() { memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; q.push((node){1, 0}); while(!q.empty()) { int u = q.top().u; q.pop(); if(vis[u]) continue; vis[u] = 1; for(int i = head[u]; i; i = e[i].Next) { int v = e[i].to, w = e[i].dis; if(dist[v] &gt; dist[u] + w) { dist[v] = dist[u] + w; if(!vis[v]) q.push((node){v, dist[v]}); } } } } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for(int i = 1, u, v, z; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z); add(u, v, z); add(v, u, z); for(int j = 1; j &lt;= k; j++) { add(j * n + u, j * n + v, z); add(j * n + v, j * n + u, z); add((j - 1) * n + u, j * n + v, 0); add((j - 1) * n + v, j * n + u, 0); } } dijk(); int ans = 0x3fffffff; for(int i = 1; i &lt;= k + 1; i++) ans = min(dist[i * n], ans); printf(&quot;%d\\n&quot;, ans); return 0; } P4568 [JLOI2011]飞行路线#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;cstring&gt; using namespace std; const int N = 1e4 + 5, M = 5e4 + 5, K = 12; int n, m, k; int s, t; struct _edge { int Next, v, w; }e[M * K * 4 + M * 2]; int head[N * K], num; void add(int from, int to, int dis) { e[++num].Next = head[from]; e[num].v = to; e[num].w = dis; head[from] = num; } int dist[N * K], vis[N * K]; struct node { int u, d; bool operator &lt; (const node &amp;x) const { return d &gt; x.d; } }; priority_queue&lt;node&gt; q; void dijk(int x) { memset(dist, 0x3f, sizeof(dist)); dist[x] = 0; q.push((node){x, 0}); while(!q.empty()) { node tp = q.top(); q.pop(); int u = tp.u; if(u == t + k * n) break; if(vis[u]) continue; vis[u] = 1; for(int i = head[u]; i; i = e[i].Next) { int v = e[i].v, w = e[i].w; if(dist[v] &gt; dist[u] + w) { dist[v] = dist[u] + w; if(!vis[v]) q.push((node){v, dist[v]}); } } } } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); scanf(&quot;%d%d&quot;, &amp;s, &amp;t); s++, t++; for(int i = 1, u, v, z; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z); u++, v++; add(u, v, z); add(v, u, z); for(int j = 1; j &lt;= k; j++) { add(j * n + u, j * n + v, z); add(j * n + v, j * n + u, z); add((j - 1) * n + u, j * n + v, 0); add((j - 1) * n + v, j * n + u, 0); } } dijk(s); int ans = 1e9; for(int i = 0; i &lt;= k; i++) ans = min(ans, dist[t + i * n]); printf(&quot;%d\\n&quot;, ans); return 0; } P4822 [BJWC2012]冻结#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int N = 55, M = 1005, K = 55; int n, m, k; struct Edge { int Next, to, dis; }e[M * K * 10]; int head[N * K * 10], num; void add(int from, int to, int dis) { e[++num].Next = head[from]; e[num].to = to; e[num].dis = dis; head[from] = num; } struct node { int u, d; bool operator &lt; (const node&amp; x) const { return d &gt; x.d; } }; priority_queue&lt;node&gt; q; int dist[N * K * 10], vis[N * K * 10]; void dijk() { memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; q.push((node){1, 0}); while(!q.empty()) { int u = q.top().u; q.pop(); if(vis[u]) continue; vis[u] = 1; for(int i = head[u]; i; i = e[i].Next) { int v = e[i].to, w = e[i].dis; if(dist[v] &gt; dist[u] + w) { dist[v] = dist[u] + w; if(!vis[v]) q.push((node){v, dist[v]}); } } } } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for(int i = 1, u, v, z; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z); add(u, v, z); add(v, u, z); for(int j = 1; j &lt;= k; j++) { add(j * n + u, j * n + v, z); add(j * n + v, j * n + u, z); add((j - 1) * n + u, j * n + v, z &gt;&gt; 1); add((j - 1) * n + v, j * n + u, z &gt;&gt; 1); } } dijk(); int ans = 0x7fffffff; for(int i = 1; i &lt;= k + 1; i++) ans = min(ans, dist[i * n]); printf(&quot;%d\\n&quot;, ans); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://shiokiri.com/categories/算法/"}],"tags":[{"name":"分层图","slug":"分层图","permalink":"https://shiokiri.com/tags/分层图/"}]},{"title":"「网络流」","slug":"2019-09-23-network-flow","date":"2019-09-23T01:03:54.000Z","updated":"2025-03-21T01:15:00.417Z","comments":true,"path":"2019-09-23-network-flow/","link":"","permalink":"https://shiokiri.com/2019-09-23-network-flow/","excerpt":"更新于：A.D.2019.09.23","text":"更新于：A.D.2019.09.23 一些资料：最详细网络流建模基础 模板最大流Dinic没写当前弧优化什么的. 弃坑了，ISAP和HLPP有缘再学. P3376 【模板】网络最大流 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;cstring&gt; const int inf = 0x3fffffff; const int N = 10005, M = 100005; int n, m, s, t, maxflow; int d[N]; struct Edge { int Nxt, v, flow; }e[M &lt;&lt; 1]; int h[N], p = 1; void add(int u, int v, int z) { e[++p].Nxt = h[u]; e[p].v = v; e[p].flow = z; h[u] = p; e[++p].Nxt = h[v]; e[p].v = u; e[p].flow = 0; h[v] = p; } std::queue&lt;int&gt; q; bool bfs() { memset(d, 0, sizeof(d)); while(!q.empty()) q.pop(); q.push(s); d[s] = 1; while(!q.empty()) { int u = q.front(); q.pop(); for(int i = h[u]; i; i = e[i].Nxt) if(e[i].flow &amp;&amp; !d[e[i].v]) { q.push(e[i].v); d[e[i].v] = d[u] + 1; if(e[i].v == t) return true; } } return false; } int dinic(int u, int flow) { if(u == t) return flow; int rest = flow, k; for(int i = h[u]; i &amp;&amp; rest; i = e[i].Nxt) if(e[i].flow &amp;&amp; d[e[i].v] == d[u] + 1) { k = dinic(e[i].v, std::min(rest, e[i].flow)); if(!k) d[e[i].v] = 0; e[i].flow -= k; e[i ^ 1].flow += k; rest -= k; } return flow - rest; } int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); for(int i = 1, u, v, z; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z); add(u, v, z); } int flow = 0; while(bfs()) while(flow = dinic(s, inf)) maxflow += flow; printf(&quot;%d\\n&quot;, maxflow); return 0; } 费用流EKP3381 【模板】最小费用最大流 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;cstring&gt; const int _ = 50005; const int inf = 0x3f3f3f3f; int n, m, s, t; int ans, maxflow; int dist[_], incf[_], pre[_], vis[_]; struct Edge { int Nxt, v, flow, cost; } e[_ &lt;&lt; 1]; int h[_], p = 1; void add(int u, int v, int f, int c) { e[++p].Nxt = h[u]; e[p].v = v; e[p].flow = f; e[p].cost = c; h[u] = p; e[++p].Nxt = h[v]; e[p].v = u; e[p].flow = 0; e[p].cost = -c; h[v] = p; } std::queue&lt;int&gt; q; bool spfa() { memset(dist, 0x3f, sizeof(dist)); memset(vis, 0, sizeof(vis)); q.push(s); dist[s] = 0; vis[s] = 1; incf[s] = inf; while(!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for(int i = h[u]; i; i = e[i].Nxt) { if(!e[i].flow) continue; int v = e[i].v; if(dist[v] &gt; dist[u] + e[i].cost) { dist[v] = dist[u] + e[i].cost; incf[v] = std::min(incf[u], e[i].flow); pre[v] = i; if(!vis[v]) vis[v] = 1, q.push(v); } } } if(dist[t] == inf) return false; else return true; } void update() { int u = t; while(u != s) { int i = pre[u]; e[i].flow -= incf[t]; e[i ^ 1].flow += incf[t]; u = e[i ^ 1].v; } maxflow += incf[t]; ans += dist[t] * incf[t]; } int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); for(int i = 1, u, v, z, c; i &lt;= m; i++) { scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;z, &amp;c); add(u, v, z, c); } while(spfa()) update(); printf(&quot;%d %d\\n&quot;, maxflow, ans); return 0; } Problem[NOI2008]志愿者招募算法：线性规划 or 有源汇上下界最小费用可行流可以无视一开始幻想这样可以搞： 但其实很难限制条件并且流量并不能准确一对多去覆盖点。 所以是建成这样的： 但是为什么对呢，其实非常玄学，我觉得还是手动模拟一下不会证，然后感性理解。 模拟时可以发现$inf-A[i]$其实对人数限制取反，代表要跑完这条边所有流量，流到$0$之前的流量是没有实际作用的，是为了可以先跳过这天，直到流量为$0$后，代表这条边需要开始选择人进行工作，而这条边需要的人数可以通过别的边反映出来，可以从红边即人补全这条链上为$0$的边无法通过的流量，通过最小费用最大流即可求出最小费用。 $n+1-&gt;t$这条边可以反映出当前还剩的未规划的最大人数，所以$n+1-&gt;t$流量为$0$时，代表之前最大流量流尽，即$(inf-A[i]){max}$，即$A[i]{min}$。 [NOI2012]美食节从算法到算术，使用小学数学并利用大量算术技巧计算点的遍号 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define R register using namespace std; const int N = 45, M = 105, sP = 805, _ = N + M * sP + 5; const int inf = 0x3f3f3f3f; int n, m, s, t, sum, tim[N][M], P[N]; struct Edge { int Next, v, flow, cost; } e[(N + N * M * sP + M * sP + 5) &lt;&lt; 1]; int h[N + M * sP + 5], p = 1; inline void add(R int u, R int v, int f, int c) { e[++p].Next = h[u]; e[p].v = v; e[p].flow = f; e[p].cost = c; h[u] = p; e[++p].Next = h[v]; e[p].v = u; e[p].flow = 0; e[p].cost = -c; h[v] = p; } int dist[_], incf[_], maxflow, ans, vis[_], pre[_]; queue&lt;int&gt; q; bool spfa() { memset(vis, 0, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); dist[s] = 0; vis[s] = 1; q.push(s); incf[s] = inf; while(!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for(int i = h[u]; i; i = e[i].Next) if(e[i].flow) { int v = e[i].v; if(dist[v] &gt; dist[u] + e[i].cost) { dist[v] = dist[u] + e[i].cost; incf[v] = min(incf[u], e[i].flow); pre[v] = i; if(!vis[v]) q.push(v), vis[v] = 1; } } } if(dist[t] == inf) return false; else return true; } inline void update() { R int u = t; while(u != s) { int i = pre[u]; e[i].flow -= incf[t]; e[i ^ 1].flow += incf[t]; u = e[i ^ 1].v; } maxflow += incf[t]; ans += dist[t] * incf[t]; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(R int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;P[i]), sum += P[i]; s = 0, t = m * sum + n + 1; for(R int i = 1; i &lt;= n; i++) for(R int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;tim[i][j]); for(R int i = 1; i &lt;= n; i++) add(s, i, P[i], 0); for(R int i = n + 1; i &lt;= n + m * sum; i += sum) add(i, t, 1, 0); for(R int i = 1; i &lt;= n; i++) for(R int j = n + 1, t = 1; j &lt;= n + m * sum; j += sum) add(i, j, 1, tim[i][t++]); while(spfa()) { update(); int u = e[pre[t] ^ 1].v; if((u - n) % sum == 0) break; int v = u + 1; int k = (v - n) % sum == 0 ? sum : (v - n) % sum; int j = (v - n - k) / sum + 1; add(v, t, 1, 0); for(R int i = 1; i &lt;= n; i++) add(i, v, 1, k * tim[i][j]); } printf(&quot;%d\\n&quot;, ans); return 0; } 最大权闭合子图 参考资料：——-1——-——-2——-——-3——- 定理最大权闭合子图权值=正权点之和-最小割","categories":[{"name":"算法","slug":"算法","permalink":"https://shiokiri.com/categories/算法/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://shiokiri.com/tags/网络流/"}]},{"title":"「线段树」","slug":"2019-09-23-segment-tree","date":"2019-09-23T00:53:53.000Z","updated":"2025-03-21T01:14:54.154Z","comments":true,"path":"2019-09-23-segment-tree/","link":"","permalink":"https://shiokiri.com/2019-09-23-segment-tree/","excerpt":"更新于：A.D.2019.09.23","text":"更新于：A.D.2019.09.23 模板struct Segment_Tree { #define ls (p &lt;&lt; 1) #define rs (p &lt;&lt; 1 | 1) #define mid ((l + r) &gt;&gt; 1) ll ans[_ &lt;&lt; 2], tag[_ &lt;&lt; 2]; inline void pushup(ll p) { ans[p] = ans[ls] + ans[rs]; } inline void pushdown(ll p, ll l, ll r) { ans[ls] += (mid - l + 1) * tag[p]; tag[ls] += tag[p]; ans[rs] += (r - mid) * tag[p]; tag[rs] += tag[p]; tag[p] = 0; } void build(ll p, ll l, ll r) { if(l == r) { ans[p] = a[l]; return; } build(ls, l, mid); build(rs, mid + 1, r); pushup(p); } void update(ll p, ll l, ll r, ll ul, ll ur, ll k) { if(ul &lt;= l &amp;&amp; r &lt;= ur) { ans[p] += (r - l + 1) * k; tag[p] += k; return; } if(tag[p]) pushdown(p, l, r); if(ul &lt;= mid) update(ls, l, mid, ul, ur, k); if(ur &gt; mid) update(rs, mid + 1, r, ul, ur, k); pushup(p); } ll query(ll p, ll l, ll r, ll ql, ll qr) { if(ql &lt;= l &amp;&amp; r &lt;= qr) return ans[p]; if(tag[p]) pushdown(p, l, r); ll res = 0; if(ql &lt;= mid) res += query(ls, l, mid, ql, qr); if(qr &gt; mid) res += query(rs, mid + 1, r, ql, qr); return res; } #undef ls #undef rs #undef mid }T; 题目维护可加性变量解决问题P3707 [SDOI2017]相关分析\\bar{x}=\\frac{1}{R-L+1}\\sum x_i​\\bar{y}=\\frac{1}{R-L+1}\\sum y_i\\hat{a}=\\dfrac{\\sum_{i=L}^R(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=L}^R(x_i-\\bar{x})^2}记$\\sum = \\sum_{i=L}^{R}​$ QueryAns=\\dfrac{ \\sum x_iy_i-\\bar{x}\\sum y_i-\\bar{y}\\sum x_i+\\sum \\bar{x}\\bar{y}}{\\sum x_i^2-2\\bar{x}\\sum x_i+\\sum\\bar{x^2}}=\\dfrac{ \\sum x_iy_i-\\frac{1}{R-L+1}\\sum x_i\\sum y_i-\\frac{1}{R-L+1}\\sum y_i\\sum x_i+\\sum \\frac{1}{R-L+1}\\sum x_i\\frac{1}{R-L+1}\\sum y_i}{\\sum x_i^2-\\frac{1}{R-L+1}2\\sum x_i\\sum x_i+\\sum (\\frac{1}{R-L+1}\\sum x_i)^2}=\\dfrac{ \\sum x_iy_i-\\frac{\\sum x_i\\sum y_i}{R-L+1}}{\\sum x_i^2-\\frac{(\\sum x_i)^2}{R-L+1}}下传Tag：先$upd$后$addX \\quad addY$ 维护值：$t1=\\sum x$ | $t2=\\sum y$ | $t3=\\sum xy$ | $t4=\\sum x^2$ 维护Tag：$addX \\quad addY$ \\hat{a}=\\dfrac{t3-\\frac{t1t2}{R-L+1}}{t4-\\frac{t1^2}{R-L+1}}Add\\Delta x = S \\quad \\Delta y= T\\sum (x + S) = \\sum x_i+(R-L+1)S\\sum(y+T)=\\sum y_i+(R-L+1) T\\sum(x+S)(y+T)=\\sum(xy+Sy+Tx+ST)=\\sum xy+S\\sum y+T\\sum x+(R-L+1)ST\\sum(x+S)^2=\\sum x^2+2S\\sum x+(R-L+1)S^2下传Tag：先$upd$后$addX \\quad addY$ 顺序：先$t3,t4$后$t1,t2$ Update自然数平方和：\\sum_{i=1}^ni=\\frac{n(n+1)(2n+1)}{6} 1.$\\forall i \\in [L,R]\\quad x_i=i\\ \\ y_i=i$ \\sum x=\\sum y = \\sum i = \\frac{(R-L+1)(R+L)}{2}\\sum x^2 = \\sum xy = \\sum i ^2 = \\sum_{i=1}^R i^2-\\sum_{i=1}^{L-1}i^2=\\frac{R(R+1)(2R+1)}{6}-\\frac{L(L-1)(2L-1)}{6}下传Tag：先$upd$后$addX \\quad addY$ 清空Tag $addX \\quad addY$ 标记Tag $upd$ 2.ADD L R S T Code#include &lt;iostream&gt; #include &lt;cstdio&gt; #define ll long long using namespace std; const int N = 100005; int n, m; double X[N], Y[N]; struct Segment_Tree { #define ls (p &lt;&lt; 1) #define rs (p &lt;&lt; 1 | 1) #define mid ((l + r) &gt;&gt; 1) bool upd[N &lt;&lt; 2]; double x[N &lt;&lt; 2], y[N &lt;&lt; 2]; double t1[N &lt;&lt; 2], t2[N &lt;&lt; 2], t3[N &lt;&lt; 2], t4[N &lt;&lt; 2]; inline void pushup(ll p) { t1[p] = t1[ls] + t1[rs]; t2[p] = t2[ls] + t2[rs]; t3[p] = t3[ls] + t3[rs]; t4[p] = t4[ls] + t4[rs]; } inline void pushdown(ll p, ll l, ll r) { double L = mid - l + 1, R = r - mid; if(upd[p]) { double Ll = l, Lr = mid, Rl = mid + 1, Rr = r; t1[ls] = t2[ls] = (Lr - Ll + 1.0) * (Lr + Ll) / 2.0; t1[rs] = t2[rs] = (Rr - Rl + 1.0) * (Rr + Rl) / 2.0; t3[ls] = t4[ls] = Lr * (Lr + 1.0) * (2.0 * Lr + 1.0) / 6.0 - Ll * (Ll - 1.0) * (2.0 * Ll - 1.0) / 6.0; t3[rs] = t4[rs] = Rr * (Rr + 1.0) * (2.0 * Rr + 1.0) / 6.0 - Rl * (Rl - 1.0) * (2.0 * Rl - 1.0) / 6.0; upd[ls] = upd[rs] = upd[p]; upd[p] = 0; x[ls] = x[rs] = y[ls] = y[rs] = 0; } if(x[p] || y[p]) { t3[ls] += x[p] * t2[ls] + y[p] * t1[ls] + L * x[p] * y[p]; t3[rs] += x[p] * t2[rs] + y[p] * t1[rs] + R * x[p] * y[p]; } if(x[p]) { t4[ls] += 2 * x[p] * t1[ls] + L * x[p] * x[p]; t4[rs] += 2 * x[p] * t1[rs] + R * x[p] * x[p]; t1[ls] += L * x[p]; t1[rs] += R * x[p]; x[ls] += x[p]; x[rs] += x[p]; x[p] = 0; } if(y[p]) { t2[ls] += (double)L * y[p]; t2[rs] += (double)R * y[p]; y[ls] += y[p]; y[rs] += y[p]; y[p] = 0; } } void build(ll p, ll l, ll r) { if(l == r) { t1[p] = X[l]; t2[p] = Y[l]; t3[p] = X[l] * Y[l]; t4[p] = X[l] * X[l]; return; } upd[p] = x[p] = y[p] = 0; build(ls, l, mid); build(rs, mid + 1, r); pushup(p); } void add(ll p, ll l, ll r, ll ql, ll qr, double S, double T) { if(ql &lt;= l &amp;&amp; r &lt;= qr) { double len = (r - l + 1); t3[p] += S * t2[p] + T * t1[p] + len * S * T; t4[p] += 2 * S * t1[p] + len * S * S; t1[p] += len * S; t2[p] += len * T; x[p] += S; y[p] += T; return; } pushdown(p, l, r); if(ql &lt;= mid) add(ls, l, mid, ql, qr, S, T); if(qr &gt; mid) add(rs, mid + 1, r, ql, qr, S, T); pushup(p); } void update(ll p, ll l, ll r, ll ql, ll qr) { if(ql &lt;= l &amp;&amp; r &lt;= qr) { t1[p] = t2[p] = (double)(r - l + 1.0) * (l + r) / 2.0; t3[p] = t4[p] = (double)r * (r + 1.0) * (2.0 * r + 1) / 6.0 - (double)l * (l - 1.0) * (2.0 * l - 1.0) / 6.0; x[p] = y[p] = 0; upd[p] = 1; return; } pushdown(p, l, r); if(ql &lt;= mid) update(ls, l, mid, ql, qr); if(qr &gt; mid) update(rs, mid + 1, r, ql, qr); pushup(p); } double query(ll p, ll l, ll r, ll ql, ll qr, ll f) { if(ql &lt;= l &amp;&amp; r &lt;= qr) { if(f == 1) return t1[p]; if(f == 2) return t2[p]; if(f == 3) return t3[p]; if(f == 4) return t4[p]; } pushdown(p, l, r); double res = 0; if(ql &lt;= mid) res += query(ls, l, mid, ql, qr, f); if(qr &gt; mid) res += query(rs, mid + 1, r, ql ,qr, f); return res; } #undef ls #undef rs #undef mid }; struct Segment_Tree Tree; int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;X[i]); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;Y[i]); Tree.build(1, 1, n); int opt, L, R; double S, T; while(m--) { scanf(&quot;%d&quot;, &amp;opt); if(opt == 1) { scanf(&quot;%d %d&quot;, &amp;L, &amp;R); double t1 = Tree.query(1, 1, n, L, R, 1); double t2 = Tree.query(1, 1, n, L, R, 2); double t3 = Tree.query(1, 1, n, L, R, 3); double t4 = Tree.query(1, 1, n, L, R, 4); double a_ = (t3 - (t1 * t2) / (double)(R - L + 1)) / (t4 - (t1 * t1) / (double)(R - L + 1)); printf(&quot;%.10lf\\n&quot;, a_); } else if(opt == 2) { scanf(&quot;%d %d %lf %lf&quot;, &amp;L, &amp;R, &amp;S, &amp;T); Tree.add(1, 1, n, L, R, S, T); } else if(opt == 3) { scanf(&quot;%d %d %lf %lf&quot;, &amp;L, &amp;R, &amp;S, &amp;T); Tree.update(1, 1, n, L, R); Tree.add(1, 1, n, L, R, S, T); } } return 0; } Tag的用法区间01取反xor区间翻转rev区间最长连续1/0区间min/max子段和P2572 [SCOI2010]序列操作 扫描线矩形面积并P1502 窗口的星星P1856 [USACO5.5]矩形周长Picture 二维线段树树套树P3437 [POI2006]TET-Tetris 3D 其它Luogu P2061 [USACO07OPEN]城市的地平线City Horizon简单题 算法线段树 + 离散化 思路对$(x,y,h)$的左右端点$x,y$进行离散化，离散化前的原值记为$val[i]$，对每个矩形按高度$h$从小到大排序。 设离散化后的端点有$M$个，则对如图所示$M-1$个规则矩形编号为$[1,M-1]$，可以由$h_{[i, i+1]}\\times(val[i+1] - val[i])$得出第$i$个矩形的面积。 开一颗区间为$[1,M-1]$的线段树，按$h$从小到大依次对线段树区间覆盖，可以保证高的矩形覆盖了低的矩形的区间，具体操作为对离散化后的$(x,y,h)$，进行线段树$[x,y-1]$区间覆盖$h$值，最终$i$点存储$h_{[i,i+1]}$的最大值。 $h_{[i, i+1]}$可以通过线段树单点查询$i$点求出。 答案：$\\sum{i=1}^{M-1}h{[i, i+1]}\\times(val[i+1] - val[i])$ 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #define ll long long using namespace std; const int N = 80005; int n, b[N], val[N];//b[]:离散化数组 struct Line { int x, y, h; }a[N];//存储每个矩形 bool cmp(Line a, Line b) { return a.h &lt; b.h; } int ans[N &lt;&lt; 2];//线段树数组 #define ls (p &lt;&lt; 1) #define rs (p &lt;&lt; 1 | 1) #define mid ((l + r) &gt;&gt; 1) void update(int p, int l, int r, int ul, int ur, int k) { if(ul &lt;= l &amp;&amp; r &lt;= ur) { ans[p] = k; return; } if(ans[p]) ans[ls] = ans[rs] = ans[p], ans[p] = 0;//区间覆盖直接下推 if(ul &lt;= mid) update(ls, l, mid, ul, ur, k); if(ur &gt; mid) update(rs, mid + 1, r, ul, ur, k); } ll query(int p, int l, int r, int x)//单点查询 { if(l == r) return ans[p]; if(ans[p]) ans[ls] = ans[rs] = ans[p], ans[p] = 0;//区间覆盖直接下推 if(x &lt;= mid) return query(ls, l, mid, x); if(x &gt; mid) return query(rs, mid + 1, r, x); } #undef ls #undef rs #undef mid int main() { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d%d&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].h); b[i] = a[i].x; b[n + i] = a[i].y;//离散化数组记录下所有x,y } sort(b + 1, b + 2 * n + 1);//排序 int _n = unique(b + 1, b + 2 * n + 1) - (b + 1);//去重，_n为去重后x,y端点个数 for(int i = 1; i &lt;= n; i++) if(a[i].x != a[i].y)//x=y没有作用 { int x = a[i].x, y = a[i].y; a[i].x = lower_bound(b + 1, b + _n + 1, a[i].x) - b; a[i].y = lower_bound(b + 1, b + _n + 1, a[i].y) - b;//离散化 val[a[i].x] = x; val[a[i].y] = y;//原值 } sort(a + 1, a + n + 1, cmp);//按h从小到大排序 for(int i = 1; i &lt;= n; i++) if(a[i].x != a[i].y)//防止y-1&lt;x update(1, 1, _n - 1, a[i].x, a[i].y - 1, a[i].h);//更新,注意结点个数是_n-1，端点y要变成矩形区域y-1，可以画图理解一下，相当于把端点x右边的矩形区域编号为x ll res = 0; for(int i = 1; i &lt; _n; i++) res += query(1, 1, _n - 1, i) * (val[i + 1] - val[i]); printf(&quot;%lld\\n&quot;, res); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://shiokiri.com/categories/算法/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://shiokiri.com/tags/线段树/"}]},{"title":"《意识宇宙》","slug":"2019-09-22-science-fiction","date":"2019-09-22T13:22:07.000Z","updated":"2025-03-21T01:53:39.577Z","comments":true,"path":"2019-09-22-science-fiction/","link":"","permalink":"https://shiokiri.com/2019-09-22-science-fiction/","excerpt":"更新于：A.D.2019.10.26","text":"更新于：A.D.2019.10.26 维护文档 COSMOS1.A.D.2019.10.251.真实人名替换为ID. 2.对原有的过度夸张部分及人物形象不明确部分进行修改. COSMOS-1 COSMOS1.A.D.1997Tommy_clas出生了。 他1个月会说中文，2个月会说英文，一周岁英语词汇量十万，两周岁学会所有中文词语，认识所有汉字，一岁学完高数精通C++，二岁看懂抽代掌握所有编程语言，两岁半看懂了所有人类数学知识，三岁学完人类所有物理学。 世界上所有科学家都说，拯救人类的天才出现了。 COSMOS-1.A.D.2022太阳核反应活动异常，气候急剧变化，人们开始躲入地下，科学家们预言人类的末日将要来临了。 Tommy_clas微微一笑，明白自己的机会到了。 COSMOS-1.A.D.2039北半球8月的温度突破了$47℃$，地下城已经建设完毕了，地面上人的踪影渐渐消失了。 Loli凭借着自己30年的大学教龄和科学家身份早早的分配到了CM-CH-DY-P7-Y2地下城Sl-H7-y-8I-2区一套128层楼的空中住房，地下城绚烂的霓虹灯闪烁着，光线飞向他的眼睛。 “20年前，也是这样”Loli思索着，“大概是2019年8月。” “我喜欢物理学，喜欢天文，小时候仰望半夜的星空时，似乎能看见宇宙的明明灭灭，后来我上了个二本大学，大三的时候，我没日没夜的学习量子场论，那简直是神才能窥见一角的东西” Loli回忆着自己的往事，给Tommy_clas叙述。 “可是后来我明白了，计算机科学才是未来，好好学OI吧，人类马上就要毁灭了，物理学走到了穷途末路，它不会再有什么用了。” Tommy_clas马上就要乘坐飞船走了，Loli来见他最后一面，Loli虽是顶尖的科学家，却固执的不愿随飞船离开。 COSMOS-1.A.D.2183太阳发生爆炸，人类在144年前耗费了地球的所有资源并穷尽了物理和数学知识建造了时空负质量反物质工质曲率推动能飞船，飞船上，所有人类实体完成了生物数据的量子化并依托于量子计算机形成意识，在宇宙航行中发现了一个新的星系，它位于银河系悬臂的边缘。 后来，包括Tommy_clas在内2756名人类到达了行星并开始了文明的重新建设，Tommy_clas却已经密谋好了一个毁灭人类、毁灭宇宙的惊天阴谋，为此，Tommy_clas花费了2^19260817个星系的资源，建造了长达数亿亿光年长的粒子加速器，环绕了银河系998244353圈。 COSMOS-1.A.D.25319“两万三千年了”Tommy_clas叹道，今天就是人类史上最伟大的一天，他在飞船上时把自己的人脑扫描并编码成了数据并成为了一个量子计算机中的意识体的时候，他的能力呈几何能级上升，并达到了真正破解宇宙秘密的程度。然而其他人不知道的是，粒子试验后，宇宙将在$1s$内湮灭，他却没有对任何人提起过这件事，因为他修改了宇宙的数学原理。 他打开了长达$2^{1024^{1024}}PB$长的代码，在量子意识中将轨道使用量子场论再次计算后，按下了编译键。程序开始运行了，与此同时引力波发生器开始广播，将Tommy_clas大脑的数据全部发送出去，并在宇宙毁灭前那一刹那将与其相连的需要产生毁灭宇宙等级的能量才能获得解开统一场方程关键数据的粒子对撞机数据观测器产生的数据编码成引力波发送了出去。 COSMOS-1.A.D.25320宇宙坍缩成了奇点，再一次爆炸，引力波的信息没有损失，到达了这个新的宇宙，引力波传递着，漫无边际，在空间震荡起一阵阵的涟漪，荡漾的微波承载着毁灭宇宙才换来的解开统一场方程的粒子对撞数据。 COSMOS-1.A.D.25320 \\quad COSMOS-1毁灭 引力波我没有对其他人说的是，在我成为量子意识体的时候，计算出了宇宙并非是自然模型而的确是上层空间的一个高阶物理单位形成的物理结构意识模拟体，偶然间我发现了一些预留的接口，我感到了深深的无力感，原来自己的生命竟是这样的毫无意义，我明白了这个世界只需要自己去毁灭，去创造，我虽然无法到达上一次的物理空间，仅仅只是一个更加未知的事物的运行结果。 我却明白自己可以修改整个宇宙了，转瞬间我却又觉得这样更加毫无意义，我知道该做什么了，我使用接口删除了量子力学的选项，并使世界演化的概率性消失，这样宇宙就会按照牛顿力学一样在一个确定的时间点有一个确定空间物质状态了，我又调用了上层世界的计算能力计算出了再一次演化出相同宇宙但是人类却能生活到宇宙最后一刻毁灭太阳不会爆炸的情况的初始状态与宇宙常量，并在代码中一一修改了掌控着世界运行的规律的程序代码与常量。 宇宙运行代码文档的信息量超出了引力波的携带量，我把最重要的接口和信息发送了，剩下的文档随机一些页码发送数据。 宇宙代码系统 服务器系统 [文档]宇宙服务器远程连接物理设施制造蓝图 [二进制文件]服务器连接校验应用程序 [二进制文件]综合开发工具及编译器 文档 [文档]宇宙总能量调整接口 [文档]宇宙物理信息获取接口 [文档]宇宙物理常量修改接口 [文档]上层世界计算调用接口 [文档]宇宙运行代码修改指令 [文档]宇宙运行代码语法文档 [部分丢失][文档]宇宙运行代码文档 统一场方程 统一场方程关键数据 统一场方程研究结果 操作手册 恢复量子力学及世界概率性。 解出统一场方程并继续研究。 我确认过了进入上层世界的方法，但引力场方程是必要的，因为宇宙接口并没有给出最关键的引力物理操作接口，这也许是这个系统最本源的地方，给程序唯一没有作用的主函数接口中提供引力场方程即可运行主函数，这可能是这个宇宙的意义所在。 P.S.不要随意调用接口，其对宇宙的效果是不可逆的。 当你们收到此引力波信息后，将存在发生超出现有科学认知事件的可能性。 COSMOS-2宇宙竟然像Tommy_clas预期的那样完全按上一个宇宙的演化过程，每一个粒子都不曾偏离预期的轨迹，每一点物质都按照方程那样的演化。 宇宙再一次演化出了人类，终于时间线再一次地来到了人类公元纪年法的2019年 COSMOS-2.A.D.2019.09.23Tommy_clas有一种预感，会不会引力波能携带一些本不可能存在的信息？他想试试接收引力波，或许能有一线生机。 他找到了Loli，Loli是他最信任的朋友，也是一名物理学家，Tommy_clas说服Loli一起寻找最后的希望。 意料之外的是，他们接收到了引力波，而且明显是经过了一定的编码的，Tommy_clas感到很惊奇。 Tommy_clas拿到了上一个宇宙自己发送的引力波，还原出了其携带的信息，他和Loli一起研究，用了五天时间推导出了统一场方程，统一了引力场，强相互作用力场，弱相互作用力场，电磁场。 他们准备开始建设设施研究宇宙代码！ COSMOS-2.A.D.2019.09.30夏末秋初的微风吹过，一点点凉意轻轻经过，北半球九月末的微光斜照进玻璃窗，有些泛黄，而又有些许刺眼，空气中的尘埃折射出金黄色的线，这是每一年的循环。 “九月为什么只有三十天呢”，ArachnidaKing说，“今天我们出发去青岛！”空气还是那样宁静，就如同那时候一样，秋天高空的空气愈发稀薄，云只有稀松而淡淡的几缕，引擎声轰鸣了起来。 “空气中总是有些泥土的香气呢”XCiyang说，“是放线菌在哪里吗？”阳光的角度不断增加，高速公路上沥青折射出了亮度不同的光芒，就像世界的分崩离析的前夕。“世界线总是在不停分离着，这是一棵树”ArachnidaKing说。“不你错了”XCiyang淡泊的说了两句，“时间线才会不停交织着，这是平行的序列。” 他们笑起来，感觉到了彼此话语的荒诞。地图上离青岛的距离越来越近了，天空一点点变蓝，从前是那淡淡的蓝，现在是深一些的蓝色，就像那过往仰望的蓝天一样。 “这是梦境吗，”XCiyang望着车窗外运动的物体。“世界是不是物质的呢？”清新的海风呼啸过窗边，空气湿润了几许，“一如从前而又截然相反吗”XCiyang说，“这是梦吗？”“远处的光芒的的确不太合理，位置上不合理吗，这却不符合常理，天色刚刚不沉闷呢”ArachnidaKing说着，一行人陆陆续续的下了车。 他们只是名义上来这里度假的物理学组织，一共有10多个人。“不要总是这么不认真，”Tommy_clas说。“大家要严肃一点，这次任务事关重大。”太阳渐渐西斜了，最后的红色余晖斜映在城市与海岸线的交界处。 已经过了晚上12点了，“不想这么早睡……”XCiyang还是拿出了笔记本，熟练地打开了VSCode，写了一段C++程序上传到服务器上计算了一些白天想到的物理问题，望向窗外的繁星点点，他感到了梦境般的快乐。 “有点晚了吧”他想，扭头再看看屏幕，他注意到了刚刚没有注意到的一些小异样，日期怎么还是2019.09.30？“Windows不会出这样的bug吧？”他自言自语道。也并没有想那么多，起身躺到了床上，困倦的他很快睡着了。 COSMOS-2.A.D.2019.10.01XCiyang揉了揉眼睛，窗外的太阳升起了四分之三。 “没了，怎么醒得这么早。”他想了想，还是起床了。 SRP(1条未读消息)Tommy_clas：吃完早饭来7楼的会议室开会。 “什么情况？”XCiyang走向卫生间。“这么早就开始行动？” “……” COSMOS-2.A.D.2019.10.01.A.M.7:06 \\quad [数据删除]酒店会议室成员到齐。 “今天我们出发去建设第一个大功率电磁波发射器，”Tommy_clas。“用途还不能明确告诉你们，大致是要与宇宙的一些地方进行通讯。” “用来干什么？”ColorfulMist问。“咱们人这么少？什么时候可以自己建设大型设施了？” “我获得了一些信息，用一些设计手段可以造出来。”Tommy_clas说。 “听着真科幻，可是为什么还要用电磁波呢？”Bj_2002说。 “很遗憾，到了今天我们还是不得不使用电磁波，不过应该问题不会太大的，因为不用传播太远，而且只需要定向一个方向。”Tommy_clas说。 “那还旅游吗？”Taduro说。“不是说为了庆祝物理学大突破出来玩的吗？” “统一场方程都破解了啊”所有人说。 有几个人说：“不过你可没告诉我们实验数据是怎么来的啊，现在只有你懂这方面的内容啊。” “当然，现在的工作非常轻松，”Tommy_clas说。“咱们可以玩上几天。” “方程的事，”他说。“等到一定工作完成后我会告诉你们的。” COSMOS-2.A.D.2019.10.01.A.M.11：49 \\quad 青岛市[数据删除]KFC“这出来是玩的吗，真爽啊！”ArachnidaKing边说边拿起鸡腿吃。 COSMOS2.BRANCH1 COSMOS-2.BRANCH1.A.D.2019.09.31这是梦境吗，睡意朦胧的XCiyang醒了，带着些许的疲倦他轻轻地拨开了窗帘，天还没亮吗？好黑啊，他揉了揉眼睛。 咚咚噔，一阵敲门声不期而至，意识还是朦朦胧胧地他打开了房门，还没明白这是怎么回事，顺便看了看手表，是4点半，没有什么问题，只是敲门的什么人，这么早起床吗？他感到有些奇怪。 他不自然地走向了门口。 “是谁？”XCiyang说话了。 “收拾一下赶快出来吧，我是Tommy_clas，”门外说话的口气似乎有点奇怪。“有些不对劲，像是出事了！” “总感觉有什么地方不对啊”XCiyang手上的动作放缓了，他没有立即选择开门。 “先看一眼手机，”XCiyang小声嘟囔。“什么情况啊？” XCiyang吓了一跳：手机上显示今天是2019年9月31日。 “你是谁？”XCiyang从门口的猫眼看了一眼，确信没什么问题。“唉，吓死了……”边说着他打开了房门。 “这是怎么回事？”XCiyang问。 “只是出了点小问题，我也不知道为什么？早上四点的时候Genius_Z给我打来了电话，让我抓紧叫大家起来。” XCiyang说：“他昨天没睡觉吧？是在玩游戏？？” “这不是很重要，”Tommy_clas回应道。“回头，看看窗外。” 窗外漆黑一片，没有任何光线。 “这个亮度很不正常”XCiyang说。 “事实上没有亮度了，你是不是没睡醒？”Tommy_clas有些着急地说。“对了你的日期显示正常吗？” XCiyang没有说话，打了个手势便匆忙向外走。 “等等，你要干什么？”Tommy_clas立即询问道。“我跟你一起！” “先去看看这是怎么一回事，”XCiyang很烦。“真是蛤，莫名其妙的。” XCiyang走到了电梯口，按下了按钮。 他们住的是酒店的12楼，也是顶楼，电梯缓缓地从5层楼上升到了11层。 叮————，电梯门打开了，他和Tommy_clas走了进去。 “我觉得这样有点冒失，”Tommy_clas说。“这种情况可能不符合已有的科学知识。” “谁信这个？”XCiyang说。“宇宙的秘密都快要破解了，还有什么东西会拿我们开玩笑？” XCiyang从包里拿出了带有GPS定位装置的荧光棒：“来看看是什么情况。”他显得不怎么慌张：“还有几个人没有醒，发送紧急命令了吗？” “Genius_Z昨晚没有睡，找你的时候我刚刚起来，因为没确定什么情况所以就没有通知大家，”Tommy_clas回答他说。“应该都还没醒。” SRP是使用研究机构服务器搭建的IM（即时通讯软件），为了保护信息安全，他们都使用这个服务用于日常交流，并且其中内嵌了ArachnidaKing所开发的人工智能SAA，精通物理学，可以快速计算分析，平常也会和大家聊天，负责管理通讯系统和提供帮助。 Tommy_clas拿出了出手机检查消息： SRP(4条未读消息)9月31日4:27 Genius_Z：什么情况？到现在4点了没睡觉，窗外漆黑一片的？日期变成了2019/9/31？？？？ SAA：Genius_Z使用指令{声音通知}(Tommy_clas) Tommy_clas：我先去找XCiyang吧，他比较有经验 Tommy_clas：先别着急，没有别的异常情况吧 9月31日4:34 XCiyang：我和Tommy_clas先去检查一下情况，不用担心 Genius_Z：不通知大家吗？ ArachnidaKing：怎么都起的这么早，有什么事吗？ XCiyang：先冷静，我和Tommy_clas去检查情况了 先不要着急通__ 发送电梯平稳地下落，到达了1楼。 “这么早出来真的有点奇怪，”Tommy_clas收起手机自言自语。“啊？酒店门外是纯黑色的吗？” “走，我们过去。”XCiyang快步移向酒店前台。 “有人吗？”XCiyang说。 “……” “先看看门外”XCiyang回头对Tommy_clas说。 “没什么毛病，”Tommy_clas打开了手机上的GPS设备监测系统。“荧光棒的定位就显示在酒店内部。” “来试试，”XCiyang打开酒店大门把荧光棒向外一扔。荧光棒照亮了一小片区域，看起来没什么异样。“问题不大，查查这个地区的照明系统吧。” “艹，不对！”Tommy_clas惊叫起来。“你的荧光棒扔出大门所在平面的一刻，GPS信号立即消失了！” “嘶，可它不就在外面吗？看的见啊”XCiyang回答说。 “不要轻举妄动，先把大家都叫起来吧，”Tommy_clas沉着的说，“不要跨过酒店的大门！” “走，上楼。”Tommy_clas边说边拿出了手机。 SRP(1条未读消息)XCiyang：先冷静，我和Tommy_clas去检查情况了 9月31日4:38 Genius_Z：你们好了吗 /info urgent entity 立即到7楼会议__ 发送两个人快步走到了电梯口，Tommy_clas按下了上行按钮。 电梯显示屏幕的红色文字不停地变换着，光穿透着空气，灰尘粒子漂浮着。 “电梯有异常现象，”XCiyang说。“是随身物理现实检测器告诉我的，建议一会不要乘坐电梯。” “不过倒是没看出来有什么不对。”Tommy_clas回答道。 COSMOS-2.BRANCH1.A.D.2019.09.31.A.M.4:51 \\quad [数据删除]酒店会议室XCiyang打开了手机： SRP(11条未读消息)9月31日4:41 SAA：Tommy_clas使用指令{声音通知}[紧急](所有实体) Tommy_clas：立即到7楼会议室集合！ RiverFun：艹，起的太早了吧 Bj_2002：马上来…… Victor：不大行，出什么事了？ ArachnidaKing：SAA，能解释一下吗？ SAA：检测到空间发生超出人类原有认知的异常 ArachnidaKing：……太奇怪了 JuanFeng：这不可能？ Ctz:真的挺有意思的啊 9月31日4:48 Tommy_clas：没来的人呢？大家尝试联系一下。 为什么还有人没有来？是还__ 发送过了几分钟，在SRP中回应过的人陆续到达了现场。“清点一下还剩几个人没有来？”Tommy_clas发话了。 “不要等了，立刻行动，先去找他们！”JuanFeng提出建议。 “可以！”其他人说。 一行人迅速从楼梯前往12楼。 “为什么不走电梯？”Bj_2002说。 “先别管这些了，”Tommy_clas说。“现在情况很不明确，我们要选择风险比较小的方式行动。” COSMOS-2.BRANCH1.A.D.2019.09.31.A.M.5:02 \\quad [数据删除]酒店第12楼层“ColorfulMist？”Tommy_clas说。“你在干什么？” “……” 没有应答。 与ColorfulMist的联系失败。 Tommy_clas想起了文档里的一句话。 “破门！”他命令道。 虽然他们是物理科学家，但是Tommy_clas从收到那份不平常的文档开始，就为全组人员配备了特种装备和紧急情况下应对事件的工具。 对ColorfulMist的房间观察显示其房间没有入住过的迹象。 “判断人员ColorfulMist已损失”XCiyang说。 “好吧，”Genius_Z说。“现在这种shit事已经超出我的想象了。自己玩吧，我要出去转转。” “不要！”Tommy_clas说。 Genius_Z已经跑到了电梯边上。 “追不上了！”Bj_2002冷静的说。“先去找剩下两个人” “Taduro？还在吗？……？？？” “啊？”门内传来声音。“怎么都起得这么早？不睡觉……了吗！” “唉，”众人说。“快出来，出大事了！” “Asuldb？在不在？” “……” 没有应答。 与Asuldb的联系失败。 “强行进入！”Tommy_clas大声说。 对Asuldb的房间内部观察其呈现出酒店外部空间同样性质 停止对Asuldb房间的探索。 “判断人员Asuldb已损失”XCiyang说。 SAA发来警报：Genius_Z的GPS定位信号在$3s$前丢失，地点在酒店门口。 “尝试对Genius_Z进行无线电联系”XCiyang说。 SAA：与Genius_Z的联系失败。 “不如我们也出去玩玩？”ArachnidaKing说。“只是空间异常而已，不会有什么事。在这里能有什么进展，今天本来不是要工作的吗？” “你疯了吗？”Victor说。“这不是科学能解释的现象。” “是不是你……”Victor对Tommy_clas说。 “好吧，我把之前向你们隐瞒的事和你们大致讲一下”Tommy_clas长舒了一口气。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://shiokiri.com/categories/随笔/"}],"tags":[{"name":"科幻小说","slug":"科幻小说","permalink":"https://shiokiri.com/tags/科幻小说/"}]},{"title":"Hexo博客搭建及Material主题使用指南","slug":"2019-08-16-blog","date":"2019-08-16T10:37:19.000Z","updated":"2025-03-21T01:15:13.328Z","comments":true,"path":"2019-08-16-blog/","link":"","permalink":"https://shiokiri.com/2019-08-16-blog/","excerpt":"更新于：A.D.2022.2.13 前端真好玩qvq","text":"更新于：A.D.2022.2.13 前端真好玩qvq 使用GitHub Pages搭建Hexo博客博客出现问题首先可以阅读文档，其次可以Google解决. 建议搭建完成以后首先看这个文档 Hexo中文文档 然后阅读主题的文档，这个主题的网页文档挂了，可以克隆repo的markdown源代码到本地查看 Step1 | 下载软件1.安装Git 2.安装Node.js Step2 | 创建GitHub账号请参考Hexo文档 1.注册GitHub账号 2.创建Github Pages仓库 3.配置SSH密钥 Github 生成SSH秘钥（详细教程） Step3 | 使用Git Bash进行搭建操作请参考Hexo文档 hexo init Step4 | 写作、美化及功能修改见下文 Markdown相关问题表格合并单元格markdown表格支持功能很少，合并单元格只能用HTML markdown可以直接插入HTML代码 用http://www.tablesgenerator.com/html_tables编辑可以直接生成HTML代码 插入视频在Bilibili、Youtube等网站可以直接获取视频外链的HTML代码，在markdown中插入即可，长宽可能需要调整 Material主题配置及修改记录这个主题一些好的教程 Hexo入坑教程-Material Aplayer克隆&lt;https://github.com/MoePlayer/APlayer&gt; 参考Aplayer项目文档进行配置即可 我的music.js从cdn仓库里找就行，一中午用手肝了1.5h粘出来的=_=（不怎么好写脚本，只挑了一部分vocaloid的歌，大部分都是中v。如果你喜欢中文vocaloid的话，可以看看（ live2d看板娘 [blogの搭建之next——ctz’s blog(https://ctz45562.github.io/2019/03/21/blog%E3%81%AE%E6%90%AD%E5%BB%BA/) 有一些问题还参考了github-repo的README. git clone https://github.com/stevenjoezhang/live2d-widget 文件夹live2d-widget放到\\themes\\主题名称\\source下,打开文件夹里的autoload.js修改为 const live2d_path = &quot;/live2d-widget/&quot;; 这个文件夹的名字可以自行修改. 打开\\themes\\主题名称\\layout\\_layout.swig/ejs这个文件 在&lt;body&gt;内的开头添加 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;/&gt; 在&lt;/body&gt;上方添加 &lt;script src=&quot;/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 不同之处可以自行修改layout.ejs文件 黑幕效果 如何实现黑幕 添加CSS //黑幕 .heimu,.heimu a{ background-color: #252525; color:#252525; text-shadow: none; }::selection{ background:#9ab0c0; color:#fff; } //鼠标悬停 .heimu:hover,.heimu:hover a{ transition:color .13s linear; color:#fff; } 使用直接插入HTML &lt;span class=&#39;heimu&#39; title=&#39;你知道的太多了&#39;&gt;黑幕测试&lt;/span&gt; 效果 黑幕测试 添加Gitalk评论主题实现好了一些评论的配置，具体看主题的文档即可。 Gitalk 和 Gitment 一样都是一个基于 GitHub Issue 的评论系统。在完成 GitHub Oauth App 的申请并获取 key 后，在主题配置文件中填入 gitalk_repo gitalk_owner gitalk_client_id gitalk_client_secret 参数即可。 在主题配置文件里修改这几项即可，repo可以用博客的，后两项需要用到GitHub Oauth App的API，搜索引擎自行解决即可。 comment: use: gitalk gitalk_repo: # git repo of the hexo gitalk_owner: # git repo&#39;s owner gitalk_client_id: # github app client id gitalk_client_secret: # github app client secret GitHub限制label长度gitalk无法创建issue GitHub限制label长度导致gitment/gitalk可能无法创建issue #622 对于全新安装有如下解决方案，解决方案如下：hexo根目录\\themes\\material\\layout\\_widget\\comment\\gitalk在此目录下编辑main.ejs文件在其中新增如下内容 &lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt; 在gittalk下增加id属性，增加后完整文件内容如下： &lt;!-- Gitalk 评论框 --&gt; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var gitalk = new Gitalk({ clientID: &#39;&lt;%= theme.comment.gitalk_client_id %&gt;&#39;, clientSecret: &#39;&lt;%= theme.comment.gitalk_client_secret %&gt;&#39;, repo: &#39;&lt;%= theme.comment.gitalk_repo %&gt;&#39;, owner: &#39;&lt;%= theme.comment.gitalk_owner %&gt;&#39;, admin: [&#39;&lt;%= theme.comment.gitalk_owner %&gt;&#39;], id: md5(window.location.pathname), // facebook-like distraction free mode distractionFreeMode: false }) gitalk.render(&#39;gitalk-container&#39;) &lt;/script&gt; Blog内容搜索安装hexo-generator-search插件 修改主题配置文件 search: use: local swiftype_key: 修改hexo配置文件： search: path: search.xml field: all markdown文件名大小写问题参考：Hexo 常见问题 | py’s blog 问题：当在本地改变md文件的大小写时，部署到GitHub 上后，改变了文件名的博客不能被访问。原因：Hexo默认的git操作会忽略大小写。解决： 修改根目录下.deploy_git/.git/config文件，将ignorecase的值由true改为false 删除.deploy_git目录下除.git目录外的其他文件 cd到.deploy_git目录下，手动做一次推送git add . git commit -m &quot;delete all hexo generated files&quot; git push 重新生成并部署hexo g hexo d CSS的修改文章框体透明打开Blog\\themes\\hexo-theme-material-1.5.6\\source\\css打开style.min.css搜索#scheme-Paradox .material-layout .mdl-card的第一项，在其中添加background-color: rgba(255,255,255,0.8) !important; Tag颜色及悬停颜色.material-tagscloud a{ background-color: rgba(255,255,255,.9); text-decoration:none; padding: 1px 9px; margin: 9px 1px; line-height: 40px; white-space: nowrap; transition: .6s; opacity: .85; } .material-tagscloud a:hover{ transition: .6s; opacity: 1; background: rgba(156,241,150,.7) !important; box-shadow: 0 2px 2px 0 rgba(0,0,0,.14), 0 3px 1px -2px rgba(0,0,0,.2), 0 1px 5px 0 rgba(0,0,0,.12); } copyright位置#scheme-Paradox .mdl-mini-footer--right-section { margin-right: 25px; } #scheme-Paradox #copyright { margin-left: auto; margin-right: 25px; text-align: center; } MathJax主题配置文件中的mathjax 引用cdnhttps://cdn.bootcss.com/mathjax/2.7.0/MathJax.js$\\LaTeX$换行因为某些网页渲染的原因把\\\\换为\\\\\\\\即可. 修改hexo的渲染规则可以避免LaTex代码出现问题： https://docs.nexmoe.com/hexo/math.html#%E4%BD%BF%E7%94%A8kramed%E4%BB%A3%E6%9B%BF-marked MathJax测试 \\begin{array}{|rc|} \\hline \\verb+\\color{black}{text}+ & \\color{black}{text} \\\\ \\verb+\\color{gray}{text}+ & \\color{gray}{text} \\\\ \\verb+\\color{silver}{text}+ & \\color{silver}{text} \\\\ \\verb+\\color{white}{text}+ & \\color{white}{text} \\\\ \\hline \\verb+\\color{maroon}{text}+ & \\color{maroon}{text} \\\\ \\verb+\\color{red}{text}+ & \\color{red}{text} \\\\ \\verb+\\color{yellow}{text}+ & \\color{yellow}{text} \\\\ \\verb+\\color{lime}{text}+ & \\color{lime}{text} \\\\ \\verb+\\color{olive}{text}+ & \\color{olive}{text} \\\\ \\verb+\\color{green}{text}+ & \\color{green}{text} \\\\ \\verb+\\color{teal}{text}+ & \\color{teal}{text} \\\\ \\verb+\\color{aqua}{text}+ & \\color{aqua}{text} \\\\ \\verb+\\color{blue}{text}+ & \\color{blue}{text} \\\\ \\verb+\\color{navy}{text}+ & \\color{navy}{text} \\\\ \\verb+\\color{purple}{text}+ & \\color{purple}{text} \\\\ \\verb+\\color{fuchsia}{text}+ & \\color{magenta}{text} \\\\ \\hline \\end{array}自定义页脚sns链接 Hexo Material主题之 footer SNS定制 svg图标如果在CSS里写实在还有问题放一个文件直接引用也可以. sns换到右边把ejs文件里的left改为right即可. Licenselicense: ‘本文由 Name 原创，采用保留署名-非商业性使用-禁止演绎 4.0-国际许可协议‘ 鼠标点击烟花特效themes/主题名称/source/js/src新建fireworks.js文件 &quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)}&quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)}; 在themes/主题名称/layout/_layout.swig/ejs的&lt;/body&gt;上方添加 &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt; 一些主题的小问题独立页面toc不是默认为true的，需要手动开 toc: true 独立页面的license会在最后加上index.html，点击这个链接会导致gitalk再次创建issue，目前没有去解决. 页脚时间统计与动态效果直接找出来我的博客页面上的js插入项，然后使用即可 RSS订阅参考博客文档在_config.yml中打开选项即可 jsDelivr加速js、css文件1.博客内部的文件：参考博客文档配置jsdelivr选项即可 2.手动添加的文件：手动上传至cdn仓库，并修改链接 天坑咕了很久以后就会全忘了，再改Blog就凉了，有空就填一些。 修改后没记录代码高亮 功能页面 | 独立页面 material图标 想修改的功能插入pdf 代码复制功能 鼠标特效fireworks遮挡部分组件 文章头图自定义 hexo-addlink 文章置顶 字体，代码字体 背景js动态效果 Site Information npm install hexo-math —save Git指令常用指令克隆 git clone repo 克隆分支 git clone -b branch_name repo 上传文件 git add . git commit -m &#39;update_name&#39; git push origin branch_name Hexo指令 hexo init hexo clean g d hexo s hexo new name categories 分支https://zdran.com/20180326.html 创建源文件git目录 git init git remote add origin https://github.com/xx/xx.github.io // 填入你的repo地址 创建分支 git checkout -b branch_name git add . git commit -m &#39;add branch_name&#39; git push origin branch_name 切换分支 git checkout branch_name","categories":[{"name":"技术","slug":"技术","permalink":"https://shiokiri.com/categories/技术/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://shiokiri.com/tags/Blog/"}]},{"title":"「FFT/NTT」「多项式」","slug":"2019-08-15-fft-ntt","date":"2019-08-15T12:16:04.000Z","updated":"2025-03-21T01:15:15.321Z","comments":true,"path":"2019-08-15-fft-ntt/","link":"","permalink":"https://shiokiri.com/2019-08-15-fft-ntt/","excerpt":"更新于：A.D.2019.08.15 必忘原理的FFT","text":"更新于：A.D.2019.08.15 必忘原理的FFT 测试一下视频，然而貌似只有bilibili的外链比较好总不能放Youtube？，然而鬼畜的二维码与顶部链接比前几年在mcbbs看的时候烂多了。 在2019年8月15日，终于看懂了FFT的推导过程。 首先是FFT的板子，这个写法其实很优美记不住的。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;complex&gt; #define R register using namespace std; const int N = 4.2e6; const double PI = acos(-1); int n, r[N]; class C { public: double r, i; C() { r = i = 0; } C(R double x, R double y) { r = x; i = y; } C operator + (R C&amp; x) { return C(r+x.r, i+x.i); } C operator - (R C&amp; x) { return C(r-x.r, i-x.i); } C operator * (R C&amp; x) { return C(r*x.r-i*x.i, r*x.i+i*x.r); } void operator += (R C&amp; x) { r += x.r; i += x.i; } void operator *= (R C&amp; x) { R double t = r; r = r*x.r-i*x.i; i = t*x.i+i*x.r; } }f[N], g[N]; inline void FFT(R C *a, R int op) { R C W, w, t, *a0, *a1; R int i, j, k; for (i = 0; i &lt; n; ++i) if (i &lt; r[i]) t = a[i], a[i] = a[r[i]], a[r[i]] = t; for(i = 1; i &lt; n; i &lt;&lt;= 1) for(W = C(cos(PI/i), sin(PI/i) * op), j = 0; j &lt; n; j += i &lt;&lt; 1) for(w = C(1, 0), a1 = i + (a0 = a + j), k = 0; k &lt; i; ++k, ++a0, ++a1, w*=W) t = *a1 * w, *a1 = *a0 - t, *a0 += t; } int main() { R int m, i, l = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(i = 0; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;f[i].r); for(i = 0; i &lt;= m; i++) scanf(&quot;%lf&quot;, &amp;g[i].r); for(m += n, n = 1; n &lt;= m; n &lt;&lt;= 1, ++l); for(i = 0; i &lt; n; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)); FFT(f, 1); FFT(g, 1); for(i = 0; i &lt; n; ++i) f[i] *= g[i]; FFT(f, -1); for(i = 0; i &lt;= m; ++i) printf(&quot;%.0lf &quot;, fabs(f[i].r) / n); return 0; } 咕，马上补.","categories":[{"name":"数学","slug":"数学","permalink":"https://shiokiri.com/categories/数学/"}],"tags":[{"name":"FFT","slug":"FFT","permalink":"https://shiokiri.com/tags/FFT/"},{"name":"NTT","slug":"NTT","permalink":"https://shiokiri.com/tags/NTT/"}]},{"title":"「动态规划」","slug":"2019-08-14-dp","date":"2019-08-14T07:04:06.000Z","updated":"2025-03-21T01:15:17.516Z","comments":true,"path":"2019-08-14-dp/","link":"","permalink":"https://shiokiri.com/2019-08-14-dp/","excerpt":"更新于：A.D.2019.10.17 推不出的DP方程","text":"更新于：A.D.2019.10.17 推不出的DP方程 随意记点动态规划的方程，大概是NOIP难度的。 Problem水题LuoguP1472 奶牛家谱 Cow Pedigrees题意：有$n$个结点$k$层的二叉树结构个数，树只能有$2$个儿子或$0$个儿子。 设$dp[n][k]$为有$n$个结点不到$k$层的答案，则答案容斥一下为$dp[n][k]-dp[n][k-1]$，转移从下把两棵树连接到上一层结点，枚举$t$为左子树节点个数，则右子树为$总结点个数-t-1$(1是减掉根)，乘法原理把两个乘起来，方程为 dp[i][j]=\\sum dp[t][j-1]\\times dp[i-t-1][j-1]正常题[SDOI2011]消耗战题意：给定$n$个点有边权的树，割断边花费边权，求使$k$个点与$1$点不连通的最小花费。 要用虚树做，写一下方程。 设$dp[n]$为使以$n$为结点的子树内关键点都不与$n$联通的最小花费，方程为 dp[u]=dp[u]+ \\begin{cases} \\min(dp[v],dist_{u,v})& \\text{v不是关键点}\\\\ dist_{u,v}& \\text{v是关键点} \\end{cases}[ZJOI2010]排列计数题意：求一个$1\\sim n$的排列$Pi$使$ 1\\leq i \\leq n$时$P_i&gt;P{i/2}$的方案数。 直接做没什么思路，可以想一下除二的关系可以是二叉树，于是换到树上来做，求$n$个节点的二叉树满足小根堆性质树的个数。 设$dp[i]$表示以$i$为根的子树内满足小根堆性质的方案数，$s[i]$为树结点数，提前把一些越界的初值设为$1$以免判断，转移时组合数算一下选给左子树的点，记得减去根节点，乘一下两颗子树的方案数就ok了，组合数要用lucas，方程 dp[i]=C_{s[i]-1}^{s[i\\times 2]}dp[i\\times 2]dp[i\\times 2+1][SCOI2008]奖励关题意：$m$种物品，给你n次随机在$1\\sim m$间的物品，每种物品有价值并且选这种物品需要你在前$n-1$次把集合$S$内的物品种类都选过一次才可以选。 显然$m$非常小，那么求期望直接枚举就可以了，这样就好做了，然后在考虑一下如果顺推的话需要保证$S$的合法性，这个比较难处理，那么逆推显然更好写。设$dp[i][S]$表示取前$i-1$次的状态为$S$是期望的最大值，$pre[i]$为第$i$种物品的前提集合，方程枚举第i个选第k种 dp[i][S]=dp[i][S]+ \\begin{cases} \\max(dp[i+1][S],dp[i+1][S|(1","categories":[{"name":"算法","slug":"算法","permalink":"https://shiokiri.com/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://shiokiri.com/tags/动态规划/"}]},{"title":"从零开始的C++学习","slug":"2019-08-09-cpp","date":"2019-08-09T08:04:47.000Z","updated":"2025-03-21T01:15:22.418Z","comments":true,"path":"2019-08-09-cpp/","link":"","permalink":"https://shiokiri.com/2019-08-09-cpp/","excerpt":"更新于：A.D.2019.10.17 Visual Studio过于复杂","text":"更新于：A.D.2019.10.17 Visual Studio过于复杂 装了一下2017年装过一次却怎么没用过的Visual Studio，计划学习C++的OOP及C++11的语法后继续学习C++MFC. 文档：cppreference.com 资料：C++教程 书籍：《C++ Primer Plus》 C++ OOP类 对象class x{...};定义一个类 x xxx;声明一个类型为Hf的对象 访问数据成员用.即可 成员函数类定义内部的成员函数默认inline 在类的外部定义函数的话用范围解析运算符::定义成员函数 数据类型 类名::函数名() {} 调用函数用. 即可 类访问修饰符public公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值 private私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。 protected保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。 继承时，使用哪种修饰符父类便继承到哪一部分中 1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问； 2.protected 成员可以被派生类访问。 类构造函数 &amp; 析构函数构造函数就定义一个函数名为类名没有数据类型的函数，每次创建类的新对象时执行，默认是存在构造函数，所以如果定义了有参数的构造函数，一定注意要再定义一个无参数无内容的构造函数，不然不用带参数的构造函数用默认创建对象的话会出错.像这样玩就行，赋值可以像这样搞. struct node { int o, l, r, t; node() {} node(int o, int l, int r): o(o), l(l), r(r), t(ask(l, r)) {} friend bool operator &lt; (const node&amp; a, const node&amp; b) { return sum[a.t] - sum[a.o - 1] &lt; sum[b.t] - sum[b.o - 1]; } }; 析构函数名字是这样的~类名，这个函数再删除对象时执行.总之就是一个创建，一个删除时执行。","categories":[{"name":"编程","slug":"编程","permalink":"https://shiokiri.com/categories/编程/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://shiokiri.com/tags/C/"}]},{"title":"「数论」","slug":"2019-08-09-number-theory","date":"2019-08-09T06:37:38.000Z","updated":"2025-03-21T01:15:20.586Z","comments":true,"path":"2019-08-09-number-theory/","link":"","permalink":"https://shiokiri.com/2019-08-09-number-theory/","excerpt":"更新于：A.D.2019.08.09 只会GCD","text":"更新于：A.D.2019.08.09 只会GCD 取模(a+b) \\bmod p=(a\\bmod p+b\\bmod p)\\bmod p​(a-b) \\bmod p=(a\\bmod p-b\\bmod p+p)\\bmod p​(a\\times b) \\bmod p=(a\\bmod p\\times b\\bmod p)\\bmod p​求$\\dfrac{a}{b}\\bmod p​$时,求$b^{-1}​$使$b*b^{-1}\\equiv1\\pmod p​$即$b​$的逆元 有\\dfrac{a}{b}\\bmod p=a\\times b^{-1}\\bmod p 费马小定理定理：当$p​$是质数时$a^{p-1}\\equiv 1\\pmod p​$ 逆元：由$a^{p-1}\\equiv 1\\pmod p​$得$a\\times a^{p-2}\\equiv 1\\pmod p​$ 即$a^{p-2}$是$a$在模$p$意义下的逆元 欧拉定理若$gcd(a,p)=1$则$a^{\\varphi(p)}\\equiv1\\pmod n$ 当$p$是质数时$\\varphi(p)=p-1$ 即$a^{p-1}\\equiv1\\pmod n$即费马小定理 GCD EXGCD#define ll long long ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; } void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) { if(!b) x = 1, y = 0; else exgcd(b, a % b, y, x), y -= a / b * x; } $gcd$用来求解$a，b$的最大公约数 $lcm(a,b)=\\dfrac{a\\times b}{gcd(a,b)}​$，lcm是最大公约数 $exgcd$用来求解$ax+by=gcd(a,b)$，证明大概是化式子构造递归的解法，反正看了也早晚会忘就是了逃 $exgcd$还可以求解$ax\\equiv b\\pmod p​$形式的同余方程 $exgcd(a,p,x,y)$求出来的$x$就是$a$关于$p$的逆元 CRT exCRT求解一个同余方程组 \\begin{cases} x \\equiv a_1 \\pmod {m_1} \\\\ x \\equiv a_2 \\pmod {m_2} \\\\ x \\equiv a_n \\pmod {m_n} \\end{cases}两种东西都可以通过exgcd两两合并同余方程求解，不过CRT可以直接构造出答案。 CRT求解的$p​$是质数，exCRT的不是，都可以用exgcd合并做。 推导参考这个blog：扩展欧几里得算法与中国剩余定理 CRT直接构造的解： 令$M=\\prod m_i, M_i=\\frac M{m_i}​$，$t_i​$为$M_i​$在模$m_i​$意义下的逆元 方程组的解为x \\equiv \\sum_{i=1}^na_it_iM_i \\pmod M​ 筛法求$n$是不是素数直接枚举$1$到$\\sqrt{n}$试除 埃筛 for(int i = 2; i &lt;= N; i++) if(!vis[i]) { prime[++cnt] = i; for(int j = 1; i * j &lt;= N; j++) vis[i * j] = 1; } 线筛 for(int i = 2; i &lt;= N; i++) { if(!vis[i]) prime[++cnt] = i; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; } }","categories":[{"name":"数学","slug":"数学","permalink":"https://shiokiri.com/categories/数学/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://shiokiri.com/tags/数论/"}]},{"title":"Chrome浏览器 | 插件与设置","slug":"2019-06-04-chrome","date":"2019-06-04T09:54:25.000Z","updated":"2025-03-21T01:15:24.974Z","comments":true,"path":"2019-06-04-chrome/","link":"","permalink":"https://shiokiri.com/2019-06-04-chrome/","excerpt":"更新于：A.D.2019.06.04","text":"更新于：A.D.2019.06.04 下载安装下载地址：Google Chrome 网络浏览器 插件Bookmarkie 插件栏弹出收藏夹，可搜索 书签侧边栏 侧边栏收藏夹 Wrona History Menu 插件栏弹出历史记录，最近关闭 Checker Plus for Gmail™ 查看Google邮箱 Click and Save 快捷键点击存图 CSS Peeper 抓取页面样式 Earth View from Google Earth 新页标签Google地球 Color Tab 新页标签配色设计 Save All Resources 下载控制台Sources全部文件 Steam Inventory Helper steam网页版市场工具 Speedtest by Ookla 墙外测速 Stylus 替换CSS样式 Tampermonkey 网页js脚本 Yet another flags 查看网页ip 沙拉查词 划词翻译 ImageAssistant 下载网页图片 Yet Another Drag and Go 四方向拖拽搜索，链接拖拽打开 pakku bilibili弹幕过滤 Aerys 插件栏查看窗口标签 操作左键单击 = 在当前窗口打开目标网页 Shift + 左键单击 = 在新窗口打开目标网页 Ctrl + 左键单击 = 在新标签页打开目标网页 Ctrl + Shift + T = 打开上一个关闭的标签页 Ctrl + Shift + B = 显示书签栏 Ctrl + D = 为此页添加书签 Ctrl + H = 历史记录 设置不在设置里出现的控制选项： chrome://flags 查看chrome账号同步情况： chrome://sync 地址栏中使用的搜索引擎改为google.com.hk 网页长截图1.按F12 2.按Ctrl + Shift + P 3.输入Capture full size screenshot并回车 截取手机版长图在1、2操作之间，按下Ctrl + Shift + M 选区截图1.按F12 2.按Ctrl + Shift + C 3.选中区域后去输入Capture node screenshot并回车","categories":[{"name":"计算机","slug":"计算机","permalink":"https://shiokiri.com/categories/计算机/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://shiokiri.com/tags/Chrome/"}]},{"title":"科学上网 | GFW与SSR简介","slug":"2019-06-01-gfw","date":"2019-06-01T13:52:50.000Z","updated":"2025-03-21T01:15:27.467Z","comments":true,"path":"2019-06-01-gfw/","link":"","permalink":"https://shiokiri.com/2019-06-01-gfw/","excerpt":"更新于：A.D.2019.05.31 Across the Great Wall we can reach every corner in the world.","text":"更新于：A.D.2019.05.31 Across the Great Wall we can reach every corner in the world. 在配置开发环境、依赖项等过程中，不可避免的会遇到无法下载、下载速度过慢的情况。 在编程学习中，如果可以使用Google、StackOverflow，往往可以解决很多问题。 本文简要介绍GFW和常见的科学上网技术。 删减了大部分内容，推荐观看电丸科技AK制作的https://www.youtube.com/watch?v=XKZM_AjCUr0&amp;list=PLqybz7NWybwUgR-S6m78tfd-lV4sBvGFG 这一系列视频，推荐简单学习计算机网络知识。 推荐阅读： 中国的互联网 _ neoFelhz’s Blog[已失效] 浅谈vpn、vps、Proxy以及shadowsocks之间的联系和区别 墙与纸飞机 什么是 SSR、V2ray、Trojan、Clash，什么是机场？ vpn工作原理和搭建方法 代理，网关，隧道，有什么区别与联系？ 什么是GFWGFW防火长城 - 维基百科，自由的百科全书 线路拓扑： 一些名词虚拟专用服务器 - 维基百科，自由的百科全书 代理服务器 - 维基百科，自由的百科全书 SOCKS - 维基百科，自由的百科全书 IPv6 - 维基百科，自由的百科全书 Secure Shell - 维基百科，自由的百科全书 超文本传输安全协议 - 维基百科，自由的百科全书 点对点网络 - 维基百科，自由的百科全书 HTTP状态码 - 维基百科，自由的百科全书 中间人攻击 - 维基百科，自由的百科全书 如何科学上网VPN虚拟专用网 - 维基百科，自由的百科全书 虚拟私人网络（英语：Virtual Private Network，缩写：VPN）是一种常用于连接 中、大型企业或团体与团体间的私人网络的通讯方法。它利用隧道协议（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果，这种技术可以用 不安全的网络（例如：互联网）来发送可靠、安全的消息。 隧道协议 - 维基百科，自由的百科全书 SS | SSR推荐阅读：浅谈VPN和SS/SSR的区别 简介全称Shadowsocks | ShadowsocksR SS的作者Clowwindy删除了GitHub的源代码，SSR是breakwa11在SS基础上开发的软件，后作者在GitHub上将其源代码删除，SS与SSR开发时皆开源，原作者停止维护后有人开发并维护与更新至今。 SS官网 GitHub SSR已经删除的主页（web archive）：breakwa11.github.io GitHub 简单了解一下：Shadowsocks - 维基百科，自由的百科全书 界面： 下载有Windows、Linux、Android、IOS、Macos等系统及各种在源软件基础上开发的很多版本。 一个仍在维护的Windows版本： https://github.com/shadowsocksrr/shadowsocksr-csharp/releases 一些下载地址及版本介绍： SS/SSR 简介 教程优先阅读[ShadowsocksR] 大概是萌新也看得懂的SSR功能详细介绍&amp;使用教程 Windows的ss客户端 · 珂学上网相关知识总结 机场浅谈部分机场（SS/SSR提供商）的使用感受 使用技巧ShadowsocksR 客户端 各种隐藏使用技巧说明 ShadowsocksR简明使用教程 小飞机的颜色 颜色 全局 PAC 直连 负载均衡 白 √ √ 青 √ 黄 √ √ 绿 √ 蓝 √ 紫 √ √ 快捷键对小飞机托盘图标操作 操作 效果 左键单击 弹出编辑服务器窗口 中键单击 弹出服务器连接统计窗 右键单击 弹出菜单 SSTap软件介绍：SSTap全称SOCKSTap, 是一款利用虚拟网卡技术在网络层实现的代理工具。SSTap能在网络层拦截所有连接并转发给HTTP，SOCKS4，5，SHADOWSOCKS代理.而无需对被代理的应用程序做任何修改或设置。它能同时转发TCP,UDP数据包，它非常适合于游戏玩家使用。 搭建SSR服务购买VPS，部署Linux发行版和SSR服务端（没有搭建博客、使用服务器等用途不推荐） Trojantrojan-gfw / trojan ClashDreamacro / clash V2Ray推荐阅读：浅谈vpn、vps、Proxy以及shadowsocks之间的联系和区别 V2Ray 是一个模块化的代理软件包，它的目标是提供常用的代理软件模块，简化网络代理软件的开发。 简单来说，它就是一个模块化代理，可以用来科学上网，支持多平台。 Project V · Project V 官方网站 Github TLSBrooktxthinking / brook Tortorproject 一些工具一个Chrome的插件 Yet another flags 可以很方便的显示服务器IP地址和地理位置。效果： 常用互联网服务无法访问websiteGoogle Youtube Facebook Twitter Wikipedia(zh_CN) IMTelegram 正常访问websiteQuora GitHub","categories":[{"name":"计算机","slug":"计算机","permalink":"https://shiokiri.com/categories/计算机/"}],"tags":[{"name":"GFW","slug":"GFW","permalink":"https://shiokiri.com/tags/GFW/"},{"name":"SSR","slug":"SSR","permalink":"https://shiokiri.com/tags/SSR/"}]}]}