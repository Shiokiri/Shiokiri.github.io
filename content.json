{"meta":{"title":"落影汐雾的x号虚空印刷站","subtitle":null,"description":null,"author":"落影汐雾","url":"https://x.lyxw.xyz","root":"/"},"pages":[{"title":"关于","date":"2022-04-01T14:18:06.978Z","updated":"2022-04-01T14:18:06.978Z","comments":true,"path":"about/index.html","permalink":"https://x.lyxw.xyz/about/index.html","excerpt":"","text":"落影汐雾，学生 曾经是OIer，用过的id是ColorfulMist 喜欢中文vocaloid、PC游戏、一点ACGN、电子产品和写代码 网站是高中时期摸鱼搭建的静态博客，使用 Hexo，主题是 Material 交换友链在此回复名称+介绍+头像链接+主页链接即可\\ (￣︶￣\\ *))"},{"title":"gallery","date":"2021-08-02T07:18:15.855Z","updated":"2019-06-05T02:12:39.411Z","comments":true,"path":"gallery/index.html","permalink":"https://x.lyxw.xyz/gallery/index.html","excerpt":"","text":""},{"title":"links","date":"2022-06-02T10:56:30.214Z","updated":"2019-06-05T01:55:50.556Z","comments":true,"path":"links/index.html","permalink":"https://x.lyxw.xyz/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-28T23:46:29.832Z","updated":"2019-06-05T01:55:21.571Z","comments":true,"path":"tags/index.html","permalink":"https://x.lyxw.xyz/tags/index.html","excerpt":"","text":""},{"title":"timeline","date":"2021-07-28T23:46:29.832Z","updated":"2019-06-05T02:15:20.850Z","comments":true,"path":"timeline/index.html","permalink":"https://x.lyxw.xyz/timeline/index.html","excerpt":"","text":""},{"title":"闲聊","date":"2077-07-11T16:00:00.000Z","updated":"2022-04-12T15:16:23.171Z","comments":true,"path":"chat/index.html","permalink":"https://x.lyxw.xyz/chat/index.html","excerpt":"","text":"更新于：A.D.2022-04-01 Q：喜欢什么样的二次元？ A：https://bangumi.tv/user/shiokiri Q：做过什么算法题？ A：https://www.luogu.com.cn/user/51525&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://leetcode-cn.com/u/shiokiri/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://vjudge.net/user/i/552714&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://codeforces.com/profile/colorfulmist&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https://atcoder.jp/users/neoSoda"}],"posts":[{"title":"文章索引","slug":"post-index","date":"2033-07-12T15:59:59.000Z","updated":"2022-04-01T14:28:25.102Z","comments":true,"path":"2033/post-index/","link":"","permalink":"https://x.lyxw.xyz/2033/post-index/","excerpt":"更新于： A.D.2022.04.01","text":"更新于： A.D.2022.04.01 这是一篇索引. 因为我还不太想去折腾置顶的东西，所以手动置顶. 日期含义是Metro2033+洛天依生日. 关于 闲聊 计算机 3科学上网 | GFW与SSR简介 Chrome浏览器 | 插件与设置 Windows软件快速指南 编程 7PyQt5上手指南 VSCode配置Python环境及Python入门学习 从零开始的C++学习 C++STL的OI常用内容 Python网络爬虫学习 后端开发学习 C++11学习笔记 技术 6MMD制作简介 Hexo博客搭建及Material主题使用指南 使用jsDelivr+PicGo对图片进行cdn加速 Github Pages+HTML5 up制作个人主页及绑定二级域名 使用Gmail进行域名邮箱邮件收发 VRoid Studio-&gt;Blender-&gt;Unity制作人物模型 杂谈 7夏日小日记 《意识宇宙》 一切都结束了 烦躁沉寂的八月 「观测者轻语」杂谈 我接触与学习编程及OI的经历 一些metagame的介绍与评价（无剧透） 数学 5「FFT/NTT」「多项式」 「莫比乌斯反演」 「概率期望」 「数论」 「计算几何」 算法 5「动态规划」 「后缀数组」 「线段树」 「网络流」 「分层图」 杂项 3电子产品评测 落影汐雾的记录集 游戏《递归的边界线Recursive Boundary》开发记录","categories":[],"tags":[]},{"title":"C++11学习笔记","slug":"C++11","date":"2022-04-01T13:41:25.000Z","updated":"2022-04-01T14:01:59.359Z","comments":true,"path":"2022/C++11/","link":"","permalink":"https://x.lyxw.xyz/2022/C++11/","excerpt":"更新于：A.D.2022.04.01","text":"更新于：A.D.2022.04.01 参考资料 《C++ Primer Plus》 《C++ Primer》 https://zh.cppreference.com C++11功能新类型long long unsigned long long char16_t char32_t 原始字符串 统一的初始化缩窄std::initializer_list声明autodecltype返回类型后置模板别名：using=nullptr智能指针异常规范方面的修改作用域内枚举对类的修改显式转换运算符explicit 类内成员初始化模板和STL方面的修改基于范围的for循环int p[5] = {1,2,3,4,5}; for(int x : p) std::cout &lt;&lt; x &lt;&lt; std::endl; for(auto x : p) std::cout &lt;&lt; x &lt;&lt; std::endl; //--- std::vector&lt;int&gt; v(10); for(auto &amp; x : v) x = 1; 右值引用&amp; 左值引用 &amp;&amp; 右值引用 移动语义和右值引用新的类功能Lambda函数[](int x) { return x/2; } auto div2 = [](int x) { return x/2; } //--- [](double x) -&gt; double{ int y = x; return x - y; } //--- int x = 0; [&amp;x](int a) { x += a; } //--- int x = 0, y = 0; [&amp;](int a) { x += a; y += a; } 包装器可变参数模板其他新功能","categories":[{"name":"编程","slug":"编程","permalink":"https://x.lyxw.xyz/categories/编程/"}],"tags":[{"name":"C++11","slug":"C-11","permalink":"https://x.lyxw.xyz/tags/C-11/"}]},{"title":"游戏《递归的边界线Recursive Boundary》开发记录","slug":"unity-project-recursive-boundary","date":"2022-04-01T13:04:25.000Z","updated":"2022-04-12T15:10:31.163Z","comments":true,"path":"2022/unity-project-recursive-boundary/","link":"","permalink":"https://x.lyxw.xyz/2022/unity-project-recursive-boundary/","excerpt":"更新于：A.D.2022.04.12","text":"更新于：A.D.2022.04.12 括号内的英文为Unity内置概念 剧情编写与游戏流程设计剧本编写构思了游戏主要设定，编写了游戏剧情文本，分为五个部分，分别在五个场景中计划进行应用 递归的边界线 游戏流程设计设计了游戏流程： Unity引擎操作与C#脚本编写渲染管线选取与美术资源预处理可编程渲染管线是一个瘦 API 层，允许使用 C# 脚本来调度和配置渲染命令。Unity 将这些命令传递给它的低级图形架构，后者随后将指令发送给图形 API。Unity 的可编程渲染管线 (Scriptable Render Pipeline, SRP) 是一项可以通过 C# 脚本来控制渲染的功能。SRP 技术可以强化通用渲染管线 (URP) 和高清渲染管线 (HDRP)。 本次项目选用了通用渲染管线（Universal Render Pipeline），首先通过Unity对美术素材中的Shader升级为URP格式，并手动处理升级失败的Shader。 为树木材质升级失败的场景手动摆放了不同风格的树木，为场景选择了天空盒（Skybox），并调整了场景太阳光点光源设置，调整了URP渲染管线的配置。 人物模型制作与数据格式转换使用人形模型生成软件VRoid Studio进行角色设计，通过数位板（设备：Wocam CTL672）对贴图进行绘画，选择合适三角形面数导出为VRM数据格式，通过GitHub下载Blender Python插件cats-blender-plugin-0-19-0并安装，转换VRM数据格式为通用数据格式FBX，并对模型网格（Mesh），骨骼（Skeleton）等内容进行修复。 在动画网站https://www.mixamo.com/上传模型，并根据具体模型选取动画，并调整网站动画参数，减少穿模，错位，最后下载动画数据FBX文件，并导入Unity。 导入FBX模型文件进入Unity，设置模型动画格式为人形（Humanoid），选择合适的材质球（Material）格式。 第三人称控制系统与动画系统通过Unity官方资源Starter Assets获取基本人形控制器，替换人形的模型与骨骼，替换脚本控制器为当前人物的控制器，通过Unity动画状态机（Animator）完善了默认的走路、跑动、跳跃、静止四种基本状态的状态转换路线。 配置了瞄准动画的动画状态机设置，并通过检测鼠标右键点击切换动画状态，使用了遮罩（Mask）和IK Pass实现了动画转换，制作了选取头部、颈部、与上肢的骨骼遮罩，使瞄准动画的上体动作不在受到基本动画状态的影响。 第三人称射击系统与粒子特效通过光线投射方法计算当前屏幕中心点在场景模型中的投影，并通过投影点与子弹发出点的坐标计算欧拉角，对子弹使用实例化方法，实例一发子弹沿欧拉角方向射出，给出初始速度，并且使子弹完全沿光线方向射出，不受重力影响。 配置了子弹的材质（Material）光效，使得子弹模型显示为红色，并在击中目标后显示绿色粒子光效，未击中目标时显示红色粒子光效。 在瞄准时将虚拟摄像机切换瞄准虚拟摄像机（VirtualCamera），使得人物模型在视野中心偏右，并通过调整图片Alpha值的方法控制UI中心准星的显示，取消瞄准时切换到常规虚拟摄像机，并禁止子弹发出。 调整了常规和瞄准的视角，常规状态时鼠标可环绕，而模型不会转动方向，瞄准状态时模型随鼠标环绕而转动方向。 射中目标后，通过子弹附着的代码，检测刚体碰撞，并获取碰撞物体的对象，通过对象附着的代码暴露出的setter修改射中物体对象的私有属性血量。 通过泛型应用单例设计模式对游戏管理器（GameManager）和场景管理器（SceneController）的代码设计采用单例的设计模式，使整个游戏过程中代码挂载的对象只产生一份。 设计工具类Singleton类并编写虚函数和方法，通过泛型继承Singleton类实现这一设计模式。 场景异步加载与跨场景人物传送通过C#协程（Coroutines）方法，调用UnityEngine继承类中的异步（Asynchronous）加载方法，对场景实行多线程加载。 设计代码，使用枚举数据类型，在O(n)的时间复杂度下找到对应标签的传送地点，并通过GameManager的单例方法删除原场景中的人物，并使用单例方法在新场景中通过玩家预制体（Prefab）生成玩家（Player） 通过URP Shader制作传送门特效，为传送门挂载脚本，将传送门保存为预制体（Prefab），在所有场景中摆放传送门并设置传送门自身标签与传送目的标签。 人物属性数据设计与存储系统对人物设计了最大血量，当前血量，最大子弹，当前子弹4种私有数据存储于数据类中。 通过另一个接口类的公有方法对其他类暴露，并通过C#语法糖为变量设置了getter setter。 游戏操作界面UI设计通过对人物模型附着子物体摄像机，将摄像机画面输出到渲染管线纹理（RenderPipeline Texture），将渲染管线纹理输出到材质球（Material），将材质球输出到UI的image对象中，调整UI中image对象的位置，实现了实时头像的显示。 通过一张图片作为底色，控制一张图片的长度实现血量条和子弹条。 开发计划完成游戏整体设计对按照现有整体游戏控制框架，进一步完善游戏内容： 设计游戏主界面UI，并编写代码完成UI系统 设计游戏总流程的状态机，编写代码控制对话系统。 设计敌人的行为树，并编写代码与完善模型与动画资源，完成敌人系统。 设计数据存储结构，完成数据存档系统。 完成编写实现风格化渲染的Unity Shader对至少完成对人物模型的Unity Shader编写，实现二维卡通渲染效果，凸出表现阴影和高光部分。","categories":[{"name":"杂项","slug":"杂项","permalink":"https://x.lyxw.xyz/categories/杂项/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://x.lyxw.xyz/tags/Unity/"},{"name":"Blender","slug":"Blender","permalink":"https://x.lyxw.xyz/tags/Blender/"},{"name":"C#","slug":"C","permalink":"https://x.lyxw.xyz/tags/C/"},{"name":"VRoid Studio","slug":"VRoid-Studio","permalink":"https://x.lyxw.xyz/tags/VRoid-Studio/"}]},{"title":"「计算几何」","slug":"computational-geometry","date":"2022-04-01T12:43:25.000Z","updated":"2022-04-01T12:50:13.925Z","comments":true,"path":"2022/computational-geometry/","link":"","permalink":"https://x.lyxw.xyz/2022/computational-geometry/","excerpt":"更新于：A.D.2022.04.01","text":"更新于：A.D.2022.04.01 参考资料 1.授课PDF 2.OI-Wiki 几何定理欧拉公式对于一个平面图$G=\\left \\langle V,E,C,F \\right \\rangle$，有$|V|$个顶点，$|E|$条连边，$|C|$个（弱）连通分量，$|F|$个区域（包含无限域），则 |F|+|V|-|E|=|C|+1皮克公式对于一个定点都位于格点上的多边形，设其面积为$S$，多边形非边界内部的点数为$a$，多边形边界上的点数为$b$，则 2S=2a+b-2二维几何向量类（V vector）class V { protected: double x, y; public: V() { x = y = 0; } V(double _x, double _y) : x(_x), y(_y) {} //... }; 点类（P point）class P : public V { protected: int i; public: P() { x = y = 0; } P(double _x, double _y, int _i = -1): V(_x, _y), i(_i) {} //... }; 线段类（S segment） class S { protected: P u, v; public: S() {} S(P _u, P _v) : u(_u), v(_v) {} //... }; 直线类（L line）class L : public S { protected: public: L() {} L(P _u, P _v) : S(_u, _v) {} //... }; 圆类（C circle）class C { protected: P o; double r; public: C() {} C(P _o, double _r) : o(_o), r(_r) {} //... }; 凸包类（CH convex_hull）凸包是对于给定点集而言的，凸包是包含给定点集的最小凸多边形的边界点的集合。 一个多边形是凸的，当且仅当其内部任意两点的连线都被该多边形所包含。 class CH { //逆时针方向给出点 protected: int n; P* p; public: CH() : n(0), p(NULL) {} CH(int _n) : n(0) { p = (P*)calloc(_n, sizeof(P)); } //... }; 常用函数符号函数与比实数大小const double eps = 1e-8; int sgn(double a) { return a &lt; -eps ? -1 : a &gt; eps; } int cmp(double a, double b) { return sgn(a - b); } 平方函数double sqr(double x) { return x * x; } 向量的加减乘除V operator + (const V&amp; o) const { return V(x + o.x, y + o.y); } V operator - (const V&amp; o) const { return V(x - o.x, y - o.y); } V operator * (double k) const { return V(x * k, y * k); } V operator / (double k) const { return V(x / k, y / k); } 取出向量的某一分量double operator [](int i) const { return i == 0 ? x : y; } 向量的模与辐角 整型绝对值: abs(x) \\\\ 浮点型绝对值: fabs(x) \\\\ atan2(y,x)=\\arctan(\\frac{y}{x})double norm2() const { return sqr(x) + sqr(y); } //模长的平方 double norm() const { return sqrt(norm2()); } //模长 double arg() const { return atan2(y, x); } //辐角 向量的单位方向向量V operator ~() const { return *this / norm(); } 两向量的点乘和叉乘friend double dot(const V&amp; a, const V&amp; b) { return a.x * b.x + a.y * b.y; } friend double det(Const V&amp; a, const V&amp; b) { return a.x * b.y - b.x * a.y; } 两向量的距离与夹角 \\mathbf{a}\\cdot \\mathbf{b}=|\\mathbf{a}||\\mathbf{b}| \\cos\\left \\langle \\mathbf{a},\\mathbf{b} \\right \\rangle \\\\ \\mathbf{a}\\times \\mathbf{b}=|\\mathbf{a}||\\mathbf{b}|\\sin\\left \\langle \\mathbf{a},\\mathbf{b} \\right \\rangle \\\\ atan2(\\mathbf{a}\\times \\mathbf{b},\\mathbf{a}\\cdot \\mathbf{b})=atan2(\\frac{\\mathbf{a}\\times \\mathbf{b}}{\\mathbf{a}\\cdot \\mathbf{b}})=atan2(\\tan\\left \\langle \\mathbf{a},\\mathbf{b} \\right \\rangle)=\\left \\langle \\mathbf{a},\\mathbf{b} \\right \\rangle \\\\friend double dis(const V&amp; a, const V&amp; b) { return (a - b).norm(); } friend double irad(const V&amp; a, const V&amp; b) { return atan2(det(a, b), dot(a, b)); } 旋转某向量（逆时针） \\mathbf{V} = \\begin{bmatrix} x \\\\ y \\end{bmatrix} \\\\ 旋转矩阵(向逆时针方向转\\alpha\\ rad)\\ \\mathbf{T} = \\begin{bmatrix} \\cos(\\alpha) & -\\sin(\\alpha) \\\\ \\sin(\\alpha) & \\cos(\\alpha) \\end{bmatrix} \\\\ \\mathbf{\\hat{V}}=\\mathbf{T}\\mathbf{V}V rot(double a) { return V(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a)); } 某向量的垂直向量（逆时针）V perp() const { return V(-y, x); } 两点间的位移向量V operator - (const P&amp; o) const { return V(x - o.x, y - o.y); } 点的位移P operator + (const V&amp; o) const { return P(x + o[0], y + o[1]); } 点的微小扰动void shake(double e = eps) { srand(time(0)); x += (rand() / (double)RAND_MAX - 0.5) * e; y += (rand() / (double)RAND_MAX - 0.5) * e; } 点到直线距离 P(x,y) \\quad l:uv\\\\ S=\\frac{1}{2}|uv|\\cdot d=\\frac{1}{2}|(u-p)\\times(v-p)| \\\\ d=\\frac{|(u-p)\\times(v-p)|}{|uv|}friend double dis(const L&amp; l, const P&amp; p) { return fabs(det(p - l[0], l[1] - l[0]) / l.len()); } 线段上定比分点friend P defpoint(const L&amp; l, double k) { return l[0] + l.dir() * k; } 点关于直线的投影点friend P proj(const L&amp; l, const P&amp; p) { return l[0] + ~l.dir() * dot(p - l[0], l[1] - l[0]) / l.len(); } 其他跨立实验判断两线段是否相交射线法判断点是否在多边形内部经典问题及算法二维凸包平面最远点对平面最近点对圆反演三维凸包进阶内容几何（计算机图形学）仿射变换射影几何算法自适应辛普森积分最左转线法三角剖分问题最小圆覆盖圆的面积并半平面交平面图转对偶图 &amp; 点定位题目圈奶牛Fencing the Cows /【模板】二维凸包简单实验了一下封装方法和C++11 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;iomanip&gt; #include &lt;cstdlib&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;ctime&gt; using std::cin; using std::cout; using std::endl; using std::swap; using std::sort; const double eps = 1e-8; int sgn(double a) { return a &lt; -eps ? -1 : a &gt; eps; } int cmp(double a, double b) { return sgn(a - b); } double sqr(double x) { return x * x; } class V { protected: double x, y; public: V() { x = y = 0; } V(double _x, double _y) : x(_x), y(_y) {} //... V operator + (const V&amp; o) const { return V(x + o.x, y + o.y); } V operator - (const V&amp; o) const { return V(x - o.x, y - o.y); } V operator * (double k) const { return V(x * k, y * k); } V operator / (double k) const { return V(x / k, y / k); } double operator [](int i) const { return i == 0 ? x : y; } double norm2() const { return sqr(x) + sqr(y); } double norm() const { return sqrt(norm2()); } double arg() const { return atan2(y, x); } V operator ~() const { return *this / norm(); } friend double dot(const V&amp; a, const V&amp; b) { return a.x * b.x + a.y * b.y; } friend double det(const V&amp; a, const V&amp; b) { return a.x * b.y - b.x * a.y; } friend double dis(const V&amp; a, const V&amp; b) { return (a - b).norm(); } friend double irad(const V&amp; a, const V&amp; b) { return atan2(det(a, b), dot(a, b)); } V rot(double a) { return V(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a)); } V perp() const { return V(-y, x); } }; class P : public V { protected: int i; public: P() { x = y = 0; } P(double _x, double _y, int _i = -1): V(_x, _y), i(_i) {} //... V operator - (const P&amp; o) const { return V(x - o.x, y - o.y); } P operator + (const V&amp; o) const { return P(x + o[0], y + o[1]); } bool operator &lt; (const P&amp; p) const { if(cmp(this-&gt;x, p.x) == 0) return cmp(this-&gt;y, p.y) == -1; else return cmp(this-&gt;x, p.x) == -1; } void shake(double e = eps) { srand(time(0)); x += (rand() / (double)RAND_MAX - 0.5) * e; y += (rand() / (double)RAND_MAX - 0.5) * e; } }; class S { protected: P u, v; public: S() {} S(P _u, P _v) : u(_u), v(_v) {} double len() const { return dis(u, v); } V dir() const { return u - v; } //... P operator [](int i) const { return i == 0 ? u : v; } }; class L : public S { protected: public: L() {} L(P _u, P _v) : S(_u, _v) {} //... friend double dist(const L&amp; l, const P&amp; p) { return fabs(det(p - l[0], l[1] - l[0]) / l.len()); } friend P defpoint(const L&amp; l, double k) { return l[0] + l.dir() * k; } friend P proj(const L&amp; l, const P&amp; p) { return l[0] + ~l.dir() * dot(p - l[0], l[1] - l[0]) / l.len(); } }; class C { protected: P o; double r; public: C() {} C(P _o, double _r) : o(_o), r(_r) {} //... }; class CH { protected: int n; P* p; public: CH() : n(0), p(NULL) {} CH(int _n) : n(0) { p = (P*)calloc(_n, sizeof(P)); } //... P operator [](int i) const { return p[i]; } void push_back(const P&amp; _p) { p[n++] = _p; } void pop_back() { n--; } int size() { return n; } double sumPointDist() { double sum = dis(p[n-1], p[0]); for(int i = 1; i &lt; n; i++) sum += dis(p[i], p[i-1]); return sum; } }; CH graham(int n, P p[]) { int b = 0; for(int i = 1; i &lt; n; i++) { if(p[i] &lt; p[b]) { b = i; } } swap(p[0], p[b]); sort(p + 1, p + n, [&amp;p](const P&amp; u, const P&amp; v) { return sgn(det(u - *p, v - *p)) &gt; 0 || (sgn(det(u - *p, v - *p)) == 0 &amp;&amp; sgn(dis(u, *p) - dis(v, *p)) &lt; 0); }); CH ch(n); ch.push_back(p[0]), ch.push_back(p[1]); for(int i = 2; i &lt; n; i++) { int ls = ch.size() - 1; while(ls &gt; 0 &amp;&amp; sgn(det(p[i] - ch[ls - 1], ch[ls] - ch[ls - 1])) &gt;= 0) { ch.pop_back(), --ls; } ch.push_back(p[i]); } return ch; } int main() { int n; cin &gt;&gt; n; P* p = new P[n]; for(int i = 0; i &lt; n; i++) { double x, y; cin &gt;&gt; x &gt;&gt; y; p[i] = P(x, y, i); } CH ch = graham(n, p); cout &lt;&lt; std::setiosflags(std::ios::fixed); cout &lt;&lt; std::setprecision(2) &lt;&lt; ch.sumPointDist() &lt;&lt; endl; return 0; } Beauty Contest G /【模板】旋转卡壳","categories":[{"name":"数学","slug":"数学","permalink":"https://x.lyxw.xyz/categories/数学/"}],"tags":[{"name":"C++11","slug":"C-11","permalink":"https://x.lyxw.xyz/tags/C-11/"},{"name":"计算几何","slug":"计算几何","permalink":"https://x.lyxw.xyz/tags/计算几何/"}]},{"title":"VRoid Studio->Blender->Unity制作人物模型","slug":"vroid-studio-blender-unity","date":"2022-04-01T07:04:25.000Z","updated":"2022-04-01T13:39:37.318Z","comments":true,"path":"2022/vroid-studio-blender-unity/","link":"","permalink":"https://x.lyxw.xyz/2022/vroid-studio-blender-unity/","excerpt":"更新于：A.D.2022.04.01","text":"更新于：A.D.2022.04.01 VRoid Studio下载与安装插件首先在Steam下载，然后安装以下两个插件 【汉化】VRoidStudio正式版 中文汉化 【插件】VRoid Studio 扩展插件 VRoidXYTool v0.3 导出VRM文件导出时适当降低多边形面数 Blender安装Blender通过Steam下载 转换VRM文件为FBX文件删除以下三个物体 从此处导入VRM模型 安装插件 cats-blender-plugin 选安装，再选择插件的zip文件，最后勾选图中的3D View: Cats Blender Plugin 按1 2 3的顺序点击（保证不选Combine Same Materials） 按照1 2的顺序点击 保持默认属性导出FBX文件 最终生成一个FBX文件，一个贴图文件夹 Unity寻找动画素材在该网站上寻找到合适的动画素材后，将FBX文件上传至网站，并通过调整网站提供的参数，使得动作符合模型，避免穿模、错位情况出现，下载动画文件时选择FBX for Unity格式 mixamo.com 导入Unity将FBX文件和贴图文件夹同时导入Unity Assets中 更改模型Rig-Animation Type为Humanoid（人形），Rig-Avatar Definition为Create From This Model 未编写Shader时使用临时Shader保证显示正常（从一个Unity的vrm插件中获取） 导入时自动生成材质球（Matertial），为材质球选择Shader即可 Shader &quot;UniGLTF/UniUnlit&quot; { Properties { _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {} _Color (&quot;Main Color&quot;, COLOR) = (1,1,1,1) _Cutoff (&quot;Alpha Cutoff&quot;, Range(0, 1)) = 0.5 [HideInInspector] _BlendMode (&quot;_BlendMode&quot;, Float) = 0.0 [HideInInspector] _CullMode (&quot;_CullMode&quot;, Float) = 2.0 [HideInInspector] _VColBlendMode (&quot;_VColBlendMode&quot;, Float) = 0.0 [HideInInspector] _SrcBlend (&quot;_SrcBlend&quot;, Float) = 1.0 [HideInInspector] _DstBlend (&quot;_DstBlend&quot;, Float) = 0.0 [HideInInspector] _ZWrite (&quot;_ZWrite&quot;, Float) = 1.0 // VertexColor } SubShader { Tags { &quot;RenderType&quot;=&quot;Opaque&quot; } LOD 100 Pass { Cull [_CullMode] Blend [_SrcBlend] [_DstBlend] ZWrite [_ZWrite] ZTest LEqual BlendOp Add, Max CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile_fog #pragma multi_compile _ _ALPHATEST_ON _ALPHABLEND_ON #pragma multi_compile _ _VERTEXCOL_MUL #include &quot;UnityCG.cginc&quot; struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; #if defined(_VERTEXCOL_MUL) fixed4 color : COLOR; #endif UNITY_VERTEX_INPUT_INSTANCE_ID }; struct v2f { float4 vertex : SV_POSITION; float2 uv : TEXCOORD0; UNITY_FOG_COORDS(1) #if defined(_VERTEXCOL_MUL) fixed4 color : COLOR; #endif UNITY_VERTEX_OUTPUT_STEREO }; sampler2D _MainTex; float4 _MainTex_ST; half4 _Color; half _Cutoff; v2f vert (appdata v) { v2f o; UNITY_SETUP_INSTANCE_ID(v); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o); o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); UNITY_TRANSFER_FOG(o,o.vertex); #if defined(_VERTEXCOL_MUL) o.color = v.color; #endif return o; } fixed4 frag (v2f i) : SV_Target { fixed4 col = tex2D(_MainTex, i.uv) * _Color; #if defined(_VERTEXCOL_MUL) col *= i.color; #endif #if defined(_ALPHATEST_ON) clip(col.a - _Cutoff); #endif #if !defined(_ALPHATEST_ON) &amp;&amp; !defined(_ALPHABLEND_ON) col.a = 1.0; #endif UNITY_APPLY_FOG(i.fogCoord, col); return col; } ENDCG } } Fallback &quot;Unlit/Texture&quot; }","categories":[{"name":"技术","slug":"技术","permalink":"https://x.lyxw.xyz/categories/技术/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://x.lyxw.xyz/tags/Unity/"},{"name":"Blender","slug":"Blender","permalink":"https://x.lyxw.xyz/tags/Blender/"},{"name":"VRoid Studio","slug":"VRoid-Studio","permalink":"https://x.lyxw.xyz/tags/VRoid-Studio/"}]},{"title":"使用Gmail进行域名邮箱邮件收发","slug":"domain_mail","date":"2022-02-12T15:48:00.000Z","updated":"2022-04-01T12:47:18.190Z","comments":true,"path":"2022/domain_mail/","link":"","permalink":"https://x.lyxw.xyz/2022/domain_mail/","excerpt":"更新于：A.D.2022.02.13","text":"更新于：A.D.2022.02.13 准备1.域名 2.Gmail账号 收取根据域名服务商不同，设置也有所不同，我是使用的是Namesilo 设置域名服务商DNS检查DNS设置中是否有MX配置 若没有，从下方选项中添加Email Forwarding默认配置（点击红色区域按钮） 设置域名服务商邮件转发填写域名邮箱地址 填写转发到邮箱地址 发送获取Google应用专用密码https://myaccount.google.com/security 1.打开 两步验证 2.点击 应用专用密码 3.填写 选择应用-邮件 选择设备-其他（自定义名称） 4.填写 域名邮箱地址（方便分辨） 5.获得16位应用专用密码，保存密码后续使用 设置Gmail邮箱SMTP服务点击 用这个地址发送邮件：添加其他电子邮件地址 填写Gmail中邮件地址的显示名称与域名邮箱地址，点击下一步 SMTP服务器 填写 smtp.gmail.com 用户名 填写 去除@gmail.com的gmail邮件地址 密码 填写 前文保存的应用专用密码 端口选择587 选择使用TLS的安全连接 点击添加账号，从Gmail中收取确认邮件并点击确认链接 最后，可以选择是否作为默认发信地址，选择回复邮件时的方式，设置选项在 用这个地址发送邮件 中 测试测试收取邮件使用域名邮箱和Gmail邮箱外的一个邮箱 1.向域名邮箱发送一封邮件，并测试是否发送成功及送达速度 2.使用Gmail收取邮件后，检查收件人，邮送域，署域，安全性是否正确 测试发送邮件使用Gmail发送一封邮件到其他邮箱 1.测试是否发送成功及送达速度 2.检查是否为域名邮箱并显示从Gmail邮箱代发","categories":[{"name":"技术","slug":"技术","permalink":"https://x.lyxw.xyz/categories/技术/"}],"tags":[{"name":"域名邮箱","slug":"域名邮箱","permalink":"https://x.lyxw.xyz/tags/域名邮箱/"},{"name":"Gmail","slug":"Gmail","permalink":"https://x.lyxw.xyz/tags/Gmail/"}]},{"title":"后端开发学习","slug":"backend","date":"2022-01-29T20:24:25.000Z","updated":"2022-04-01T12:53:08.925Z","comments":true,"path":"2022/backend/","link":"","permalink":"https://x.lyxw.xyz/2022/backend/","excerpt":"更新于：A.D.2022.03.31","text":"更新于：A.D.2022.03.31 Java主要学习SpringBoot、Shiro、MySql、JPA、AOP面向切面编程、IOC架构、设计模式等 环境配置1.安装IntelliJ IDEA 2021.2.3，用于Java开发 2.安装Navicat Premium 15，用于图形化查看MySQL数据 3.安装MySQL Workbench，用于数据库管理 4.安装Postman，用于接口测试 5.配置MySQL，用于数据库环境 6.配置Maven，用于项目管理 Maven XML配置pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;&lt;/name&gt; &lt;description&gt;&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 在dependencies中添加依赖项 数据库配置src/…/resources/application.yml server: port: 8080 spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/DataBaseName username: root password: password jpa: hibernate: ddl-auto: update show-sql: true properties: hibernate: jpa:hibernate:ddl-auto create： 每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop ： 每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 update： 最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。 validate ： 每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 常用注解@SpringBootApplication @Entity @Id @GeneratedValue @Column @PathVariable @RequestParam @___Mapping @RestController @Getter @Setter HTTP协议请求类型GET PUT POST DELETE JPA关系映射@OneToOne @OneToMany @ManyToOne @ManyToMany Jpa接口extends JpaRepository Shiro框架Golang环境配置1.配置Golang编译器，环境变量与VSCode开发环境，用于学习语法 2.安装GoLand 2021.2.2，用于Golang开发 3.配置Gin框架环境 Hello wolrdpackage main import &quot;github.com/gin-gonic/gin&quot; func main() { r := gin.Default() r.GET(&quot;/&quot;, func(c *gin.Context) { c.String(200, &quot;Hello world!&quot;) }) r.Run() }","categories":[{"name":"编程","slug":"编程","permalink":"https://x.lyxw.xyz/categories/编程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://x.lyxw.xyz/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"https://x.lyxw.xyz/tags/MySQL/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://x.lyxw.xyz/tags/SpringBoot/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://x.lyxw.xyz/tags/SpringMVC/"},{"name":"Golang","slug":"Golang","permalink":"https://x.lyxw.xyz/tags/Golang/"}]},{"title":"电子产品评测","slug":"electronics","date":"2022-01-29T20:23:12.000Z","updated":"2022-06-23T18:28:23.019Z","comments":true,"path":"2022/electronics/","link":"","permalink":"https://x.lyxw.xyz/2022/electronics/","excerpt":"更新于：A.D.2022.3.19","text":"更新于：A.D.2022.3.19 这里简单评测一些我用过的电子设备 台式机2017年购买，i5-7500+GTX1050Ti的配置，8GB内存 256GB SSD，3TB HDD，ASUS刻录机 屏幕是飞利浦1080P 60hz的一款曲面屏 用了五年多了，上一台电脑是2006年的（，有了这台电脑才开始能玩游戏…… 笔记本机械革命 Umi Pro 32021年购买，i7-11800H+RTX3060的配置，16GB内存 512GB SSD，加装了1TB的西部数据sn550（更换缓外前的版本） 优点：2021年暑假有货，同配置最轻薄模具，液金散热到位，满血RTX3060，屏幕色域色准2k165hz 缺点：内部做工略显粗糙，满载噪音极大（可以人工调整风扇转速），16:9屏幕，双显卡续航1.5~2h 耳机铁三角 ATH-CLR1002018年购买，比起30元左右的耳机，清晰度有所改善，低音音量大小有所改善，不会过吵。 耳机线特别细，比较容易坏。 绿色配色比较好看。 飞利浦 SHP95002021年购买，耳机解析度比较清晰，能很好地分辨出一些细微的声音。分层较好，能明显听出多种乐器声的分层。声场不是太好，不太能听出来乐器位置。 大单元动圈开放式耳机，声音比较通透。人声比较明亮，高音突出，低音较弱。 不夹头，材质偏向塑料，手感比较硬，不是太好。 AirPods 22021年获得，苹果附赠的产品，总体来说外形很不错，比较圆润，音质中规中矩。 如果没有苹果设备，实际上连接体验并不是太好。 SONY WH1000-XM42022年购买，降噪效果比较好，可以隔绝大部分低频噪音，稍稍降低人声。 4代比起3代来说不夹头，受力要小一些。 智能免摘功能很好用，主动说话时就会切换到收音状态 平板iPad Pro 20212021年购买，玩原神用的，顺带看点epub电子书，批注pdf扫描版纸质书 还能看知乎，B站，记手写笔记和3d扫描…… Apple Pencil2021年购买，记笔记还是能用用的，画画不如数位板舒服 手机小米11 Pro2021年购买，人生第二个手机或许是因为我一直喜欢小米 屏幕很好2k 120hz 100%P3 比较喜欢GN2摄像头这样就能夜视了 UFS3.1存储明显快了太多太多，apk安装速度提升极其明显 骁龙888实在是不好，日常使用温感明显常常过热，原神全高掉帧明显 曲面屏我不是太喜欢，比较喜欢iPhone那种有棱角的造型 红米 Note52018年购买，人生第一个手机，在当时那个价位全面屏屏幕真的很漂亮 使用了3年时间，期间加装了128GB闪存卡，后期日常使用也完全不卡，但是64GB存储不太够用 骁龙636陪我玩了刺激战场等等游戏，最后陪我玩了半年原神相当卡 因为过度使用，电池损耗量很大，存储读写速度明显下降 鼠标罗技G5022021年购买，无极滚轮很好用，功能很全面，重量稍重 罗技G3042021年购买，握感很好，无线连接延迟也很小，耗电量不大，电池半年一换，重要主要在电池上 数位板Wacom CTL6722020年购买，总体来说使用体验比iPad好很多，能感受到比较细微的压感，适合作为入门级别产品使用 键盘iKBC C104 白色 青轴2018年购买，第一次体验机械键盘，当时买的时候还比较早，机械键盘才刚刚比较流行。 键盘104键，有线，轴是Cherry的青轴，很有段落感，咔哒咔哒的感觉。键帽是PBT键帽，确实不会打油。后来被我换了几十一套的淘宝蓝色渐变键帽。 iKBC W200 绿色 红轴2021年购买，2.4G无线版本的iKBC键盘，有一个小接收器，配套笔记本使用的，87键，Cherry红轴。整体使用来说轴体触发位置比较靠上，力度较轻，不用摁到底，比较适合长时间写作、敲代码。 入门价位还是比较推荐的，做工没有太大的问题。 VROculus Quest 2真正感受元宇宙的最便宜解决方案 2021年购买，Facebook的产品，购买的话最好从美国亚马逊购买，第一次开机折腾起来相当费劲，最好有比较新可以刷固件的路由器，会节省很多麻烦，否则可能需要笔记本的虚拟网卡开热点，和能代理到网络层的方法，不可以用socks5这种代理到会话层的协议。 内向外四摄像头 + 物理运动定位，定位很准确，绝对不会丢定位，这点比Pico Neo 3好太多。 屏幕4k120hz，实际使用中难以避免纱窗效应，比显示器画质差太多，但有时纱窗效应不是很明显，刷新率很好，不会因为刷新率而感到眩晕。 观看了Youtube全景视频 使用《SKYBOX》通过局域网传输，模拟了电影院播放电影，重温《HELLO WORLD》。 通过SideQuest安装破解版，体验了一体机的节奏光剑《Beat Saber》，燥热《SUPERHOT》，滑翔伞模拟《RUSH》、真实乒乓球《Eleven Table Tennis》、攀岩2《The Climb 2》 使用SteamVR，通过WIFI串流，体验了《Half-Life Alyx》、《The Lab》、《VRChat》 插图1 - VRChat - 在中文吧自拍 家居用品米家台灯2017年购买，台灯是最早的版本，很漂亮，比较喜欢这种简洁的设计，小红线很和谐 光线可以接受，可以连接局域网，使用米家app控制台灯 小米80W无线充电2022年购买，接入67W的充电器可以实现对小米11 Pro功率50W的充电 外形很漂亮，很有设计感，适合作为桌面摆件 穿戴设备小米手环32018年购买，黑白界面，可以计步数，检测睡眠等一些小功能 小米手环42019年购买，彩色界面还挺好看的，换了一些彩色的腕带，主要还是用于看时间，睡眠情况的 游戏机Nintendo Switch OLED2022年购买，OLED屏幕比较大，色彩也还可以，频闪对于我来说没有太大的影响 首先玩了期待已久的《十三机兵防卫圈》，很喜欢 糖豆人也免费了，当然，还可以玩Apex 插图2 - 十三机兵防卫圈 - 冬坂五百里","categories":[{"name":"杂项","slug":"杂项","permalink":"https://x.lyxw.xyz/categories/杂项/"}],"tags":[{"name":"评测","slug":"评测","permalink":"https://x.lyxw.xyz/tags/评测/"},{"name":"电子产品","slug":"电子产品","permalink":"https://x.lyxw.xyz/tags/电子产品/"}]},{"title":"Python网络爬虫学习","slug":"python_web_crawler","date":"2022-01-11T17:01:20.000Z","updated":"2022-03-30T15:00:48.714Z","comments":true,"path":"2022/python_web_crawler/","link":"","permalink":"https://x.lyxw.xyz/2022/python_web_crawler/","excerpt":"更新于：A.D.2022.2.13","text":"更新于：A.D.2022.2.13 按模块学习urllib库json库按功能学习下载HTML源代码from urllib.request import urlopen import sys html = urlopen( &quot;url&quot; ).read().decode(&#39;utf-8&#39;) if sys.getdefaultencoding() == &#39;ascii&#39;: sys.stdout = open(&quot;2.输出html.html&quot;, &quot;w&quot;, encoding = &#39;gb2312&#39;) else: sys.stdout = open(&quot;2.输出html.html&quot;, &quot;w&quot;, encoding = &#39;utf-8&#39;) print(html) 下载网页图片from urllib.request import urlopen import urllib.parse import sys import re import os def getHtml(url): html = urlopen(url).read().decode(&#39;utf-8&#39;) return html def printImg(imgList, url): for i in imgList: imgName = i.split(&quot;/&quot;)[-1] imgPicture = urlopen(url + i) File = open(&#39;\\\\image\\\\&#39; + imgName, &#39;wb&#39;) File.write(imgPicture.read()) File.close() def downloadImg(url): html = getHtml(url) rule_1 = r&#39;&lt;img src=&quot;([^&quot;]+\\.png)&quot;&#39; rule_2 = r&#39;&lt;img src=&quot;([^&quot;]+\\.jpg)&quot;&#39; imgList_1 = re.findall(rule_1, html) printImg(imgList_1, url) imgList_2 = re.findall(rule_2, html) printImg(imgList_2, url) if __name__ == &#39;__main__&#39;: url = &quot;url&quot; downloadImg(url) 下载通知from urllib.request import urlopen import sys import re def getHtml(url): html = urlopen(url).read().decode(&#39;utf-8&#39;) return html def printList(list_1, list_2, list_3): if sys.getdefaultencoding() == &#39;ascii&#39;: sys.stdout = open(&quot;4.爬取通知.txt&quot;, &quot;w&quot;, encoding = &#39;gb2312&#39;) else: sys.stdout = open(&quot;4.爬取通知.txt&quot;, &quot;w&quot;, encoding = &#39;utf-8&#39;) for i in range(0, len(list_1)): print(&#39;#%d&#39; % (i+1)) print(&#39;标题：&#39; + list_2[i]) print(&#39;日期：&#39; + list_3[i]) print(&#39;网址：&#39; + &#39;url&#39; + list_1[i]) print(&#39;&#39;) def download(url): html = getHtml(url) rule_1 = r&#39;&lt;a target=&quot;_blank&quot; href=&quot;([^&quot;]+\\.htm)&quot;&gt;&#39; List_1 = re.findall(rule_1, html) rule_2 = r&#39;&lt;a target=&quot;_blank&quot; href=.*?&gt;(.*?)&lt;/a&gt;&#39; List_2 = re.findall(rule_2, html) rule_3 = r&#39;&lt;font color=&quot;#3a6399&quot;&gt;&amp;nbsp;&amp;nbsp;(.*?)&lt;/font&gt;&#39; List_3 = re.findall(rule_3, html) printList(List_1, List_2, List_3) if __name__ == &#39;__main__&#39;: url = &quot;url&quot; download(url) 下载任意页数通知from urllib.request import urlopen import sys import re def getHtml(url): html = urlopen(url).read().decode(&#39;utf-8&#39;) return html def printList(list_1, list_2, list_3): if sys.getdefaultencoding() == &#39;ascii&#39;: sys.stdout = open(&quot;5.爬取任意页数通知.txt&quot;, &quot;w&quot;, encoding = &#39;gb2312&#39;) else: sys.stdout = open(&quot;5.爬取任意页数通知.txt&quot;, &quot;w&quot;, encoding = &#39;utf-8&#39;) print(&#39;通知页数：第&#39; + pageNumber + &#39;页&#39;) print(&#39;&#39;) for i in range(0, len(list_1)): print(&#39;#%d&#39; % (i+1)) print(&#39;标题：&#39; + list_2[i]) print(&#39;日期：&#39; + list_3[i]) print(&#39;网址：&#39; + &#39;url&#39; + list_1[i]) print(&#39;&#39;) def download(url): html = getHtml(url) rule_1 = r&#39;&lt;a target=&quot;_blank&quot; href=&quot;([^&quot;]+\\.htm)&quot;&gt;&#39; List_1 = re.findall(rule_1, html) rule_2 = r&#39;&lt;a target=&quot;_blank&quot; href=.*?&gt;(.*?)&lt;/a&gt;&#39; List_2 = re.findall(rule_2, html) rule_3 = r&#39;&lt;font color=&quot;#3a6399&quot;&gt;&amp;nbsp;&amp;nbsp;(.*?)&lt;/font&gt;&#39; List_3 = re.findall(rule_3, html) printList(List_1, List_2, List_3) if __name__ == &#39;__main__&#39;: print(&#39;请输入需要爬取的通知页数：&#39;) pageNumber = input() url = &quot;url&quot; + pageNumber + &quot;.html&quot; download(url) Bilibili-Favorites-Download用于下载B站个人收藏夹信息 https://github.com/ShioKiri/Bilibili-Favorites-Download 因为调用一个外部网站API查询了失效视频且没有处理失败情况，目前因为API有一定问题，不能稳定运行，可以自行删去处理失效视频的代码使用 没有使用数据库和图形界面，直接保存为TXT或者CSV文件 生成TXT文件按照一定格式保存为TXT，推荐使用编辑器打开TXT避免速度过慢 from urllib.request import urlopen import json import re import time import sys import logging # -*- coding: UTF-8 -*- bilibili_uid = 0 aFavVideoCnt = 0 totVideoCnt = 0 totVideoNum = 0 def initUid(): global bilibili_uid bilibili_uid = int(input()) def getJsonUrl(url): Data = urlopen(url).read().decode(&#39;utf-8&#39;) jsonData = json.loads(Data) return jsonData def getFavoriteList(uid): global totVideoNum favoriteListUrl = &#39;https://api.bilibili.com/medialist/gateway/base/created?pn=1&amp;ps=100&amp;up_mid={uid}&amp;is_space=0&amp;jsonp=jsonp&#39;.format(uid=uid) favoriteListData = getJsonUrl(favoriteListUrl) listInfo = favoriteListData[&#39;data&#39;][&#39;list&#39;] favNum = len(listInfo) for i in range(0, favNum): totVideoNum += listInfo[i][&#39;media_count&#39;] for i in range(0, favNum): print(&#39;收藏夹编号:#%d 名称:%s 视频数量:%d\\n&#39; % (i+1, listInfo[i][&#39;title&#39;], listInfo[i][&#39;media_count&#39;])) getFavListVideo(uid, listInfo[i][&#39;fid&#39;]) def getFavListVideo(uid, fid): global aFavVideoCnt, totVideoCnt, totVideoNum aFavVideoCnt = 0 favPageUrl = &#39;https://api.bilibili.com/x/space/fav/arc?vmid={uid}&amp;ps=30&amp;fid={fid}&amp;tid=0&amp;keyword=&amp;pn={page}&amp;order=fav_time&amp;jsonp=jsonp&#39;.format(uid=uid,fid=fid,page=1) favPageDate = getJsonUrl(favPageUrl) printVideoInfo(favPageDate[&#39;data&#39;][&#39;archives&#39;]) pageCount = favPageDate[&#39;data&#39;][&#39;pagecount&#39;] for i in range(2, pageCount+1): favPageUrl = &#39;https://api.bilibili.com/x/space/fav/arc?vmid={uid}&amp;ps=30&amp;fid={fid}&amp;tid=0&amp;keyword=&amp;pn={page}&amp;order=fav_time&amp;jsonp=jsonp&#39;.format(uid=uid,fid=fid,page=i) favPageDate = getJsonUrl(favPageUrl) printVideoInfo(favPageDate[&#39;data&#39;][&#39;archives&#39;]) def printInfo(Info): print(&#39;投稿时间:&#39; + time.strftime(&quot;%Y-%m-%d-%H:%M:%S&quot;, time.gmtime(Info[&#39;pubdate&#39;]))) print(&#39;描述:%s&#39; % (Info[&#39;desc&#39;])) print(&#39;分区:%s&#39; % (Info[&#39;tname&#39;])) print(&#39;标签:%s&#39; % (Info[&#39;dynamic&#39;])) print(&#39;up主用户名:%s up主uid:%s&#39; % (Info[&#39;owner&#39;][&#39;name&#39;], Info[&#39;owner&#39;][&#39;mid&#39;])) print(&#39;播放:%s 弹幕:%s 回复:%s 收藏:%s 硬币:%s 分享:%s 喜欢:%s&#39; % (Info[&#39;stat&#39;][&#39;view&#39;], Info[&#39;stat&#39;][&#39;danmaku&#39;], Info[&#39;stat&#39;][&#39;reply&#39;], Info[&#39;stat&#39;][&#39;favorite&#39;], Info[&#39;stat&#39;][&#39;coin&#39;], Info[&#39;stat&#39;][&#39;share&#39;], Info[&#39;stat&#39;][&#39;like&#39;],)) print(&#39;收藏时间:&#39; + time.strftime(&quot;%Y-%m-%d-%H:%M:%S&quot;, time.gmtime(Info[&#39;fav_at&#39;]))) print() def printVideoInfo(aPageInfo): global aFavVideoCnt, totVideoCnt, totVideoNum for i in range(0, len(aPageInfo)): aFavVideoCnt += 1 totVideoCnt += 1 if totVideoCnt % 10 == 0 or totVideoCnt == totVideoNum: logging.info(&#39;已经完成了{num1}/{num2}个视频...&#39;.format(num1 = totVideoCnt,num2 = totVideoNum)) Info = aPageInfo[i] video_id = Info[&#39;aid&#39;] if Info[&#39;title&#39;] == &#39;已失效视频&#39;: getInvalidVideoInfo(video_id, Info) else: print(&#39;视频编号:#%d AV号:%d 视频标题:%s&#39; % (aFavVideoCnt, Info[&#39;aid&#39;], Info[&#39;title&#39;])) print(&#39;封面图片:%s&#39; % (Info[&#39;pic&#39;])) printInfo(Info) biliplusApiCnt = 0 runTime = 0 def getInvalidVideoInfo(video_id, Info): global aFavVideoCnt, biliplusApiCnt, runTime biliplusApiCnt += 1 while biliplusApiCnt / ((time.time() - runTime) / 60.0) &gt;= 5: time.sleep(1) url = &#39;https://www.biliplus.com/api/view?id={vid}&#39;.format(vid = video_id) InvVideoInfo = getJsonUrl(url) if &#39;code&#39; in InvVideoInfo: print(&#39;视频编号:#%d [已失效][BiliplusApi数据缺失] AV号:%d 视频标题:已失效视频&#39; % (aFavVideoCnt, video_id)) print(&#39;封面图片:%s&#39; % (Info[&#39;pic&#39;])) printInfo(Info) else: print(&#39;视频编号:#%d [已失效][BiliplusApi获得标题与封面图片] AV号:%d 视频标题:%s&#39; % (aFavVideoCnt, video_id, InvVideoInfo[&#39;title&#39;])) print(&#39;封面图片:%s&#39; % (InvVideoInfo[&#39;pic&#39;])) printInfo(Info) def start(): # for cmd global totVideoNum, runTime logging.basicConfig(level=logging.DEBUG) if sys.getdefaultencoding() == &#39;ascii&#39;: sys.stdout = open(&quot;FavoriteVideoList.txt&quot;, &quot;w&quot;, encoding = &#39;gb2312&#39;) else: sys.stdout = open(&quot;FavoriteVideoList.txt&quot;, &quot;w&quot;, encoding = &#39;utf-8&#39;) initUid() runTime = time.time() getFavoriteList(bilibili_uid) print(&#39;你的收藏夹共有%d个视频&#39; % (totVideoNum)) logging.info(&#39;已完成！&#39;) # def windowMain(Uid, filePath): # for window ui if __name__ == &#39;__main__&#39;: # cmd start() 生成CSV文件生成可以用Excel打开的逗号分隔值文件，因为Unicode(UTF-8)文件头没有BOM编码会导致编码错误（后期会处理），可以使用Notepad++修改Unicode(UTF-8)为ANSI，或者修改为带BOM编码格式的Unicode(UTF-8)文件。 from urllib.request import urlopen import json import re import time import sys import logging # -*- coding: UTF-8 -*- bilibili_uid = 0 aFavVideoCnt = 0 totVideoCnt = 0 totVideoNum = 0 def initUid(): global bilibili_uid bilibili_uid = int(input()) def getJsonUrl(url): Data = urlopen(url).read().decode(&#39;utf-8&#39;) jsonData = json.loads(Data) return jsonData def getFavoriteList(uid): global totVideoNum print(&#39;收藏夹编号,收藏夹名称,收藏夹视频数量,视频编号,AV号,视频状态,视频标题,封面图片,投稿时间,描述,分区,标签,up主用户名,up主uid,播放,弹幕,回复,收藏,硬币,分享,喜欢,收藏时间,&#39;) favoriteListUrl = &#39;https://api.bilibili.com/medialist/gateway/base/created?pn=1&amp;ps=100&amp;up_mid={uid}&amp;is_space=0&amp;jsonp=jsonp&#39;.format(uid=uid) favoriteListData = getJsonUrl(favoriteListUrl) listInfo = favoriteListData[&#39;data&#39;][&#39;list&#39;] favNum = len(listInfo) for i in range(0, favNum): totVideoNum += listInfo[i][&#39;media_count&#39;] for i in range(0, favNum): favInformation = &#39;#{x1},{x2},{x3}&#39;.format(x1=i+1, x2=listInfo[i][&#39;title&#39;], x3=listInfo[i][&#39;media_count&#39;]) getFavListVideo(uid, listInfo[i][&#39;fid&#39;], favInformation) def printInfo(Info): print(time.strftime(&quot;%Y-%m-%d-%H:%M:%S&quot;, time.gmtime(Info[&#39;pubdate&#39;])), end=&#39;,&#39;) print(&#39;&quot;%s&quot;&#39; % (Info[&#39;desc&#39;]), end=&#39;,&#39;) print(&#39;&quot;%s&quot;&#39; % (Info[&#39;tname&#39;]), end=&#39;,&#39;) print(&#39;&quot;%s&quot;&#39; % (Info[&#39;dynamic&#39;]), end=&#39;,&#39;) print(&#39;&quot;%s&quot;,&quot;%s&quot;&#39; % (Info[&#39;owner&#39;][&#39;name&#39;], Info[&#39;owner&#39;][&#39;mid&#39;]), end=&#39;,&#39;) print(&#39;%s,%s,%s,%s,%s,%s,%s&#39; % (Info[&#39;stat&#39;][&#39;view&#39;], Info[&#39;stat&#39;][&#39;danmaku&#39;], Info[&#39;stat&#39;][&#39;reply&#39;], Info[&#39;stat&#39;][&#39;favorite&#39;], Info[&#39;stat&#39;][&#39;coin&#39;], Info[&#39;stat&#39;][&#39;share&#39;], Info[&#39;stat&#39;][&#39;like&#39;],), end=&#39;,&#39;) print(time.strftime(&quot;%Y-%m-%d-%H:%M:%S&quot;, time.gmtime(Info[&#39;fav_at&#39;])), end=&#39;,&#39;) print() def getFavListVideo(uid, fid, favInfo): global aFavVideoCnt, totVideoCnt, totVideoNum aFavVideoCnt = 0 favPageUrl = &#39;https://api.bilibili.com/x/space/fav/arc?vmid={uid}&amp;ps=30&amp;fid={fid}&amp;tid=0&amp;keyword=&amp;pn={page}&amp;order=fav_time&amp;jsonp=jsonp&#39;.format(uid=uid, fid=fid, page=1) favPageDate = getJsonUrl(favPageUrl) printVideoInfo(favPageDate[&#39;data&#39;][&#39;archives&#39;], favInfo) pageCount = favPageDate[&#39;data&#39;][&#39;pagecount&#39;] for i in range(2, pageCount+1): favPageUrl = &#39;https://api.bilibili.com/x/space/fav/arc?vmid={uid}&amp;ps=30&amp;fid={fid}&amp;tid=0&amp;keyword=&amp;pn={page}&amp;order=fav_time&amp;jsonp=jsonp&#39;.format(uid=uid, fid=fid, page=i) favPageDate = getJsonUrl(favPageUrl) printVideoInfo(favPageDate[&#39;data&#39;][&#39;archives&#39;], favInfo) def printVideoInfo(aPageInfo, favInfo): global aFavVideoCnt, totVideoCnt, totVideoNum for i in range(0, len(aPageInfo)): print(favInfo, end=&#39;,&#39;) aFavVideoCnt += 1 totVideoCnt += 1 if totVideoCnt % 10 == 0 or totVideoCnt == totVideoNum: logging.info(&#39;已经完成了{num1}/{num2}个视频...&#39;.format(num1=totVideoCnt, num2=totVideoNum)) Info = aPageInfo[i] video_id = Info[&#39;aid&#39;] if Info[&#39;title&#39;] == &#39;已失效视频&#39;: getInvalidVideoInfo(video_id, Info) else: print(&#39;#%d,%d,[有效],&quot;%s&quot;,&quot;%s&quot;&#39; % (aFavVideoCnt, Info[&#39;aid&#39;], Info[&#39;title&#39;], Info[&#39;pic&#39;]), end=&#39;,&#39;) printInfo(Info) biliplusApiCnt = 0 runTime = 0 def getInvalidVideoInfo(video_id, Info): global aFavVideoCnt, biliplusApiCnt, runTime biliplusApiCnt += 1 while biliplusApiCnt / ((time.time() - runTime) / 60.0) &gt;= 5: time.sleep(1) url = &#39;https://www.biliplus.com/api/view?id={vid}&#39;.format(vid = video_id) InvVideoInfo = getJsonUrl(url) if &#39;code&#39; in InvVideoInfo: print(&#39;#%d,%d,[失效][BiliplusApi数据缺失],已失效视频,(·w·)&#39; % (aFavVideoCnt, Info[&#39;aid&#39;]), end=&#39;,&#39;) printInfo(Info) else: print(&#39;#%d,%d,有效,&quot;%s&quot;,&quot;%s&quot;&#39; % (aFavVideoCnt, Info[&#39;aid&#39;], InvVideoInfo[&#39;title&#39;], InvVideoInfo[&#39;pic&#39;]), end=&#39;,&#39;) printInfo(Info) def start(): # for cmd global totVideoNum, runTime logging.basicConfig(level=logging.DEBUG) if sys.getdefaultencoding() == &#39;ascii&#39;: sys.stdout = open(&quot;FavoriteVideoList.csv&quot;, &quot;w&quot;, encoding = &#39;gb2312&#39;) else: sys.stdout = open(&quot;FavoriteVideoList.csv&quot;, &quot;w&quot;, encoding = &#39;utf-8&#39;) initUid() runTime = time.time() getFavoriteList(bilibili_uid) print(&#39;你的收藏夹共有%d个视频&#39; % (totVideoNum)) logging.info(&#39;已完成！&#39;) # def windowMain(Uid, filePath): # for window ui if __name__ == &#39;__main__&#39;: # cmd start()","categories":[{"name":"编程","slug":"编程","permalink":"https://x.lyxw.xyz/categories/编程/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://x.lyxw.xyz/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://x.lyxw.xyz/tags/爬虫/"}]},{"title":"「观测者轻语」杂谈","slug":"talk_1","date":"2021-08-08T02:18:09.000Z","updated":"2022-02-12T17:28:12.824Z","comments":true,"path":"2021/talk_1/","link":"","permalink":"https://x.lyxw.xyz/2021/talk_1/","excerpt":"1.关于生活意义 2.关于电子游戏 3.关于编程学习","text":"1.关于生活意义 2.关于电子游戏 3.关于编程学习 关于生活意义一般情况下，以存在主义的前提来看： 1.在社会生活中获得一定质量的物质与精神享受，将意识存在能力发挥在部分个人愿望的实现，享受意识存在的过程。 例：学习喜欢的科学知识，欣赏喜欢的文化产品，进行一定程度的社会交际并获取社会认同感 2.参与实现更高的社会意识形态的过程，参与对物质世界的利用和改造 例：为无产阶级革命做出贡献，为社会生产做出贡献 关于电子游戏电子游戏作为一个近代的产物，具有极大的争议，不过具有成瘾性的游戏或许并不是一个有意义的游戏，我对此的理解为游戏作为一种事物的存在形式，一个合理且富有存在意义的电子游戏应该是至少具有一下三种性质中其中一种的通过电子计算机与计算机网络运行的交互程序。 艺术性图像、音乐、视频、文本可以作为一种游戏的子集。 正如文本可以构造剧情，图像可以表现艺术，音乐可以显露和谐，视频可以记录实际，这四种艺术形式在合理的运用下可以表现出独特的效果，那么游戏则可以包容不同艺术独特的优点，例如视觉小说。 游戏性一定规则的游戏可以作为竞技的手段，这类游戏与电子计算机出现之前的棋牌类游戏有一定的相似之处，只不过规则与算法复杂化了，例如反恐精英，DOTA2。 一定规则的游戏可以作为发挥个人创造能力的空间，满足非专业设计的创造满足感，例如模拟经营类游戏戴森球计划，沙盒游戏我的世界。 抽象性游戏也可以作为对现实世界的抽象，无论是3D建模还是物理引擎的设计都是基于现实世界的真实数学物理模型所做的简化操作，我们不可能通过模拟每一个原子的运动来建构一个世界，但可以通过对宏观现象的简化性描述来开始进行建构新的一个世界的起点。 例如开放世界游戏GTA5，看门狗2 Jason Gregory.游戏引擎架构[M]北京：电子工业出版社，2014. 关于编程学习信息资源的获取有问题尽量使用谷歌，学会查找阅读文档，出现bug也可以尝试用stackoverflow搜索，很多时候使用英文搜素更可能找到有用的解决方案。 各种工具的用法熟悉git和github的用法，可以先自己搭一个hexo博客试试，然后可以学习使用各种现代ide和编辑器，一开始学习可以使用ide（编辑器要配置不同语言的开发环境），但是一些依赖项的环境配置还是很难避免的。实际编程肯定也会使用更多的辅助工具，比如数据库的图形化显示。 学习顺序与学习内容我推荐先学习C++，这样可以建立对常用编程语言的快速学习能力，使用C++语言学习数据结构和算法，因为一来招聘会考算法，二来这方面会建立一些实际编程中一般性的思路。之后可以看CS的基础内容（操作系统，计算机组成，计算机网络，编译原理），学一些语言（Python、C#、Java）和开发框架（例如Spring Boot、Flutter），写一些实际项目（例如Windows桌面应用，Unity或者UE4游戏，网页前后端等），学习设计模式等软件开发的内容。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://x.lyxw.xyz/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://x.lyxw.xyz/tags/杂谈/"}]},{"title":"落影汐雾的记录集","slug":"record_set","date":"2021-07-31T20:33:26.000Z","updated":"2022-03-22T15:03:05.775Z","comments":true,"path":"2021/record_set/","link":"","permalink":"https://x.lyxw.xyz/2021/record_set/","excerpt":"最后更新：A.D.2022.2.13 这篇文章大概就是用来在网页上看看的……\\ (￣︶￣\\ *))","text":"最后更新：A.D.2022.2.13 这篇文章大概就是用来在网页上看看的……\\ (￣︶￣\\ *)) 缓缓的河流绕过泛黄的长廊 ~ 过往烟云 网站历史 日期 字符串 2019.6 搭建了此Blog 2019.9.12 购买了域名66ccff.xyz 2019.9.22 用HTML5 up模板制作个人主页并使用域名66ccff.xyz，Blog改为二级域名blog.66ccff.xyz 2019.9.22 往主域名下加了几个网页游戏 2019.11.04 创建了Virtual Dimension页面 2020.8.16 购买了域名lyxw.xyz 2021.9.10 开始这样一个新的世界 生活随想 日期 字符串 2019.6 词语时光 岁月 年华 2019.9.7 读完了《白鹿原》 2019.9.8 吃了一颗柠檬 2019.9.10 开坑套接字 2019.9.14 看完了刀剑神域Animation的SAO篇 2019.9.15 打了第一场Codeforces和AtCoder 亲切的遥远 温柔的岁月 就是那样的一个世界 ~ 虚拟维度 歌词 Lyrics Song 每一个梦都是个旋律 漫天回忆该如何去聆听 Step on your heart -心印-(Album ver) Luna Safari 晨风中的一缕光 折射梦想的宽广 Trii - Feel Your Dream 2018 亲切的遥远 温柔的岁月 就是那样的一个世界 枝江 缓缓的河流绕过泛黄的长廊 她们的故事慢慢讲 枝江 如果还能找到你 就让风儿告诉你 Artificial Emotions 虚和实的叠重 光和影的交错 触摸流云和清风勾勒的美梦 寻遍星空 夜雾里去闪烁 光年外去诉说 让星辉照耀我浩瀚的宇宙 寻遍星空 风 将我的思绪打乱 也看不清未来 梦 穿越过人山人海 快要醒来 化尘旅行 阳光斜照进窗台，记忆皆化作尘埃 化尘旅行 将漂浮的声音都吞没 描绘着贝壳上的轮廓 趁暮色未干枯 让泪水藏匿那 未曾见过的颜色 涟漪 纵流光如水逝尽千年的河川 一梦又脉脉涨满 流光逝梦 曙神星的尘埃 镶嵌漆黑缎带 它们各自旋转 轨迹精密切开 尘降 琴瑟愿与 共沐春秋 滢溪潺潺 炊烟悠悠 白石溪 唱 你给我的梦想 在天空中回荡 就像那风一样 吹向四面八方 唱给雅音宫羽Ⅱ 没有叹息的别离 飘散在 十一月的秋风里 浔阳江 至少此刻我们的心意相连 愿那片纯蓝天空一般高远 纯蓝 寻觅着 风的波折 世末歌者 初夏的蝉鸣声 轻轻掠过耳边的风 火花 夏露秋霜，匆匆十载 记忆里的人都裁开 梨花泽泽远山远 踏上未知列车 一直飞到云层最高空 一日都市 在屏幕那边 天涯般遥远 心跳同步的时光 穿越过浩瀚星间 经历过无数世界 看时光交替更迭 星愿StarWish 接一片 落雪在温热掌心 街道光斑交映 排列节日的讯息 冬去春来再尽年 その日、眺めていた校庭は 薄く青い空が染みていて Euphoria 偏离了航道 任黑夜吞噬 安静等待轨迹的放逐 坠落星空 觥筹恍惚交杯 劝留几小杯 棋逢红颜一醉 千军万马退 苏幕遮 寻寻觅觅 冷冷清清 月落乌啼月牙落孤井 声声慢 未实现的誓言 穿过似水华年 没写完的诗篇 应该如何重现 不存在的夏天 横平竖直点捺勾折皆变化 笔走龙蛇墨书春秋尽潇洒 横竖撇点折 聊以数笔写遍古今的繁华 出经入典顾自将历史传达 横竖撇点折 当火焰划破夜空 我落入银河雨中 当所有人抬起头 凝望着短暂的梦 倒数到零 天山千里雪 伸手拦一拦 花雕敬一盏 请为我开颜 不问天 若不是《浣溪沙》把《秋夜月》儿掩 我怎会困守《牧羊关》 繁华唱遍 我自那 皑皑冰川经行过 笔尖被霜雪尽然覆没 烈火灼冰 渐渐 渐渐 渐渐 我也将追逐遥远 循着八月的思恋 夏日延长战 曾经在天空绽放过的刹那烟火 熄灭后会落在城市的哪个角落 刹那烟火，落尽清凉 人设Vocaloid 名称A 名称B 归属 $\\color{rgb(102,204,255)}{洛天依}$ Luo Tianyi 天矢禾念 $\\color{rgb(238,0,0)}{乐正绫}$ Yuezheng Ling 天矢禾念 $\\color{rgb(0,255,204)}{言和}$ Yan He 天矢禾念 $\\color{rgb(153,153,255)}{ 星尘Stardust }$ Stardust 平行四界 $\\color{rgb(238,130,238)}{心华}$ Xin Hua 上海望乘 $\\color{rgb(255,192,203)}{IA}$ イア 1st PLACE $\\color{rgb(57,197,187)}{初音未来}$ 初音ミク Crypton Synthesizer V 名称 代表物 团体 / 归属 赤羽 正四面体 五维介质 / 平行四界 苍穹 正八面体 五维介质 / 平行四界 诗岸 六面体 五维介质 / 平行四界 海伊 二十面体 五维介质 / 平行四界 星尘Minus 梅塔特隆立方体（星形八面体） 五维介质 / 平行四界 虚拟偶像 名称A 名称B 团体 / 归属 嘉然(Diana) 嘉然今天吃什么 A-SOUL / 乐华娱乐 &amp; 字节跳动 永远酱 永远永远酱w 独立Vup 阿梓(Azusa) 阿梓从小就很可爱 VirtuaReal Link 新科娘 心萪 CCTV新科动漫 鸠羽伦 鳩羽つぐ 独立VTuber 七海Nana7mi 010 VirtuaReal 白神遥 Shirakami Haruka Project SP ACGN作品动画 名称 开始日期 ~ 完成日期 Re：从零开始的异世界生活 2016.10 ~ 2016.12 埃罗芒阿老师 2017.4 ~ 2017.6 BLACK★ROCK SHOOTER OVA 2015.5 ~ 2017.7 非人哉 2019.1 ~ 2019.2 刀剑神域 第一季 2019.9 ~ 2019.9.30 月色真美 2017.4 ~ 2019.10.4 云之彼端，约定的地方 2019.10 ~ 2019.11 Charlotte 2020.7 ~ 2020.8 Angel Beats! 2017.10 ~ 2020.8 我的妹妹不可能那么可爱 第一季 2013.7 ~2020.8 我的妹妹不可能那么可爱 第二季 2013.7 ~ 2020.8 魔法少女小圆 2017 ~ 2021.9 玉子市场 2020.1 ~ 摇曳百合 2017.9 ~ 境界的彼方 2019.9 ~ 轻音少女 2018 ~ 中二病也要谈恋爱 2017 ~ 凉宫春日的忧郁 2020.8 ~ 稻荷恋之歌 2020.1 ~ 冰菓 2021 ~ 樱花庄的宠物女孩 2019 ~ 动画电影 名称 完成日期 大鱼海棠 2016.7 你的名字 2017.10 声之形 2019.8 天气之子 2019.11.2 HELLO WORLD 你好世界 2020.3 视觉小说Visual Novel 名称 开始日期 ~ 完成日期 NEKOPARA Vol.0/1/2 2016 ~ 2017.4 妄想症：Deliver Me . ~ 2018.8 美少女万华镜 1 2017 ~ 2018.11 KARAKARA 1 2017 ~ 2019.7 千恋*万花 2019.8 ~ 2020.1 魔女的夜宴 2019.8 ~ 2020.2 沙耶の唄 2013.7 ~ 2020.2 Doki Doki Literature Club! 2019 ~ 2020.2 君と彼女と彼女の恋 . ~ 2020.2 Narcissu 1st . ~ 2020.3 Ever17 —the out of infinity— 2019 ~ 2020.3 しゅがてん!-sugarfull tempering- 2020.1 ~ 恋×シンアイ彼女 2020.1 ~ 2021.10 Summer Pockets 2020.1 ~ eden* 2020.2 ~ 三色绘恋 Tricolour Lovestory 2020.1 ~ Riddle Joker 2020.2 ~ 枝江往事 2021.7 ~ 恋爱绮谭~不存在的夏天~ 2019 ~ 2021.7 LOOPERS 2021.6 ~ 2021.9 青空下的加缪 2021.1 ~ Clover Day’s 2021.1 ~ 轻小说 名称 完成日期 [伏见つかさ].我的妹妹不可能那么可爱 2020.8 [谷川流].第1卷 凉宫春日的忧郁 2020.8 视频Bilibili Macro Link-Visual Release 2019 【⚡️ 热 爱 1 0 5 ° C 的 然 然⚡️ 】 【嘉然/100W庆祝】“我们只是朋友？”𝓕𝓻𝓲𝓮𝓷𝓭𝓼【MMD/PV】 “想把夏天的橘子汽水，卖给颜料用完的梵高。” 【4K/完整版】","categories":[{"name":"杂项","slug":"杂项","permalink":"https://x.lyxw.xyz/categories/杂项/"}],"tags":[{"name":"记录","slug":"记录","permalink":"https://x.lyxw.xyz/tags/记录/"}]},{"title":"夏日小日记","slug":"diary_1","date":"2021-07-29T02:18:09.000Z","updated":"2022-04-12T14:59:56.692Z","comments":true,"path":"2021/diary_1/","link":"","permalink":"https://x.lyxw.xyz/2021/diary_1/","excerpt":"o(=•ェ•=)m 以此或多或少记录下一点暑假的生活 \\ (￣︶￣\\ *))","text":"o(=•ェ•=)m 以此或多或少记录下一点暑假的生活 \\ (￣︶￣\\ *)) 6.7-6.106.7第一天上午语文没什么特殊的地方，中规中矩弄完，十分幸运地在文言文翻译提笔忘字，诗歌看不太懂写了一堆废话（大概是寄了😭，发现选择也错了），考完感觉就……还挺正常的。 中午食堂的饭挺好吃的，也不想多聊天。 下午好热，考试的时候特别焦燥，数学选择第八题把概念弄错了，然后第十二题匆匆看完AB选项选了一个不太想接着做了，接着……第四个填空第二个空算错好几次，最后还把n写成k了日。这时候已经快开考一个小时了，心里开始很慌张，第三个大题写成了$cos(A)=cos(\\pi-A)$😅，第四个大题把底面画错了，虽然后面做对了可都错了靠前的步骤，第五第六个大题就剩了15分钟，匆匆写了一问，圆锥联立韦达了一下，导数考的东西学得也不太会。考完出来就烦得要命，还特别热……想了想也很无奈，不过我同桌勇敢和对答案发现比我更惨，不想说什么了。 晚上想了想发现写错了字母……心态有点不太好。 第二天上午来了聊聊天，课间出去走了走，心里估计可能只能上600分了（事实也是这样）。 下午英语的难度刚好能让我看懂，到时间刚刚写完作文，挺正常的。这两天搬到了实验室，圆凳真是坐得让人腰疼得要死🥵。心态还算好，希望化学别裂开。 第三天物理前面都还好，最后一题出个弹簧一直都不太会，估计没分了。化学单选都记不清知识点，多选后两个依然不会，有机倒是倒推完，就能全写出来了，最后一题发挥想象力编了几个空上去。 晚上一直在想考完怎么玩半天没睡着…… 最后一天考试的时候下起来了雨，感觉很期待结束，但是也不着急。生物多选后四个可能都单选了，遗传就会前三个空，基因工程一个不会，猜了一个酶切位点和用想象力写满了这个题，考完两个大题只会三个空，都不好说什么了。挺难受的……最有把握的数学就这么寄了😥。出来还下大雨，淋了半天才出校门😰。 出了成绩感觉和想象的差不多，最后……专业没去什么天坑🥰，我真是感恩戴德。 6.10 - 6.306月10日中午天晴了，去河边转了转，下午回去收拾了教室。很怅然若失吗？ 6月23日去了毕业典礼，去了机房，也是最后一次回高中。 7.1 - 7.28考了科目一，玩游戏，买了csgo深海复仇的ak47皮肤，又买了只狼、死亡细胞、undertale、恋爱绮谭，报志愿，查录取结果，买了电脑和ipad。 7.29台风到了但是雨下得不是特别大，早晨起来先给域名续了费，namesilo买的xyz域名，第一年0.99美元，续费9.29美元，namesilo用起来还是挺靠谱的。 现在早上要去练车，不过下雨了难得放个假，早饭先去吃了一包火鸡面，依旧是等录取通知书的一天。 终于收集够了原神雪山的80个绯红玉髓，因为我想要那个翅膀…… 今天把台式机上的博客源文件之类的东西用局域网转移到笔记本上来了。 晚上和同学打csgo和gta5，麦克风又出了点小问题，调了半天。 7.30今天上午接着练车，倒车入库…… 中午apple pencil到了，ems还要签收签字，不得不说ems送件员工的工作态度是真的好。 好像要下周三才能发录取通知书了= =真是绝了。 中午雨过天晴后难得有这么清澈的阳光啊了，天很蓝。 又睡了一下午，不怎么想玩了，随便翻翻书了，晚上想看看K-On，或许是因为看到了某虚拟偶像的事。 不知不觉就快到八月了。 7.31上午练车，其余时间睡觉。 8.1睡觉，拿ems快递，试水airpods听听歌，漫无止境的八月到了。 8.2中午把node.js环境之类的东西配一下，设置一下github的ssh密钥，调整了一下blog。 8.3光猫坏了……等明天来修，出去骑车转转。 8.4今天不用练车，录取通知书终于发货了，ems应该明天就能到。 8.5中午通知书到了，开箱。 下午找同学玩，交流一番，有可爱的猫猫和狗，喝了咖啡豆磨的咖啡。 8.6在家，无事，阅读CSAPP，浏览bilibili、zhihu等网络平台 8.7立秋，下午试了试基岩版我的世界光线追踪，晚上和同学出去聊天，回忆高中生活。 8.8晨起，写一点东西。 下午去工商银行改一下预留信息…… 买了ipad保护套。 8.9睡了一天觉，买了《心庭荧彩》 8.10中午看了一点CSAPP，下午和同学玩你画我猜，接龙模式笑死了。买了个四级的题看看。 8.11 - 8.25开箱ipad，用ipad试试看了一点网络的书。看了一点数字电路 20号去考了科目二，好累…… 和同学出去吃火锅 收拾了开学物品 8.26初中同学聚会 8.27来报到，去领了好多小礼品 8.28早上去工商银行补办了因为曾用名问题没有随录取通知书寄送的银行卡 8.30上午下雨，下午开学典礼，躺平 8.31军训，下大雨，躺平 9.1军训，去海边拉练，听各种讲座，本篇至此结束","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://x.lyxw.xyz/categories/杂谈/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://x.lyxw.xyz/tags/日记/"}]},{"title":"一切都结束了","slug":"end_1","date":"2021-06-26T07:33:26.000Z","updated":"2022-02-12T15:55:30.946Z","comments":true,"path":"2021/end_1/","link":"","permalink":"https://x.lyxw.xyz/2021/end_1/","excerpt":"也确实到了结束的的时候了","text":"也确实到了结束的的时候了 我的高中生活就这么结束了，很多时候确实是有趣的，但都很遥远，也很模糊了。 我一直能回想起各种各样的事，以后可能会再慢慢记录下来吧。 最终的纪念品","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://x.lyxw.xyz/categories/杂谈/"}],"tags":[{"name":"回忆","slug":"回忆","permalink":"https://x.lyxw.xyz/tags/回忆/"}]},{"title":"MMD制作简介","slug":"MMD","date":"2020-08-19T14:22:39.000Z","updated":"2020-08-20T01:02:07.511Z","comments":true,"path":"2020/MMD/","link":"","permalink":"https://x.lyxw.xyz/2020/MMD/","excerpt":"刚刚做的：【MMD/洛天依】你是分割我人生的线 又将它们相连~勾指起誓 [1080p60fps]","text":"刚刚做的：【MMD/洛天依】你是分割我人生的线 又将它们相连~勾指起誓 [1080p60fps] 做了一个MMD 先写一下用到的所有内容 模型：TDA 改变学院风洛天依.pmx by 星空下の轩雨 动作：勾指起誓-柔美版-动作数据.vmd by-2TIGers（呆喵挠琴） 镜头：(Camera DL) 勾指起誓.vmd by SakuraHayato 场景：skura no ame.pmx by 挽挽姌School_Desk_Chair_TypeA.pmx by 下校 MME：Rui_cg：ray-mmd-1.5.0そぼろ：AutoLuminous4,Diffusion7おたもん：likelooksBYビームマンP：Sakura_v2_32_64_MMMiKeno,RedialC：ikClut_RCikeno：ikBokeh 工具：Miku Miku DanceAdobe Premiere ProAdobe After Effects 简单讲一下制作步骤 获取软件及资源并学习如果制作一个MMD主要需要场景、人物模型、动作数据等，如果我们需要用到别人制作好的内容时，在作者允许使用的情况下注明原作者，即写清借物表。如果选择自己制作，可以制作其中的一项数据，比如使用3D建模软件例如Blender等制作场景及人物模型，在MMD中编辑动作数据等。 软件获取我提供一个 https://pan.baidu.com/s/1yJnCEJI6fSHhH3IkNHM4nA pnx9 资源获取善用搜索引擎可以解决大部分问题 介于之后需要访问大量墙掉的网站，需要准备某些工具，并且需要会在GitHub网页上进行阅读及操作和在大量日文网站上进行操作，所以还需要一个带有翻译功能的浏览器。 参考：https://web.archive.org/web/20160622040846/http://konobaka.com/post/400994_16e51be (已删除，使用wayback machine查看，需要某些工具) https://xywiki.com/MMD https://blog.csdn.net/NSJim/article/details/105743730 以上是几篇对各种内容介绍比较全的文章 这是MME的资源站点：https://w.atwiki.jp/vpvpwiki/pages/272.html 你会经常访问到的网站：https://seiga.nicovideo.jp/ https://www.nicovideo.jp/ https://bowlroll.net/ 一些MME资源：https://onedrive.live.com/?id=EF581C37A4524EDA%21108&amp;cid=EF581C37A4524EDA （注意是onedrive，需要使用工具） 我提供一些，东西挺多的：https://pan.baidu.com/s/1whV2t1uWZHxvq63K3McKkg i5b1 学习软件及MME使用出现问题善用搜索引擎 参考：https://www.bilibili.com/read/cv135853 https://space.bilibili.com/11831050 https://www.bilibili.com/read/cv2529911 进行MMD制作并导出原始文件 注意看一下上面的界面，首先除音频外所有内容都可以直接拖拽进入程序内，左下角第二栏是切换.pmx文件控制的内容的，在模型操作栏内切换到照明一栏时，在附件操作栏内可以切换.x文件控制的内容，右上角MMEffect控制部分MME的功能。其余内容不复杂，可以用b站或搜索引擎简要学习，或者说哪里需要使用就学习哪个部分。 导出时帧率选择60fps，录制范围选择0~结束帧，不要勾选导出音频，可能出现bug，在后期编辑的时候加入音频。 注意选择空余较大的硬盘分区，一分钟1080p60fps原始视频会占用大约30G空间。 后期处理及压制后期处理后期编辑时我们需要使用编辑软件加入音频，进行剪辑以及其他操作，推荐使用Pr和Ae。 我们看一下Pr的界面。 我们可以直接把需要的资源拖拽到左侧一栏中，在右侧下方一栏，下方四条轨道是音轨，我们把音频拖拽到上方，然后可以选择顶栏的音频一项进行调整。上方四条轨道是四个图层，上方的图层可以覆盖下方的图层，并且可以新建图层，这里我们把视频放在V1图层并且把视频和音频轨道对齐，多个视频也要对其，上方的图层可以增加特效和字幕，这里我用Ae制作字幕，V4轨道的字幕在右侧，V3轨道的字幕在左侧，在导出时一定要注意选择视频码率和音频码率及采样率，选择H.264即mp4格式，注意分辨率帧率保持与原视频一致。如果需要不被b站二压的话视频码率不能超过6000 KB/s，音频码率不能超过320 KB/s，并且采样率一定要为44100 Hz。 参考b站官方的规定： http://www.bilibili.com/read/cv311112 http://www.bilibili.com/read/cv527957 Pr Ae的导出快捷键都是Ctrl+M，这里看一下导出界面，一定注意红框内的内容是否正确。 然后我们看一下Ae的这个字幕是怎么做的。 首先单击新建合成，注意接下来弹出的合成设置，将分辨率和帧速率设置成与你的视频相同，持续时间我们选10s。 接下来看下图，我们先单击1箭头指向的按钮，使画面变为透明，然后使用2箭头的工具在视频中选择合适的位置书写字幕。 之后在右侧一栏中调整字体等内容。最后我们制作特效。 选择菜单栏-窗口-效果和预设，之后在右侧出现这一栏内容，选择其中的*动画预设-Text-Blurs-蒸发拖动到字幕上，当然也可以是其他内容。这个效果仅有出场效果，所以我们点击字幕，按下u键，找到动画的关键帧，两个关键帧分别为动画开始与动画结束。接下来用鼠标拖动选中两个关键帧并移动位置，之后按下复制快捷键复制两个关键帧，而后移动箭头，然后按下粘贴快捷键粘贴到前方，这时交换前方两个关键帧的位置，后方两个关键帧保持不变，这样前方的动画就变成了入场效果。最后调整这四个关键帧的位置，并且选择上方的第二行的按钮进行切片。 最后进行导出，按下Ctrl+M，按123步骤操作下图界面。 步骤1：如图进行调整，如果没有安装QuickTime就去安装。步骤2：选择输出路径。步骤3：点击渲染。 最后将输出好的mov文件拖拽进入Pr进行对轨操作即可，如果有重合的部分可以用两条轨道交错放置字幕。 压制参考：https://www.bilibili.com/read/cv954478/ 使用小丸工具箱即可，可以先压制再在Pr中进行编辑。","categories":[{"name":"技术","slug":"技术","permalink":"https://x.lyxw.xyz/categories/技术/"}],"tags":[{"name":"MMD","slug":"MMD","permalink":"https://x.lyxw.xyz/tags/MMD/"}]},{"title":"烦躁沉寂的八月","slug":"august","date":"2020-08-16T14:03:37.000Z","updated":"2022-02-12T15:54:11.270Z","comments":true,"path":"2020/august/","link":"","permalink":"https://x.lyxw.xyz/2020/august/","excerpt":"蝉时雨 化成淡墨渲染暮色","text":"蝉时雨 化成淡墨渲染暮色 喜出望外（概率之中）地获得了20天假期，它被一如既往地在虚幻中无情地消耗殆尽而不留一点痕迹。在大量的睡梦中，这些假期被我无情的浪费了。计划好好写的作业只有物理生物语文都好好写了，罢了，已经没有什么耐心了。总之，时间过得如此之快，在还没有觉察之前它就已经悄然消逝了。 八月的前几天是如此的燥热，空气沉闷得让人无法呼吸，我们只好打开空调以求得一丝舒适的机会。而后十几天却开始了大量的降雨，在北方这和往年是一样的，只不过比起去年来说下雨的次数频繁些，降雨量小些。 天气从那时开始便一天比一天凉爽了，这样忙里偷闲日子也终将结束。 放假以来我发现我对游戏完全失去了兴趣，没有任何欲望在可以趋使我打开那些各式各样的游戏。其他时间，我看了看动画片，这是个挺有趣的事，毕竟我之前几年很少看什么动画之类的东西。还有便是看了看C#和unity罢了，其他时间也没干什么。 毕竟只是自己在寻找这什么意义而已吧，毕竟这样压抑的生活就没什么有趣的。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://x.lyxw.xyz/categories/杂谈/"}],"tags":[{"name":"回忆","slug":"回忆","permalink":"https://x.lyxw.xyz/tags/回忆/"}]},{"title":"使用jsDelivr+PicGo对图片进行cdn加速","slug":"cdn","date":"2020-08-15T23:45:15.000Z","updated":"2020-08-16T01:10:55.429Z","comments":true,"path":"2020/cdn/","link":"","permalink":"https://x.lyxw.xyz/2020/cdn/","excerpt":"GitHub Pages上图片的访问速度不佳，而且使用不便，现在来用GitHub+jsDelivr+PicGo解决这个问题。","text":"GitHub Pages上图片的访问速度不佳，而且使用不便，现在来用GitHub+jsDelivr+PicGo解决这个问题。 一、新建GitHub仓库 二、生成token，保存 三、下载PicGo，安装使用手册：https://picgo.github.io/PicGo-Doc/zh 四、配置PicGo 五、使用直接引用使用方法：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 如果不写版本号，将直接引用最新版 其它：如果需要使用版本号就在release发布，一次不超过50MB。","categories":[{"name":"技术","slug":"技术","permalink":"https://x.lyxw.xyz/categories/技术/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://x.lyxw.xyz/tags/Blog/"},{"name":"jsDelivr","slug":"jsDelivr","permalink":"https://x.lyxw.xyz/tags/jsDelivr/"}]},{"title":"一些metagame的介绍与评价（无剧透）","slug":"metagame","date":"2020-05-18T15:53:35.000Z","updated":"2022-02-12T15:53:26.003Z","comments":true,"path":"2020/metagame/","link":"","permalink":"https://x.lyxw.xyz/2020/metagame/","excerpt":"meta这个概念最早源于元小说（Metafiction），比如乔斯坦·贾德的《苏菲的世界》就属于这一类小说。","text":"meta这个概念最早源于元小说（Metafiction），比如乔斯坦·贾德的《苏菲的世界》就属于这一类小说。 后设小说（英语：Metafiction）又称元小说、超小说，是一种小说类型，透过自我意识的觉醒，刻意凸显书中虚构的错觉。威廉·加斯在1970年〈哲学与小说形式〉一文中首度提出“后设小说”的说法。典型的写作技巧包括将原先的剧情设定为一件文学作品，随后揭露故事的“真相”。后设小说透过讽刺和自我反省等手法，引导读者思考小说与现实之间的关联，进而有意识、有组织地探讨小说本身的虚构性。出自：https://zh.wikipedia.org/wiki/%E5%BE%8C%E8%A8%AD%E5%B0%8F%E8%AA%AA meta游戏与元小说类似，都会与现实中的读者或游玩者产生一定的交互，如同元小说会突出小说本身的虚构性，meta游戏也会着重显明自身世界的编程程序性或与该世界与玩家世界的关联性（我会将其分为程序代码型和平行世界型两种类型）并引导真实世界的游玩者通过游戏程序机制来获取到游戏世界本身并不具有的能力以此来改变游戏剧情，最终模糊虚拟和现实的边界。 程序代码型的游戏会和计算机本身产生一定的交互，并需要通过游戏程序以外的计算机内部操作完成游戏剧情的推进，或（且）会明确游戏本身是程序运行的结果。 平行世界型的游戏不会对计算机产生交互，但你可以通过自己的外部操作（存档/读档）改变平行世界的剧情走向，或（且）会明确游戏本身是独立于程序存在的一个世界，但程序可以改变此世界的一些时间线。 一般来说虽然meta游戏中你都可以完全操控主角的操作，但程序代码型会倾向于使你对游戏本身产生更多的操作，同时从前期就开始就强调主角和游玩者是两个不同的角色，而平行世界型一般会在后期点明游玩者的介入性，并强调主角对游玩者的操控性，但不会着重强调这两个角色的区分性和发挥的不同作用。 meta游戏的最主要特点是将真实世界中的游戏玩家作为游戏内容本身的参与者而不是游戏角色的操控者，也常常会有种说法指明meta游戏打破了第四面墙（显示器屏幕）。 Ever17 —the out of infinity— 时空轮回 平行世界型 AVG/galgame，科幻悬疑，设定不是非常非常科学但还是很有科学因素的，前期流程非常冗长无趣，主要体验最后解密快感。强烈推荐优先游玩此游戏，可以说此游戏也十分独特，且不存在惊吓和血腥内容。 Doki Doki Literature Club 心跳文学部 程序代码型 AVG/galgame，剧情简短明确，流程在2h左右，主要体验比较独特的吓人方式，游戏制作方不建议心理承受能力差及13岁以下人群游玩。 君と彼女と彼女の恋 程序代码型 AVG/galgame，部分精神污染极其严重，不要轻易尝试，有画面反色，文件修改等内容。前期的画面非常不错，淡色且偏水彩风格，适合看风景，前期一些设定让你一度以为这是个科幻故事，我倒是挺希望偏向一个科幻来叙事的，但是最后还是说归结到了计算机和程序这种设定上。总的来说也是很独特的游戏，这种风格的游戏几乎找不出第二个了。 Undertale 平行世界型 RPG游戏，总体来说也非常新奇，有很独特的地方，值得一玩。 Oneshot 程序代码型 冒险解谜游戏，一周目通关，部分解谜方式很新颖，会和你的计算机本身有所交互，没有在别的游戏里见过。二周目的剧情比较完善，也令人有所感动。缺点在于寻找东西的解谜就略显枯燥。 艾希 Icey 程序代码型 横版动作游戏，没有玩过，偏重于计算机方面的设定，平面砍杀，类似于空洞骑士。 史丹利的寓言 The Stanley Parable 程序代码型 冒险解谜游戏，有一些场景会有不安的感觉，本身内容不算太多，一共有十几个左右的结局。 恋爱绮谭~不存在的夏天~ 平行世界型 这部游戏的meta成分很少，寥寥几句话，但在国产galgame中是我见过的最新奇的一部作品了。整个题材融合了虚拟主播、都市怪谈、中国传统灵异设定、MtF、校园恋爱、悬疑以及部分科学性的解释、各种让人会心一笑的梗、一些故事和哲学的讨论、结尾的meta元素也不显突兀。不存在的夏天这一游戏名也一语双关，玩到后期我才明白这个名字的巧妙之处。总体来说虽然分离的故事在一开始关联性不强，但在最后给出的解释都比较合理，串联起了不同人的故事，各种悬疑也都在后期给出逻辑上并不问题的答案，对于悬疑性的体验还是不错的。我个人比较喜欢这种能融合各种现实元素的游戏，只得一提的便是游戏创新性设计的手机系统、前后文字位置的变化和声字不同的设计都显示出了这部游戏设计的独特之处，可以肯定这款游戏代表了国产galgame的一流水平。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://x.lyxw.xyz/categories/杂谈/"}],"tags":[{"name":"metagame","slug":"metagame","permalink":"https://x.lyxw.xyz/tags/metagame/"},{"name":"galgame","slug":"galgame","permalink":"https://x.lyxw.xyz/tags/galgame/"}]},{"title":"我接触与学习编程及OI的经历","slug":"about-program","date":"2020-02-29T02:18:09.000Z","updated":"2022-02-12T17:41:35.097Z","comments":true,"path":"2020/about-program/","link":"","permalink":"https://x.lyxw.xyz/2020/about-program/","excerpt":"","text":"想来自己接触编程的时间真的不算短了，也是三年多了，但是没有学会太多的知识，其原因一是没有坚持在闲暇的时候学习，自己也一直缺少主观的动力去努力学习，二是自己实践得少，没有全面的知识体系，解决问题的过程中编程容易陷入困难以至于放弃。虽然自己知识浅薄，但是编程的确是我一直喜欢的一项事物，在这里我简单写写这几年的编程学习经历吧。 20162016年快要到了末尾，初中同学总是与我聊起些计算机方面的话题，不过仅限于些PC硬件，PS之类的平淡无奇的东西罢了，我也没什么动力去学习编程，尽管前几年一直对此方面非常感兴趣，也有意向去尝试，可我的确是不敢勇于尝试，也就是不愿跨出第一步去接触新事物罢了。 不过有一天，一位同学给我看了一本书：《零基础学C语言》，据他所说仅仅是在书店买了一本，我看了看觉得不算很难，正巧当时在知乎看了一些编程的问题，也有兴趣学C语言，就顺理成章的买了一本，的确算不上一流的教材，不过庆幸的是我没有选择谭浩强之类的时代产物，也没有去看至于到诸如《C Primer Plus》等可能略微劝退我的书籍。现在依稀记得对于反码补码之类的东西理解有一些难度，不过还是很有兴趣的看完了，也写出了第一个Hello world，当时我很少写代码，大部分时间花都在翻翻书，还觉得程序框图挺有趣的，记得书上写了一些五子棋之类的游戏，当时也没全看懂。 2017书自然是看完了，可是会写多少了吗？恐怕不是的。而后呢？自然没有多大的兴趣，只记得自己把书看懂了，后来也没有写过几次C语言罢了，曾经安装过python环境，也没有去写。 暑假的时候，在一些事情的影响下决定想学一学OI，自然开始看C++，因为比较底层的内容比如指针和二进制编码理解的还比较好所以几乎没什么阻力，当然没有看多少OOP的知识，然后就开始写写简单的OI题，看看数论，算法之类的，但是的确是非常水，贡献了很多时间给MC，B站之类的，于是到11月连DFS也写不熟练。就是这样去普及组水了个1=，当然本身也得顾及学习，况且是开学后才开始学算法的。 之后我对编程迅速失去兴趣，并投入大量时间给Steam，半年没写代码。主要原因是没什么目的，也没接去接触开源社区，不太明白怎么用网络学习新技术。大概还是动力和兴趣不足。 2018从四月开始到年底的时间都花在了OI上，主要是学了大量的算法和数据结构，以及一些C++。最后11月提高组喜获2=，这一年没什么想法，除了C++别的语言几乎没有写过，不过上网时间倒是出奇的长，看了很多博客和知乎…… 其实虽然我不讨厌算法竞赛，但是确实没什么非常喜欢学习算法的感觉，就像是随波逐流地而来一样。而且说真的只要一个算法满足在数学形式上复杂或者抽象程度上高的话，我在学习它的时候就会遇到极大的困难，非常难以凭借自学的能力克服。 2019今年主要还是学习OI，五月份的时候搭了搭博客，然后这时候觉得科学上网还是方便一些，时间不太允许自己搭，于是找了个机场，才开始真正用上了一些有价值的工具。 暑假开始便清楚OI只能拿个1=，加上一直算法学习难度对我而言也是比较大，逐渐也就失去了热情，放弃了联赛之上比赛内容的学习。主要是保持每天做一些动态规划的题，学了一些自己喜欢的算法，不是联赛内容的算法看明白后写一写，就放弃继续做题了。 在学校剩下的时间便用来学了学C++的OOP，C#，python，一些前端，看了一些计算机的理论，不过重心肯定在OI上，这些只作为了一些消遣般的活动，投入时间也不多，所以知识水平并不高。当然，知乎也看了不少…… 最后11月喜获联赛的1=，基本是我真实水平，没什么好说的……退役后闲暇时间学了一些汇编，但是没有自己写过。 2020现在可能不会再有太多时间写代码了，放假的时候作为消遣应该还是会看看编程相关的内容。 突发疫情，也不用去学校，现在主要想学学C++，C#、Python也看一看。到是有兴趣去学一些Unity，不过这些事肯定得放在放假的时候去做（因为上网课的时候在玩游戏）。 结尾事到如今所有事都已成定局了，学OI也给我的算法水平带来了很大的提升吧，当然上网时间多了也接触到了更多编程相关的内容和技术。 那么看来如果要保持长时间对编程的学习的话，适度的兴趣和合适的方法论是不可或缺的。兴趣的话就例如对于一些有趣事物的实现抑或是对科学知识的那种好奇心，方法论来说就是一些自学的方法诸如快速地获取并筛选信息、对一些语言知识和实践的综合运用、遇到问题时解决错误的步骤此类的问题。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://x.lyxw.xyz/categories/杂谈/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://x.lyxw.xyz/tags/编程/"},{"name":"经历","slug":"经历","permalink":"https://x.lyxw.xyz/tags/经历/"}]},{"title":"Windows软件快速指南","slug":"software","date":"2019-10-27T09:44:02.000Z","updated":"2020-02-29T08:39:57.876Z","comments":true,"path":"2019/software/","link":"","permalink":"https://x.lyxw.xyz/2019/software/","excerpt":"Update on A.D.2019.10.28","text":"Update on A.D.2019.10.28 断断续续写了一点自己了解过的软件，会一直更新 IDE及编辑器Visual Studio Code：编辑器，可以安装插件，实现对多种语言的支持 Visual Studio：大型IDE，主要用于C++开发，对C#、Visual Basic支持较好 Notepad++：高配版记事本，速度快，适合编辑多种文件，支持代码高亮 Subline：编辑器，支持插件 Vim：编辑器，独特的键盘指令及操作可以提高效率 Eclipse：IDE，用于Java开发，可以安装插件支持其他语言 Atom：GitHub开发的编辑器，比较漂亮，支持插件 JetBrains系列：IntelliJ、CLion、PyCharm 系统安全及工具火绒：比较舒服的安全工具，没有流氓行为 Mem Reduct：清理内存 CCleaner：清理硬盘垃圾文件 DiskGenius：复杂分区操作，磁盘修复 文件管理Listary：全硬盘文件搜索，界面类型及功能多样，适合日常使用 Everything：全硬盘文件搜索，功能更加专一，适合复杂文件操作 7-Zip：最好用的压缩软件，算法一流 FastCopy：快速拷贝文件，比Windows系统快 系统美化及桌面整理Fences：桌面整理，效果很漂亮，支持扩展出多桌面 Rolan：桌面轻量级收纳工具 Startisback：让任务栏透明吧 WallpaperEngine：让桌面壁纸动起来吧 SAO-Utils：模拟刀剑神域的界面 Live2dViewerEX：让live2d小人站在桌面上吧 TrafficMonitor：显示网速、CPU及内存的悬浮窗，支持更换皮肤 IM（即时通讯）TIM：QQ简化版本 Telegram：电报桌面版 Skype：微软的软件 硬件检测卡硬工具箱：常用的各种工具都包括了，例如CPU-Z，GPU-Z，SSD测速，硬盘检测等 aida64：硬件检测工具 工作及生活Chrome：Google开发的浏览器 Firefox：火狐浏览器 potplayer：音视频播放器，可以更换皮肤，清爽流畅 Bandicam：录屏软件 Vieas：图片查看器，打开速度更快，还可简单编辑图片 OneNote：记笔记神器，功能全面，网页剪取较好用 OneDrive：微软云盘，存点随时用的文档 印象笔记：经典笔记软件 文本排版和数学Typora：Markdown编辑器 Moeditor：Markdown编辑器 LaTeX：排版及数学公式工具 Matlab：数学计算及数学 Mathematica：数学计算及数学 GraphViz：图论 geogebra：数学 几何画板：几何 游戏Steam：Valve的游戏发行平台 Uplay：育碧发行平台 origin：EA发行平台 SSTap：用于境外服务器线路加速 Fraps：显示帧数 BakaXL：好看的MC启动器 梯子及暗网Shadowsocks：ss ShadowsocksR：ssr V2Ray Brook Tor浏览器：洋葱浏览器 编程工具terminus：很漂亮的一个终端 Git：版本控制 以下内容待更新 微软系列Word、 Adobe系列Photoshop： 艺术设计工具C4D： Blender： ACGNMMD： Vocaloid：","categories":[{"name":"计算机","slug":"计算机","permalink":"https://x.lyxw.xyz/categories/计算机/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://x.lyxw.xyz/tags/软件/"}]},{"title":"PyQt5上手指南","slug":"pyqt","date":"2019-10-25T11:50:55.000Z","updated":"2022-02-12T18:01:38.336Z","comments":true,"path":"2019/pyqt/","link":"","permalink":"https://x.lyxw.xyz/2019/pyqt/","excerpt":"","text":"学习前提是需要对Python有一定的基础。 首先我们需要安装。 打开powershell输入： pip install pyqt5-tools 安装完毕后输入： designer 稍等，会弹出页面，如图所示： 现在创建一个MainWindow窗口，并进行编辑，如图所示： 默认的编辑模式是： 这是用来拖动控件的，上方的TextLabel是显示信息用的Label控件，空白的地方是用来输入信息或者显示信息的Text Edit控件，PushButton是能对点击操作发出信号的Push Button控件。 左侧的其他控件可以试试并查询功能。 控件上面的文本和窗口标题文本都可以通过右侧的此窗口修改： 现在我们切换到信号操作上： 试一试点击一个控件后拖动，这是你可以选择信号发送到其他控件或者是窗口本身。 因为信号所对应的命令还需要我们自己书写，所以我们随便指定一个命令： 这个操作的含义是当点击时关闭窗口。 现在是这样的，那么我们保存一下编辑好的界面。 打开VSCode，进入保存文件的路径，我们需要把保存的.ui文件转换成.py文件以便接下来的操作。 在终端里运行： pyuic5 FileName.ui -o FileName.py 现在我们重新配置一下settings.js文件以避免一些插件检测语法上的错误 settings.js{ &quot;python.pythonPath&quot;: &quot;C:/Users/UserName/AppData/Local/Programs/Python/Python37-32/python.exe&quot;,//选择安装路径 &quot;python.linting.pylintArgs&quot;: [ &quot;--extension-pkg-whitelist=PyQt5&quot;, &quot;--disable=W,C&quot;, &quot;--generate-members&quot; ]//避免错误报错 } 现在新建一个文件： import sys import FileName from PyQt5.QtWidgets import QApplication, QMainWindow if __name__ == &#39;__main__&#39;: app = QApplication(sys.argv) MainWindow = QMainWindow() ui = FileName.Ui_MainWindow() ui.setupUi(MainWindow) MainWindow.show() sys.exit(app.exec_()) 运行此文件，即可看到我们刚才制作的窗口。 下面的问题就是要添加对应的功能，我们打开刚才制作好的FileName.py进行修改。","categories":[{"name":"编程","slug":"编程","permalink":"https://x.lyxw.xyz/categories/编程/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"https://x.lyxw.xyz/tags/PyQt/"},{"name":"Python","slug":"Python","permalink":"https://x.lyxw.xyz/tags/Python/"}]},{"title":"VSCode配置Python环境及Python入门学习","slug":"python","date":"2019-10-17T08:46:37.000Z","updated":"2022-02-12T18:01:43.274Z","comments":true,"path":"2019/python/","link":"","permalink":"https://x.lyxw.xyz/2019/python/","excerpt":"Update on A.D.2019.10.17 内容完善中!","text":"Update on A.D.2019.10.17 内容完善中! 大概七月份花了一天的时间把python的基础语法看了一遍，十月份再花了一点时间学习，主要用于写绘制数据图片、网页爬虫、图形界面。 如果你会C++的话，我在这里就写一下如何以最快的速度看完语法，并且学会调用一些基本的库，尽量写到最简，不熟悉的语法和库可以直接查文档或者Google解决。 配置环境首先去官网下载合适版本并安装 https://www.python.org/ 安装时 记得勾选上Add Python 3.x to PATH再进行安装，这样不用自行配置环境变量 在cmd或者powershell下输入python 出现 Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)] on win32 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; 即代表安装成功 在VSCode中安装 这个插件 按下Ctrl+Shift+P选择Python: 选择解析器 Python: Select Interpreter填写python解析器路径C:/Users/UserName/AppData/Local/Programs/Python/Python37-32/python.exe（默认安装路径是这个） 检查并设置.vscode文件夹下的文件 launch.json{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Python&quot;, &quot;type&quot;: &quot;python&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${file}&quot;, &quot;console&quot;: &quot;integratedTerminal&quot; } ] } settings.json{ &quot;python.pythonPath&quot;: &quot;C:\\\\Users\\\\UserName\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37-32\\\\python.exe&quot;, } 右键-在终端中运行python文件 调试-启动调试 调试-在不调试的情况下启动 都可以运行，调试可以设置断点 在cmd或者powershell下输入python进入交互环境 使用python 文件名.py运行python文件 使用pip install 库名称安装库 使用pip list查看已安装的库 基础语法变量在赋值时被创建 数字int整型 float浮点型 complex复数 类型转换：int(x) float(x) complex(x,y) 字符串使用’’或””创建，下标从零开始 转义字符：和C++类似 运算：+连接 *重复 []获取字符 [:]截取，左闭右开 &gt;&gt;&gt;a = &quot;12345&quot; &gt;&gt;&gt;a[1:4] 234 格式化输出：print(“XXX%sXXX%dXXX” % (‘xxx’, 10)) 占位符和C++相同 运算符** 幂 / 除 // 整除 &gt;&gt;&gt;2**3 8 &gt;&gt;&gt;21/10 2.1 &gt;&gt;&gt;21//10 2 C++ Python $$ and &#124;&#124; or ! not in 在序列中找到值返回True 否则返回False not in 相反 其余和C++相同 数据结构下标从0开始 列表list类似C++中的vector l = [&#39;A&#39;, &#39;B&#39;, 2019, 2020] print(l[0]) #第0个 print(l[-2]) #倒数第2个 print(l[1:3]) #第1到第2个 del l[1] #删除第一个 print(l) list.append(2021) #在末尾添加新对象 print(l) --- 输出： A 2019 [&#39;B&#39;,2019] [&#39;A&#39;, 2019, 2020] [&#39;A&#39;, 2019, 2020, 2021] 剩余内容待更新 调用库剩余内容待更新 练习随便练习写了写的东西，但是tkinter不方便也不好看，所以我要再学一下PyQt，也方便以后学习C++的Qt 使用b站视频av号查询数据调用了b站的api 使用了tkinter最简单的功能 import tkinter as tk import json import re from urllib.request import urlopen def GetDict(date, keys, default=None): keys_list = keys.split(&#39;.&#39;) if isinstance(date,dict): dictionary = dict(date) for i in keys_list: try: if dictionary.get(i) != None: dict_values = dictionary.get(i) elif dictionary.get(i) == None: dict_values = dictionary.get(int(i)) except: return default dictionary = dict_values return dictionary Videojson = &quot;&quot; def WebRequest(id): global Videojson Videojson = urlopen(&quot;https://api.bilibili.com/x/article/archives?ids=&quot;+id).read().decode(&#39;utf-8&#39;) Data = json.loads(Videojson) return Data window = tk.Tk() window.title(&#39;哔哩哔哩数据查询&#39;) window.geometry(&#39;485x475&#39;) def insert_point(): VideoId = ScanId.get() VideoData = WebRequest(VideoId) ViewTextWindow.delete(0.0, &#39;end&#39;) TitleTextWindow.delete(0.0, &#39;end&#39;) FavoriteTextWindow.delete(0.0, &#39;end&#39;) DanmuTextWindow.delete(0.0, &#39;end&#39;) ReplyTextWindow.delete(0.0, &#39;end&#39;) CoinTextWindow.delete(0.0, &#39;end&#39;) JsonTextWindow.delete(0.0, &#39;end&#39;) ViewTextWindow.insert(&#39;insert&#39;, str(GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.stat.view&quot;))) TitleTextWindow.insert(&#39;insert&#39;, GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.title&quot;)) FavoriteTextWindow.insert(&#39;insert&#39;, str(GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.stat.favorite&quot;))) DanmuTextWindow.insert(&#39;insert&#39;, str(GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.stat.danmaku&quot;))) ReplyTextWindow.insert(&#39;insert&#39;, str(GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.stat.reply&quot;))) CoinTextWindow.insert(&#39;insert&#39;, str(GetDict(VideoData, &quot;data.&quot;+VideoId+&quot;.stat.coin&quot;))) JsonTextWindow.insert(&#39;insert&#39;, Videojson) tk.Label(window, text=&quot;输入视频AV号&quot;).place(x=350, y=10, anchor=&#39;nw&#39;) ScanId = tk.Entry(window) ScanId.place(x=320, y=45, anchor=&#39;nw&#39;) query = tk.Button(window, text=&quot;查询&quot;, width=6, height=1, command=insert_point) query.place(x=370, y=70, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;标题&quot;).place(x=10, y=10, anchor=&#39;nw&#39;) TitleTextWindow = tk.Text(window,height=1,width=35) TitleTextWindow.place(x=45, y=15, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;播放&quot;).place(x=10, y=40, anchor=&#39;nw&#39;) ViewTextWindow = tk.Text(window,height=1,width=35) ViewTextWindow.place(x=45, y=45, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;收藏&quot;).place(x=10, y=70, anchor=&#39;nw&#39;) FavoriteTextWindow = tk.Text(window,height=1,width=35) FavoriteTextWindow.place(x=45, y=75, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;弹幕&quot;).place(x=10, y=100, anchor=&#39;nw&#39;) DanmuTextWindow = tk.Text(window,height=1,width=35) DanmuTextWindow.place(x=45, y=105, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;回复&quot;).place(x=10, y=130, anchor=&#39;nw&#39;) ReplyTextWindow = tk.Text(window,height=1,width=35) ReplyTextWindow.place(x=45, y=135, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;硬币&quot;).place(x=10, y=160, anchor=&#39;nw&#39;) CoinTextWindow = tk.Text(window,height=1,width=35) CoinTextWindow.place(x=45, y=165, anchor=&#39;nw&#39;) tk.Label(window, text=&quot;json&quot;).place(x=10, y=190, anchor=&#39;nw&#39;) JsonTextWindow = tk.Text(window,height=20,width=60) JsonTextWindow.place(x=45, y=195, anchor=&#39;nw&#39;) window.mainloop() 获取b站视频总播放排名并绘制柱状图需要matplotlib库 使用https://www.kanbilibili.com的数据，获取更多数据需要写js对网页进行交互，等待python学习以及前端学习来进行改善 from urllib.request import urlopen import json import re import matplotlib.pyplot as plt import numpy as np import requests # -*- coding: UTF-8 -*- def get_dict_value(date, keys, default=None): keys_list = keys.split(&#39;.&#39;) if isinstance(date,dict): dictionary = dict(date) for i in keys_list: try: if dictionary.get(i) != None: dict_values = dictionary.get(i) elif dictionary.get(i) == None: dict_values = dictionary.get(int(i)) except: return default dictionary = dict_values return dictionary videoData = urlopen(&quot;https://www.kanbilibili.com/rank/videos&quot;).read().decode(&#39;utf-8&#39;) videoAvList = re.findall(r&#39;href=&quot;/video/av(.*?)&quot;&#39;, videoData) # &lt;a href=&quot;/video/av36570707&quot; videoVisit = {} cnt = 0 Y = [] for i in range(0, len(videoAvList)): video_id = videoAvList[i] if(video_id in videoVisit): continue videoVisit[video_id] = 1 jsonData = urlopen( &quot;https://api.bilibili.com/x/article/archives?ids=&quot; + video_id ).read().decode(&#39;utf-8&#39;) Data = json.loads(jsonData) cnt += 1 Y.append(get_dict_value(Data, &quot;data.&quot;+video_id+&quot;.stat.view&quot;)) print(&#39;rank: %d | av: %s | 播放数：%s&#39; % (cnt, video_id, get_dict_value(Data, &quot;data.&quot;+video_id+&quot;.stat.view&quot;))) print(&#39;标题：%s&#39; % get_dict_value(Data, &quot;data.&quot;+video_id+&#39;.title&#39;)) n = cnt X = np.arange(n) plt.bar(X, Y) plt.bar(X, Y, facecolor=&#39;#66ccff&#39;, edgecolor=&#39;white&#39;) plt.xlim((-0.5, 99)) plt.ylim((1, 100000000)) plt.xlabel(&#39;Rank&#39;) plt.ylabel(&#39;View&#39;) new_ticks1 = np.linspace(0, 100000000, 11) plt.yticks(new_ticks1) new_ticks = np.linspace(0, 99, 100) plt.xticks(new_ticks) plt.show()","categories":[{"name":"编程","slug":"编程","permalink":"https://x.lyxw.xyz/categories/编程/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://x.lyxw.xyz/tags/Python/"}]},{"title":"Github Pages+HTML5 up制作个人主页及绑定二级域名","slug":"html_page","date":"2019-09-23T10:31:38.000Z","updated":"2019-09-23T10:38:45.345Z","comments":true,"path":"2019/html_page/","link":"","permalink":"https://x.lyxw.xyz/2019/html_page/","excerpt":"Update on A.D.2019-09-23 好看是第一生产力​qwq","text":"Update on A.D.2019-09-23 好看是第一生产力​qwq 单个GitHub帐号下添加多个GitHub Pages的相关问题| 我很好奇 首先我们要知道GitHub Pages可以有多个，项目名为YourGitHubName.github.io的Pages使用这个域名访问，新添加一个项目ProjectName并设置为Pages项目后，使用YourGitHubName.github.io/ProjectName进行访问，那么我们可以使用一个Pages托管Hexo博客，一个Pages托管个人主页. 这里介绍一个网站提供了很多个人主页的模板https://html5up.net我们选择并下载其中一个，直接修改即可，有一定HTML和CSS基础都可以很轻松的修改，你需要一个浏览器并会使用控制台以及抓取元素和一个编辑器例如vscode即可开始编写. 那么你还需要会使用git并把这个网站的源代码上传到GitHub的repo上，不会上网找个教程吧. 那然后就是域名绑定了，如果你用域名绑定过GitHub Pages的话，你就知道域名的DNS设置要设置几个A选项，这里不讲那是啥玩意了，总之这个选项是设置GitHub的ip地址的，有空我再找链接吧，自己去查GitHub的文档就行。然后你要设置一个CNAME，设置YoutGitHubName.github.io，然后在Github的repo里添加一个CNAME文件内容是你的域名全称并且不带https，www这样的前缀. 那么现在有两个页面，我们可以把主域名解析到个人主页上，使用blog二级域名解析到博客上，具体设置就是在域名DNS设置里设置二级域名并且同样解析到YoutGitHubName.github.io上，然后分别在个人主页的CNAME里设置域名和博客的CNAME里设置blog.域名，记得打开GitHub Pages绑定个人域名的https. 现在等一会DNS解析生效和GitHub的https证书申请完毕应该就没什么问题了.","categories":[{"name":"技术","slug":"技术","permalink":"https://x.lyxw.xyz/categories/技术/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://x.lyxw.xyz/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://x.lyxw.xyz/tags/CSS/"}]},{"title":"「莫比乌斯反演」","slug":"mobius","date":"2019-09-23T01:40:00.000Z","updated":"2019-10-17T08:02:25.455Z","comments":true,"path":"2019/mobius/","link":"","permalink":"https://x.lyxw.xyz/2019/mobius/","excerpt":"Update on A.D.2019-09-23","text":"Update on A.D.2019-09-23 参考资料：莫比乌斯反演-让我们从基础开始莫比乌斯反演_cnblogs_peng-ymP2257 YY的GCD 题解容斥原理 与 莫比乌斯反演整除分块_peng-ymOI生涯中的各种数论算法的证明 整除分块公式求： \\sum_{i=1}^{n}\\lfloor\\frac{n}{i}\\rfloor对于每个$\\lfloor\\frac{n}{i}\\rfloor$值相同的区间$[l,r]$有$r=n/(n/l)$，即对于$\\forall x\\in [i,n/(n/i)]$有$x=\\lfloor\\frac{n}{i}\\rfloor$. 时间复杂度$O(\\sqrt{n})$ 代码for(int l = 1, r; l &lt;= n; l = r + 1) { r = n / (n / l); ans += (r - l + 1) * (n / l); } 数论函数满足$f(ab)=f(a)f(b),gcd(a,b)=1$的数论函数称为积性函数满足$f(ab)=f(a)f(b)$的数论函数称为完全积性函数 积性函数$\\varphi(n)$：欧拉函数，表示小于n的正整数中与n互质的数的数目 \\varphi(x)=x\\prod_{i=1}^{n}\\left(1-\\frac{1}{p_i}\\right)$\\mu(n)$：莫比乌斯函数$\\sigma(n)$：因子和函数，表示n的正因子和$d(n)​$：因子个数函数，表示n的正因数个数 完全积性函数$\\epsilon(n)=[n=1]$：单位函数$id(n)=n$：恒等函数$1(n)=1$：常函数 狄利克雷卷积对于数论函数$f(n),g(n)$定义Dirichlet卷积为 (f\\times g)(n)=\\sum_{d\\mid n}f(d)g(\\frac{n}{d})若$f,g$为积性函数，$f*g,f\\times g$为积性函数 常用的狄利克雷卷积 id=\\varphi\\times 1\\quad n=\\sum_{d\\mid n}\\varphi(d) \\epsilon = \\mu \\times 1 \\quad \\epsilon(n) = \\sum_{d\\mid n}\\mu(d) \\varphi = \\mu \\times id \\quad \\varphi(n)=\\sum_{d\\mid n}d\\mu(\\frac{n}{d})=\\sum_{d\\mid n}\\mu(d)\\frac{n}{d}莫比乌斯函数 \\mu(d) = \\left\\{\\begin{matrix}1,d=1 \\\\ (-1)^n,d=\\prod_{i=1}^{n}p_i^{k_i} , \\forall p_i, k_i=1 \\\\ 0,d=\\prod_{i=1}^{n}p_i^{k_i} , \\exists p_i, k_i\\geqslant 2 \\end{matrix}\\right.线性筛求莫比乌斯函数void sieve() { mu[1] = 1; for(int i = 2; i &lt;= N; i++) { if(!vis[i]) prime[++cnt] = i, mu[i] = -1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; } } } 性质由$\\mu \\times 1 = \\epsilon$得 \\sum_{d|n}\\mu(d)=[n=1]莫比乌斯反演对于函数 f=g\\times 1有 g=\\mu \\times f即对于 f(n)=\\sum_{d\\mid n}g(d)有 g(n)=\\sum_{d\\mid n}\\mu(d)f(\\frac{n}{d})ProblemP2303 [SDOI2012]Longge的问题 \\sum_{i=1}^{n}gcd(i,n)\\\\ =\\sum_{d\\mid n}d\\times\\sum_{i=1}^{n}[gcd(i,n)=d]\\\\ =\\sum_{d \\mid n}d \\times \\sum_{i=1}^{\\frac{n}{d}}[gcd\\left ( i,\\frac{n}{d}\\right)=1]\\\\ =\\sum_{d \\mid n} d \\cdot \\varphi\\left ( \\frac{n}{d} \\right )P2257 YY的GCD原式 =\\sum_{k=1}^{min(n,m)}\\sum_{i=1}^{n}\\sum_{j=1}^{m}[gcd(i,j)=k](k\\in prime)由 \\sum_{d|n}\\mu(d)=[n=1]得 \\sum_{d|gcd(i,j)}\\mu(d)=[gcd(i,j)=1]原式 =\\sum_{k=1}^{min(n,m)}\\sum_{i=1}^{\\lfloor{\\frac{n}{k}}\\rfloor}\\sum_{j=1}^{\\lfloor{\\frac{m}{k}}\\rfloor}\\sum_{d|gcd(i,j)}\\mu(d)(k\\in prime) =\\sum_{k=1}^{min(n,m)}\\sum_{d=1}^{\\lfloor{\\frac{n}{k}}\\rfloor}\\mu(d){\\lfloor{\\frac{n}{kd}}\\rfloor}{\\lfloor{\\frac{m}{kd}}\\rfloor})(k\\in prime)设$T=kd$有原式 =\\sum_{k=1}^{min(n,m)}\\sum_{d=1}^{\\lfloor{\\frac{n}{k}}\\rfloor}\\mu(d){\\lfloor{\\frac{n}{T}}\\rfloor}{\\lfloor{\\frac{m}{T}}\\rfloor}(k\\in prime) =\\sum_{T=1}^{min(n,m)}{\\lfloor{\\frac{n}{T}}\\rfloor}{\\lfloor{\\frac{m}{T}}\\rfloor}\\sum_{k|T,k\\in prime}\\mu(\\frac{T}{k})#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int _ = 10000005, N = 10000000; int T, n, m, cnt; int vis[_], prime[_], mu[_], f[_], sum[_]; void sieve() { mu[1] = 1; for(int i = 2; i &lt;= N; i++) { if(!vis[i]) prime[++cnt] = i, mu[i] = -1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; } } for(int i = 1; i &lt;= cnt; i++) for(int j = 1; prime[i] * j &lt;= N; j++) f[j * prime[i]] += mu[j]; for(int i = 1; i &lt;= N; i++) sum[i] = sum[i - 1] + f[i]; } int main() { sieve(); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if(n &gt; m) swap(n, m); long long ans = 0; for(int l = 1, r = 0; l &lt;= n; l = r + 1) { r = min(n / (n / l), m / (m / l)); ans += 1LL * (n / l) * (m / l) * (sum[r] - sum[l - 1]); } printf(&quot;%lld\\n&quot;, ans); } return 0; } P3455 [POI2007]ZAP-Queries \\sum_{i=1}^n\\sum_{j=1}^m[gcd(i,j)=k] =\\sum_{i=1}^{\\lfloor{\\frac{n}{k}}\\rfloor}\\sum_{j=1}^{\\lfloor{\\frac{m}{k}}\\rfloor}[gcd(i,j)=1] =\\sum_{i=1}^{\\lfloor{\\frac{n}{k}}\\rfloor}\\sum_{j=1}^{\\lfloor{\\frac{m}{k}}\\rfloor}\\sum_{d\\mid gcd(i,j)} \\mu(d) =\\sum_{d=1}^{min(n,m)}\\mu(d)\\lfloor{\\frac{n}{d}}\\rfloor\\lfloor{\\frac{m}{d}}\\rfloor#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int _ = 50005, N = 50000; int T, n, m, d; int vis[_], prime[_], mu[_], sum[_], cnt; void sieve() { mu[1] = 1; for(int i = 2; i &lt;= N; i++) { if(!vis[i]) prime[++cnt] = i, mu[i] = -1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; } } for(int i = 1; i &lt;= N; i++) sum[i] = sum[i - 1] + mu[i]; } int main() { sieve(); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;d); if(n &gt; m) swap(n, m); n /= d; m /= d; long long ans = 0; for(int l = 1, r = 0; l &lt;= n; l = r + 1) { r = min(n / (n / l), m / (m / l)); ans += 1LL * (n / l) * (m / l) * (sum[r] - sum[l - 1]); } printf(&quot;%lld\\n&quot;, ans); } return 0; } P2522 [HAOI2011]Problem b \\sum_{i=a}^b\\sum_{j=c}^d[gcd(i,j)=k] =\\sum_{i=1}^b\\sum_{j=1}^d[gcd(i,j)=k]-\\sum_{i=1}^{a-1}\\sum_{j=1}^d[gcd(i,j)=k]-\\sum_{i=1}^b\\sum_{j=1}^{c-1}[gcd(i,j)=k]+\\sum_{i=1}^{a-1}\\sum_{j=1}^{c-1}[gcd(i,j)=k] \\sum_{i=1}^n\\sum_{j=1}^m[gcd(i,j)=k] =\\sum_{i=1}^{\\lfloor{\\frac{n}{k}}\\rfloor}\\sum_{j=1}^{\\lfloor{\\frac{m}{k}}\\rfloor}[gcd(i,j)=1] =\\sum_{i=1}^{\\lfloor{\\frac{n}{k}}\\rfloor}\\sum_{j=1}^{\\lfloor{\\frac{m}{k}}\\rfloor}\\sum_{d\\mid gcd(i,j)} \\mu(d) =\\sum_{d=1}^{min(n,m)}\\mu(d)\\lfloor{\\frac{n}{d}}\\rfloor\\lfloor{\\frac{m}{d}}\\rfloor#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int _ = 50005, N = 50000; int T, a, b, c, d, k; int vis[_], prime[_], mu[_], sum[_], cnt; void sieve() { mu[1] = 1; for(int i = 2; i &lt;= N; i++) { if(!vis[i]) prime[++cnt] = i, mu[i] = -1; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; } } for(int i = 1; i &lt;= N; i++) sum[i] = sum[i - 1] + mu[i]; } long long calc(int n, int m, int k) { long long ans = 0; n = n / k; m = m / k; for(int l = 1, r = 0; l &lt;= min(n, m); l = r + 1) { r = min(n / (n / l), m / (m / l)); ans += 1LL * (n / l) * (m / l) * (sum[r] - sum[l - 1]); } return ans; } int main() { sieve(); scanf(&quot;%d&quot;, &amp;T); while(T--) { scanf(&quot;%d%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;k); long long ans = calc(b, d, k) - calc(a - 1, d, k) - calc(b, c - 1, k) + calc(a - 1, c - 1, k); printf(&quot;%lld\\n&quot;, ans); } return 0; }","categories":[{"name":"数学","slug":"数学","permalink":"https://x.lyxw.xyz/categories/数学/"}],"tags":[{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://x.lyxw.xyz/tags/莫比乌斯反演/"},{"name":"整除分块","slug":"整除分块","permalink":"https://x.lyxw.xyz/tags/整除分块/"}]},{"title":"「后缀数组」","slug":"SA","date":"2019-09-23T01:38:18.000Z","updated":"2019-10-17T08:05:57.161Z","comments":true,"path":"2019/SA/","link":"","permalink":"https://x.lyxw.xyz/2019/SA/","excerpt":"Update on A.D.2019-09-23","text":"Update on A.D.2019-09-23 参考资料：1.后缀数组详解2.后缀数组-学习笔记3.后缀数组——处理字符串的有力工具 定义$SA$排名为$i$的后缀的位置$rk$位置为$i$的后缀的排名$tp$第二关键字的排名为$i$的后缀的位置，还被用作$rank$的暂存$tax$每个排名对应的后缀数量后缀数组就是为了求出$sa$和$rk$ 性质$rk[sa[i]]=i$ $sa[rk[i]]=i$ $LCP(x,y) $：字符串x与字符串y的最长公共前缀，在这里指x号后缀与与y号后缀的最长公共前缀 $height[i]=lcp ( sa[i],sa[i - 1] )$，即排名为$i$的后缀与排名为$i−1$的后缀的最长公共前缀 $H[i]：height[rak[i]]$，即$i$号后缀与它前一名的后缀的最长公共前缀 $H[i] \\geqslant H[i - 1] - 1$ 证明 $LCP(i,j)=LCP(j,i) $ $LCP(i,i)=len(sa[i])=n-sa[i]+1$ $LCP(i,k)=min\\left\\{height[j] \\right\\}(i+1&lt;=j&lt;=k)$ $S$不同的子串个数$\\dfrac{n(n+1)}{2} -\\sum_{i=1}^nheight[i]$ 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;string&gt; #define R register int using namespace std; const int N = 1000005; string s; /* sa[i]：排名为i的后缀的位置 rak[i]：从第i个位置开始的后缀的排名，下文为了叙述方便，把从第i个位置开始的后缀简称为后缀i tp[i]：基数排序的第二关键字，意义与sa一样，即第二关键字排名为i的后缀的位置 tax[i]：i号元素出现了多少次。辅助基数排序 s：字符串，s[i]表示字符串中第i个字符串*/ int n, m, sa[N], rk[N], tp[N], c[N]; void _sort() { for(R i = 1; i &lt;= m; ++i) c[i] = 0; for(R i = 1; i &lt;= n; ++i) c[rk[i]]++; for(R i = 1; i &lt;= m; ++i) c[i] += c[i - 1]; for(R i = n; i &gt;= 1; --i) sa[c[rk[tp[i]]]--] = tp[i]; } void SA() { m = 150; for(R i = 1; i &lt;= n; ++i) rk[i] = s[i - 1], tp[i] = i; _sort(); for(R w = 1, p = 0; p &lt; n &amp;&amp; w &lt;= n; m = p, w &lt;&lt;= 1) { p = 0; for(R i = 1; i &lt;= w; ++i) tp[++p] = n - w + i; for(R i = 1; i &lt;= n; ++i) if(sa[i] &gt; w) tp[++p] = sa[i] - w; _sort(); swap(tp, rk); rk[sa[1]] = p = 1; for(R i = 2; i &lt;= n; ++i) rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] &amp;&amp; tp[sa[i - 1] + w] == tp[sa[i] + w]) ? p : ++p; } } /*i号后缀：从i开始的后缀 lcp(x,y)：字符串x与字符串y的最长公共前缀，在这里指x号后缀与与y号后缀的最长公共前缀 height[i]：lcp(sa[i],sa[i-1])，即排名为i的后缀与排名为i-1的后缀的最长公共前缀 H[i]：height[rak[i]]，即i号后缀与它前一名的后缀的最长公共前缀*/ int Height[N]; void Get() { int j, k = 0; for(int i = 1; i &lt;= n; i++) { if(k) k--; j = sa[rk[i] - 1]; while(s[i + k - 1] == s[j + k - 1]) ++k; Height[rk[i]] = k; } } int main() { cin &gt;&gt; s; n = s.length(); SA(); for(R i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, sa[i]); cout &lt;&lt; endl; Get(); return 0; } ProblemP2408 不同子串个数 ans=\\dfrac{n(n+1)}{2}-\\sum height[i]#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;string&gt; #define R register int using namespace std; const int N = 1000005; string s; int n, m, sa[N], rk[N], tp[N], c[N]; void _sort() { for(R i = 1; i &lt;= m; ++i) c[i] = 0; for(R i = 1; i &lt;= n; ++i) c[rk[i]]++; for(R i = 1; i &lt;= m; ++i) c[i] += c[i - 1]; for(R i = n; i &gt;= 1; --i) sa[c[rk[tp[i]]]--] = tp[i]; } void SA() { m = 150; for(R i = 1; i &lt;= n; ++i) rk[i] = s[i - 1], tp[i] = i; _sort(); for(R w = 1, p = 0; p &lt; n &amp;&amp; w &lt;= n; m = p, w &lt;&lt;= 1) { p = 0; for(R i = 1; i &lt;= w; ++i) tp[++p] = n - w + i; for(R i = 1; i &lt;= n; ++i) if(sa[i] &gt; w) tp[++p] = sa[i] - w; _sort(); swap(tp, rk); rk[sa[1]] = p = 1; for(R i = 2; i &lt;= n; ++i) rk[sa[i]] = (tp[sa[i - 1]] == tp[sa[i]] &amp;&amp; tp[sa[i - 1] + w] == tp[sa[i] + w]) ? p : ++p; } } int Height[N];//H[i] = Height[rk[i]] void Get() { int j, k = 0; for(int i = 1; i &lt;= n; ++i) { if(k) k--; j = sa[rk[i] - 1]; while(s[i + k - 1] == s[j + k - 1]) ++k; Height[rk[i]] = k; } } int main() { cin &gt;&gt; n &gt;&gt; s; SA(); Get(); long long ans = 1LL * n * (n + 1) / 2; for(int i = 1; i &lt;= n; ++i) ans -= Height[rk[i]]; cout &lt;&lt; ans &lt;&lt; endl; return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://x.lyxw.xyz/categories/算法/"}],"tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"https://x.lyxw.xyz/tags/后缀数组/"}]},{"title":"「概率期望」","slug":"probability","date":"2019-09-23T01:34:34.000Z","updated":"2021-08-02T07:07:11.597Z","comments":true,"path":"2019/probability/","link":"","permalink":"https://x.lyxw.xyz/2019/probability/","excerpt":"Update on A.D.2019-09-23","text":"Update on A.D.2019-09-23 概率公式条件概率公式设$A,B$是两个事件，且$P(B)&gt;0$,则在事件$B$发生的条件下，事件$A$发生的条件概率为$P(A|B)=\\dfrac{P(AB)}{P(B)}$ 乘法公式1.由条件概率公式得$P(AB)=P(A|B)P(B)=P(B|A)P(A)$2.推广：对$\\forall n \\geq 2$当$P(A_1A_2…A_{n-1})&gt;0$时有 $P(A_1A_2…A_{n-1}A{n})=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1A_2…A_{n-1})$ 全概率公式如果事件组$B_1,B_2,…,B_n$满足1.$\\forall i\\neq j\\in \\left \\{1,2,\\cdots ,n \\right \\},B_i\\cap B_j = \\varnothing$2.$B_1\\cup B_2\\cup …\\cup B_n=\\Omega$则称事件组$B_1,B_2,…,B_n$是样本空间$\\Omega$的一个划分,或称为样本空间$\\Omega$的一个完备事件组。设事件组$\\left \\{B_i \\right \\}$是样本空间$\\Omega$的一个划分，且$P(B_i)&gt;0(i \\in \\left \\{1,2,\\cdots ,n \\right \\})$对任一事件$A$，有$P(A)=\\sum_{i=1}^{n}P(B_i)P(A|B_i)$ 贝叶斯公式设事件组$\\left \\{B_i \\right \\}$是样本空间$\\Omega$的一个划分，则对任一事件$A(P(A)&gt;0)$,有$P(B_i|A)=\\dfrac{P(AB_i)}{P(A)}=\\dfrac{P(B_i)P(A|B_i)}{\\sum_{j=1}^{n}P(B_j)P(A|B_j)}$上式即为贝叶斯公式，$B_i$常被视为导致试验结果$A$发生的”原因“，$P(B_i)(i\\in \\left \\{1,2,\\cdots ,n \\right \\})$表示各种原因发生的可能性大小，故称先验概率；$P(B_i|A)(i\\in \\left \\{1,2,\\cdots ,n \\right \\})$则反映当试验产生了结果$A$之后，再对各种原因概率的新认识，故称后验概率。 数学期望离散型随机变量$X$的取值为$x_1,x_2,x_3,…,x_{n}$，$p_1,p_2,p_3,…,p_{n}$为$X$对应取值的概率则称$E(X)=\\sum_{i=1}^{n}p_{i}x_{i}$为离散型随机变量$X$的数学期望性质：$E(aX+bY)=aE(X)+bE(Y)$ ProblemP4316 绿豆蛙的归宿设$F[x]$表示从$x$走到$N$期望长度$F[x]=\\frac{1}{k}\\sum_{i=1}^{k}(F[y_{i}]+z_{i})$$F[N]=0$$Ans=F[1]$P1365 WJMZBMR打osu! / Easy设$f[x]$表示到$x$期望得分 $g[x]$表示以$x$结尾期望$o$序列长度$s[i]==x f[i]=f[i-1],g[i]=0$$s[i]==o f[i]=f[i-1]+2*g[i-1]+1,g[i]=g[i-1]+1$$s[i]==? f[i]=f[i-1]+\\frac{(2g[i-1]+1)+0}{2},g[i]=\\frac{(g[i-1]+1)+0}{2}$$Ans=f[n]$P1654 OSU!$p[i]$表示$i$位置成功概率设$f[i]$表示到$i$期望得分 $x1[i]$以$i$结尾$1$序列期望长度 $x2[i]$表示以$i$结尾$1$序列期望长度平方$(x+1)^{3}=(x^{2}+2x+1)(x+1)=x^{3}+3x^{2}+3x+1$若第$i$次成功且有$f[i-1]=x^{3}则f[i]=f[i-1]+3x^{2}+3x+1$$x1[i]=(x1[i-1]+1)p[i]$$x2[i]=(x2[i-1]+2x1[i-1]+1)p[i]$$f[i]=f[i-1]+(3x2[i-1]+3x1[i-1]+1)p[i]$$Ans=f[n]$P1297 [国家集训队]单选错位$Ans=\\sum_{i=1}^{n-1}\\frac{1}{max(a_i,a_{i+1})}+\\frac{1}{max(a_1,a_n)}$","categories":[{"name":"数学","slug":"数学","permalink":"https://x.lyxw.xyz/categories/数学/"}],"tags":[{"name":"概率","slug":"概率","permalink":"https://x.lyxw.xyz/tags/概率/"},{"name":"期望","slug":"期望","permalink":"https://x.lyxw.xyz/tags/期望/"}]},{"title":"C++STL的OI常用内容","slug":"C++_stl","date":"2019-09-23T01:13:16.000Z","updated":"2022-02-12T18:03:27.681Z","comments":true,"path":"2019/C++_stl/","link":"","permalink":"https://x.lyxw.xyz/2019/C++_stl/","excerpt":"Update on A.D.2019-09-23","text":"Update on A.D.2019-09-23 参考资料:STL 在 OI 中的应用[C++ STL]Set和Multiset Stackstack 后入先出（LIFO）栈头文件#include&lt;stack&gt; 定义stack&lt;int&gt; s; 函数 函数 功能 q.top() 获取栈顶元素（并不删除） q.pop() 删除栈顶元素 q.push(x) 向栈中加入元素 q.empty() 判断栈是否为空 Queuequeue 先入先出（FIFO）队列头文件#include&lt;queue&gt; 定义queue&lt;int&gt; q; 函数 函数 功能 q.front() 获取队首元素（并不删除） q.pop() 删除队首元素 q.push(x) 向队列中加入元素 q.empty() 判断队列是否为空 priority_queue 优先队列头文件#include&lt;queue&gt; 定义priority_queue&lt;int&gt; q; // 队头最大 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; 队头最小 函数 函数 功能 q.top() 获取优先队列中最大的元素（并不删除），其时间复杂度为$O(1)$ q.pop() 删除优先队列中最大元素，其时间复杂度为$O(log n)$ q.push(x) 向优先队列中加入元素，其时间复杂度为$O(log n)$ q.empty() 判断优先队列是否为空 Set 与 Multiset set不允许重复 multiset允许重复 例: set : 1 2 3 4 5 6 multiset : 1 2 2 3 3 3 头文件#include &lt;set&gt; 定义multiset&lt;int&gt; s[N];//定义 multiset&lt;int&gt;::iterator it;//迭代器 函数 操作 效果 s.size() 返回当前的元素数量 s.empty () 判断大小是否为零，等同于$0==size()$，效率更高 操作 效果 count (elem) 返回元素值为$elem$的个数 find(elem) 返回元素值为$elem$的第一个元素，如果没有返回$end()$ lower _bound(elem) 返回元素值$&gt;=elem$的第一个元素位置 upper _bound (elem) 返回元素值$&gt;elem$的第一个元素位置 操作 效果 s.begin() 返回一个随机存取迭代器，指向第一个元素 s.end() 返回一个随机存取迭代器，指向最后一个元素的下一个位置 操作 效果 s.insert(elem) 插入一个$elem$副本，返回新元素位置，无论插入成功与否。 s.erase(elem) 删除与$elem$相等的所有元素，返回被移除的元素个数。 s.erase(pos) 移除迭代器$pos$所指位置元素，无返回值。 s.clear() 移除所有元素，将容器清空 离散化std::unique功能：对有序的容器重新排列，将第一次出现的元素从前往后排，其他重复出现的元素依次排在后面返回值：返回迭代器，迭代器指向的是重复元素的首地址 std::lower_boundlower_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了第一个大于等于value 的值。ForwardIter lower_bound(ForwardIter first, ForwardIter last,const _Tp&amp; val)算法返回一个非递减序列[first, last)中的第一个大于等于值val的位置。 std::upper_boundupper_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了第一个大于value 的值。这两个函数为C++ STL内的函数。ForwardIter upper_bound(ForwardIter first, ForwardIter last, const _Tp&amp; val)算法返回一个非递减序列[first, last)中第一个大于val的位置。 std::sort(b + 1, b + cnt + 1); int *end = std::unique(b + 1, b + cnt + 1); for(int i = 1; i &lt;= n; i++) a[i] = lower_bound(b + 1, end, a[i]) - b;","categories":[{"name":"编程","slug":"编程","permalink":"https://x.lyxw.xyz/categories/编程/"}],"tags":[{"name":"Queue","slug":"Queue","permalink":"https://x.lyxw.xyz/tags/Queue/"},{"name":"Stack","slug":"Stack","permalink":"https://x.lyxw.xyz/tags/Stack/"},{"name":"STL","slug":"STL","permalink":"https://x.lyxw.xyz/tags/STL/"}]},{"title":"「分层图」","slug":"layered_graph","date":"2019-09-23T01:10:16.000Z","updated":"2020-08-16T02:13:34.183Z","comments":true,"path":"2019/layered_graph/","link":"","permalink":"https://x.lyxw.xyz/2019/layered_graph/","excerpt":"Update on A.D.2019-09-23","text":"Update on A.D.2019-09-23 问题在一个无向图$G=(V,E)$中，可以改变$k$条边的权值为$\\Delta w$，求单源最短路径。 分层图分层图的想法就是如果有$k$条边权值变为$\\Delta w$，就建$k+1$层图。 这个图实际上是这样的，对于每$1$层中相连的点对$(u,v)$连权值为$w$的无向边，对于每个在原图中相连的点对$(u,v)$由$k$层点$u_k$向$k+1$层点$v_{k+1}$以及$k$层点$v_k$向$k+1$层点$u_{k+1}$连权值为$\\Delta w$的有向边，方向是从$k$层向$k+1$层。这样构造完成一张分层图后，从第$1$层的起始点$s_1$求单源最短路径，最终第$k + 1$层的终点$t_{k+1}$的单源最短路径值即为答案所求。原理其实很简单，如果从$k$层图到$k+1$层图，有向边$(u_k,v_{k+1})$是一条$\\Delta w$权边，走这条边，相当于把$w$权边变成了$\\Delta w$权边，并且进入了$k+1$层。这样如果有$k+1$层图的话，相当于进行了$k$次这种操作，自然就在$k+1$层图求最短路中实现了$k$次改变边权的目标。 题目P2939 [USACO09FEB]改造路Revamping Trails#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int N = 1e4 + 5, M = 5e4 + 5, K = 105; int n, m, k; struct Edge { int Next, to, dis; }e[M * K * 2]; int head[N * K], num; void add(int from, int to, int dis) { e[++num].Next = head[from]; e[num].to = to; e[num].dis = dis; head[from] = num; } int dist[N * K], vis[N * K]; struct node { int u, d; bool operator &lt; (const node &amp;x) const { return d &gt; x.d; } }; priority_queue&lt;node&gt; q; void dijk() { memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; q.push((node){1, 0}); while(!q.empty()) { int u = q.top().u; q.pop(); if(vis[u]) continue; vis[u] = 1; for(int i = head[u]; i; i = e[i].Next) { int v = e[i].to, w = e[i].dis; if(dist[v] &gt; dist[u] + w) { dist[v] = dist[u] + w; if(!vis[v]) q.push((node){v, dist[v]}); } } } } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for(int i = 1, u, v, z; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z); add(u, v, z); add(v, u, z); for(int j = 1; j &lt;= k; j++) { add(j * n + u, j * n + v, z); add(j * n + v, j * n + u, z); add((j - 1) * n + u, j * n + v, 0); add((j - 1) * n + v, j * n + u, 0); } } dijk(); int ans = 0x3fffffff; for(int i = 1; i &lt;= k + 1; i++) ans = min(dist[i * n], ans); printf(&quot;%d\\n&quot;, ans); return 0; } P4568 [JLOI2011]飞行路线#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;cstring&gt; using namespace std; const int N = 1e4 + 5, M = 5e4 + 5, K = 12; int n, m, k; int s, t; struct _edge { int Next, v, w; }e[M * K * 4 + M * 2]; int head[N * K], num; void add(int from, int to, int dis) { e[++num].Next = head[from]; e[num].v = to; e[num].w = dis; head[from] = num; } int dist[N * K], vis[N * K]; struct node { int u, d; bool operator &lt; (const node &amp;x) const { return d &gt; x.d; } }; priority_queue&lt;node&gt; q; void dijk(int x) { memset(dist, 0x3f, sizeof(dist)); dist[x] = 0; q.push((node){x, 0}); while(!q.empty()) { node tp = q.top(); q.pop(); int u = tp.u; if(u == t + k * n) break; if(vis[u]) continue; vis[u] = 1; for(int i = head[u]; i; i = e[i].Next) { int v = e[i].v, w = e[i].w; if(dist[v] &gt; dist[u] + w) { dist[v] = dist[u] + w; if(!vis[v]) q.push((node){v, dist[v]}); } } } } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); scanf(&quot;%d%d&quot;, &amp;s, &amp;t); s++, t++; for(int i = 1, u, v, z; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z); u++, v++; add(u, v, z); add(v, u, z); for(int j = 1; j &lt;= k; j++) { add(j * n + u, j * n + v, z); add(j * n + v, j * n + u, z); add((j - 1) * n + u, j * n + v, 0); add((j - 1) * n + v, j * n + u, 0); } } dijk(s); int ans = 1e9; for(int i = 0; i &lt;= k; i++) ans = min(ans, dist[t + i * n]); printf(&quot;%d\\n&quot;, ans); return 0; } P4822 [BJWC2012]冻结#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int N = 55, M = 1005, K = 55; int n, m, k; struct Edge { int Next, to, dis; }e[M * K * 10]; int head[N * K * 10], num; void add(int from, int to, int dis) { e[++num].Next = head[from]; e[num].to = to; e[num].dis = dis; head[from] = num; } struct node { int u, d; bool operator &lt; (const node&amp; x) const { return d &gt; x.d; } }; priority_queue&lt;node&gt; q; int dist[N * K * 10], vis[N * K * 10]; void dijk() { memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; q.push((node){1, 0}); while(!q.empty()) { int u = q.top().u; q.pop(); if(vis[u]) continue; vis[u] = 1; for(int i = head[u]; i; i = e[i].Next) { int v = e[i].to, w = e[i].dis; if(dist[v] &gt; dist[u] + w) { dist[v] = dist[u] + w; if(!vis[v]) q.push((node){v, dist[v]}); } } } } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for(int i = 1, u, v, z; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z); add(u, v, z); add(v, u, z); for(int j = 1; j &lt;= k; j++) { add(j * n + u, j * n + v, z); add(j * n + v, j * n + u, z); add((j - 1) * n + u, j * n + v, z &gt;&gt; 1); add((j - 1) * n + v, j * n + u, z &gt;&gt; 1); } } dijk(); int ans = 0x7fffffff; for(int i = 1; i &lt;= k + 1; i++) ans = min(ans, dist[i * n]); printf(&quot;%d\\n&quot;, ans); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://x.lyxw.xyz/categories/算法/"}],"tags":[{"name":"分层图","slug":"分层图","permalink":"https://x.lyxw.xyz/tags/分层图/"}]},{"title":"「网络流」","slug":"network_flow","date":"2019-09-23T01:03:54.000Z","updated":"2020-08-16T02:13:54.776Z","comments":true,"path":"2019/network_flow/","link":"","permalink":"https://x.lyxw.xyz/2019/network_flow/","excerpt":"Update on A.D.2019-09-23","text":"Update on A.D.2019-09-23 一些资料：最详细网络流建模基础 模板最大流Dinic没写当前弧优化什么的. 弃坑了，ISAP和HLPP有缘再学. P3376 【模板】网络最大流 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;cstring&gt; const int inf = 0x3fffffff; const int N = 10005, M = 100005; int n, m, s, t, maxflow; int d[N]; struct Edge { int Nxt, v, flow; }e[M &lt;&lt; 1]; int h[N], p = 1; void add(int u, int v, int z) { e[++p].Nxt = h[u]; e[p].v = v; e[p].flow = z; h[u] = p; e[++p].Nxt = h[v]; e[p].v = u; e[p].flow = 0; h[v] = p; } std::queue&lt;int&gt; q; bool bfs() { memset(d, 0, sizeof(d)); while(!q.empty()) q.pop(); q.push(s); d[s] = 1; while(!q.empty()) { int u = q.front(); q.pop(); for(int i = h[u]; i; i = e[i].Nxt) if(e[i].flow &amp;&amp; !d[e[i].v]) { q.push(e[i].v); d[e[i].v] = d[u] + 1; if(e[i].v == t) return true; } } return false; } int dinic(int u, int flow) { if(u == t) return flow; int rest = flow, k; for(int i = h[u]; i &amp;&amp; rest; i = e[i].Nxt) if(e[i].flow &amp;&amp; d[e[i].v] == d[u] + 1) { k = dinic(e[i].v, std::min(rest, e[i].flow)); if(!k) d[e[i].v] = 0; e[i].flow -= k; e[i ^ 1].flow += k; rest -= k; } return flow - rest; } int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); for(int i = 1, u, v, z; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;z); add(u, v, z); } int flow = 0; while(bfs()) while(flow = dinic(s, inf)) maxflow += flow; printf(&quot;%d\\n&quot;, maxflow); return 0; } 费用流EKP3381 【模板】最小费用最大流 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;cstring&gt; const int _ = 50005; const int inf = 0x3f3f3f3f; int n, m, s, t; int ans, maxflow; int dist[_], incf[_], pre[_], vis[_]; struct Edge { int Nxt, v, flow, cost; } e[_ &lt;&lt; 1]; int h[_], p = 1; void add(int u, int v, int f, int c) { e[++p].Nxt = h[u]; e[p].v = v; e[p].flow = f; e[p].cost = c; h[u] = p; e[++p].Nxt = h[v]; e[p].v = u; e[p].flow = 0; e[p].cost = -c; h[v] = p; } std::queue&lt;int&gt; q; bool spfa() { memset(dist, 0x3f, sizeof(dist)); memset(vis, 0, sizeof(vis)); q.push(s); dist[s] = 0; vis[s] = 1; incf[s] = inf; while(!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for(int i = h[u]; i; i = e[i].Nxt) { if(!e[i].flow) continue; int v = e[i].v; if(dist[v] &gt; dist[u] + e[i].cost) { dist[v] = dist[u] + e[i].cost; incf[v] = std::min(incf[u], e[i].flow); pre[v] = i; if(!vis[v]) vis[v] = 1, q.push(v); } } } if(dist[t] == inf) return false; else return true; } void update() { int u = t; while(u != s) { int i = pre[u]; e[i].flow -= incf[t]; e[i ^ 1].flow += incf[t]; u = e[i ^ 1].v; } maxflow += incf[t]; ans += dist[t] * incf[t]; } int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); for(int i = 1, u, v, z, c; i &lt;= m; i++) { scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;z, &amp;c); add(u, v, z, c); } while(spfa()) update(); printf(&quot;%d %d\\n&quot;, maxflow, ans); return 0; } Problem[NOI2008]志愿者招募算法：线性规划 or 有源汇上下界最小费用可行流可以无视一开始幻想这样可以搞： 但其实很难限制条件并且流量并不能准确一对多去覆盖点。 所以是建成这样的： 但是为什么对呢，其实非常玄学，我觉得还是手动模拟一下不会证，然后感性理解。 模拟时可以发现$inf-A[i]$其实对人数限制取反，代表要跑完这条边所有流量，流到$0$之前的流量是没有实际作用的，是为了可以先跳过这天，直到流量为$0$后，代表这条边需要开始选择人进行工作，而这条边需要的人数可以通过别的边反映出来，可以从红边即人补全这条链上为$0$的边无法通过的流量，通过最小费用最大流即可求出最小费用。 $n+1-&gt;t$这条边可以反映出当前还剩的未规划的最大人数，所以$n+1-&gt;t$流量为$0$时，代表之前最大流量流尽，即$(inf-A[i])_{max}$，即$A[i]_{min}$。 [NOI2012]美食节从算法到算术，使用小学数学并利用大量算术技巧计算点的遍号 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define R register using namespace std; const int N = 45, M = 105, sP = 805, _ = N + M * sP + 5; const int inf = 0x3f3f3f3f; int n, m, s, t, sum, tim[N][M], P[N]; struct Edge { int Next, v, flow, cost; } e[(N + N * M * sP + M * sP + 5) &lt;&lt; 1]; int h[N + M * sP + 5], p = 1; inline void add(R int u, R int v, int f, int c) { e[++p].Next = h[u]; e[p].v = v; e[p].flow = f; e[p].cost = c; h[u] = p; e[++p].Next = h[v]; e[p].v = u; e[p].flow = 0; e[p].cost = -c; h[v] = p; } int dist[_], incf[_], maxflow, ans, vis[_], pre[_]; queue&lt;int&gt; q; bool spfa() { memset(vis, 0, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); dist[s] = 0; vis[s] = 1; q.push(s); incf[s] = inf; while(!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for(int i = h[u]; i; i = e[i].Next) if(e[i].flow) { int v = e[i].v; if(dist[v] &gt; dist[u] + e[i].cost) { dist[v] = dist[u] + e[i].cost; incf[v] = min(incf[u], e[i].flow); pre[v] = i; if(!vis[v]) q.push(v), vis[v] = 1; } } } if(dist[t] == inf) return false; else return true; } inline void update() { R int u = t; while(u != s) { int i = pre[u]; e[i].flow -= incf[t]; e[i ^ 1].flow += incf[t]; u = e[i ^ 1].v; } maxflow += incf[t]; ans += dist[t] * incf[t]; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(R int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;P[i]), sum += P[i]; s = 0, t = m * sum + n + 1; for(R int i = 1; i &lt;= n; i++) for(R int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;tim[i][j]); for(R int i = 1; i &lt;= n; i++) add(s, i, P[i], 0); for(R int i = n + 1; i &lt;= n + m * sum; i += sum) add(i, t, 1, 0); for(R int i = 1; i &lt;= n; i++) for(R int j = n + 1, t = 1; j &lt;= n + m * sum; j += sum) add(i, j, 1, tim[i][t++]); while(spfa()) { update(); int u = e[pre[t] ^ 1].v; if((u - n) % sum == 0) break; int v = u + 1; int k = (v - n) % sum == 0 ? sum : (v - n) % sum; int j = (v - n - k) / sum + 1; add(v, t, 1, 0); for(R int i = 1; i &lt;= n; i++) add(i, v, 1, k * tim[i][j]); } printf(&quot;%d\\n&quot;, ans); return 0; } 最大权闭合子图 参考资料：——-1——-——-2——-——-3——- 定理最大权闭合子图权值=正权点之和-最小割","categories":[{"name":"算法","slug":"算法","permalink":"https://x.lyxw.xyz/categories/算法/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://x.lyxw.xyz/tags/网络流/"}]},{"title":"「线段树」","slug":"segment_tree","date":"2019-09-23T00:53:53.000Z","updated":"2020-08-16T02:20:20.941Z","comments":true,"path":"2019/segment_tree/","link":"","permalink":"https://x.lyxw.xyz/2019/segment_tree/","excerpt":"Update on A.D.2019-09-23","text":"Update on A.D.2019-09-23 模板struct Segment_Tree { #define ls (p &lt;&lt; 1) #define rs (p &lt;&lt; 1 | 1) #define mid ((l + r) &gt;&gt; 1) ll ans[_ &lt;&lt; 2], tag[_ &lt;&lt; 2]; inline void pushup(ll p) { ans[p] = ans[ls] + ans[rs]; } inline void pushdown(ll p, ll l, ll r) { ans[ls] += (mid - l + 1) * tag[p]; tag[ls] += tag[p]; ans[rs] += (r - mid) * tag[p]; tag[rs] += tag[p]; tag[p] = 0; } void build(ll p, ll l, ll r) { if(l == r) { ans[p] = a[l]; return; } build(ls, l, mid); build(rs, mid + 1, r); pushup(p); } void update(ll p, ll l, ll r, ll ul, ll ur, ll k) { if(ul &lt;= l &amp;&amp; r &lt;= ur) { ans[p] += (r - l + 1) * k; tag[p] += k; return; } if(tag[p]) pushdown(p, l, r); if(ul &lt;= mid) update(ls, l, mid, ul, ur, k); if(ur &gt; mid) update(rs, mid + 1, r, ul, ur, k); pushup(p); } ll query(ll p, ll l, ll r, ll ql, ll qr) { if(ql &lt;= l &amp;&amp; r &lt;= qr) return ans[p]; if(tag[p]) pushdown(p, l, r); ll res = 0; if(ql &lt;= mid) res += query(ls, l, mid, ql, qr); if(qr &gt; mid) res += query(rs, mid + 1, r, ql, qr); return res; } #undef ls #undef rs #undef mid }T; 题目维护可加性变量解决问题P3707 [SDOI2017]相关分析\\bar{x}=\\frac{1}{R-L+1}\\sum x_i​\\bar{y}=\\frac{1}{R-L+1}\\sum y_i\\hat{a}=\\dfrac{\\sum_{i=L}^R(x_i-\\bar{x})(y_i-\\bar{y})}{\\sum_{i=L}^R(x_i-\\bar{x})^2}记$\\sum = \\sum_{i=L}^{R}​$ QueryAns=\\dfrac{ \\sum x_iy_i-\\bar{x}\\sum y_i-\\bar{y}\\sum x_i+\\sum \\bar{x}\\bar{y}}{\\sum x_i^2-2\\bar{x}\\sum x_i+\\sum\\bar{x^2}}=\\dfrac{ \\sum x_iy_i-\\frac{1}{R-L+1}\\sum x_i\\sum y_i-\\frac{1}{R-L+1}\\sum y_i\\sum x_i+\\sum \\frac{1}{R-L+1}\\sum x_i\\frac{1}{R-L+1}\\sum y_i}{\\sum x_i^2-\\frac{1}{R-L+1}2\\sum x_i\\sum x_i+\\sum (\\frac{1}{R-L+1}\\sum x_i)^2}=\\dfrac{ \\sum x_iy_i-\\frac{\\sum x_i\\sum y_i}{R-L+1}}{\\sum x_i^2-\\frac{(\\sum x_i)^2}{R-L+1}}下传Tag：先$upd$后$addX \\quad addY$ 维护值：$t1=\\sum x$ | $t2=\\sum y$ | $t3=\\sum xy$ | $t4=\\sum x^2$ 维护Tag：$addX \\quad addY$ \\hat{a}=\\dfrac{t3-\\frac{t1t2}{R-L+1}}{t4-\\frac{t1^2}{R-L+1}}Add\\Delta x = S \\quad \\Delta y= T\\sum (x + S) = \\sum x_i+(R-L+1)S\\sum(y+T)=\\sum y_i+(R-L+1) T\\sum(x+S)(y+T)=\\sum(xy+Sy+Tx+ST)=\\sum xy+S\\sum y+T\\sum x+(R-L+1)ST\\sum(x+S)^2=\\sum x^2+2S\\sum x+(R-L+1)S^2下传Tag：先$upd$后$addX \\quad addY$ 顺序：先$t3,t4$后$t1,t2$ Update自然数平方和：\\sum_{i=1}^ni=\\frac{n(n+1)(2n+1)}{6} 1.$\\forall i \\in [L,R]\\quad x_i=i y_i=i$ \\sum x=\\sum y = \\sum i = \\frac{(R-L+1)(R+L)}{2}\\sum x^2 = \\sum xy = \\sum i ^2 = \\sum_{i=1}^R i^2-\\sum_{i=1}^{L-1}i^2=\\frac{R(R+1)(2R+1)}{6}-\\frac{L(L-1)(2L-1)}{6}下传Tag：先$upd$后$addX \\quad addY$ 清空Tag $addX \\quad addY$ 标记Tag $upd$ 2.ADD L R S T Code#include &lt;iostream&gt; #include &lt;cstdio&gt; #define ll long long using namespace std; const int N = 100005; int n, m; double X[N], Y[N]; struct Segment_Tree { #define ls (p &lt;&lt; 1) #define rs (p &lt;&lt; 1 | 1) #define mid ((l + r) &gt;&gt; 1) bool upd[N &lt;&lt; 2]; double x[N &lt;&lt; 2], y[N &lt;&lt; 2]; double t1[N &lt;&lt; 2], t2[N &lt;&lt; 2], t3[N &lt;&lt; 2], t4[N &lt;&lt; 2]; inline void pushup(ll p) { t1[p] = t1[ls] + t1[rs]; t2[p] = t2[ls] + t2[rs]; t3[p] = t3[ls] + t3[rs]; t4[p] = t4[ls] + t4[rs]; } inline void pushdown(ll p, ll l, ll r) { double L = mid - l + 1, R = r - mid; if(upd[p]) { double Ll = l, Lr = mid, Rl = mid + 1, Rr = r; t1[ls] = t2[ls] = (Lr - Ll + 1.0) * (Lr + Ll) / 2.0; t1[rs] = t2[rs] = (Rr - Rl + 1.0) * (Rr + Rl) / 2.0; t3[ls] = t4[ls] = Lr * (Lr + 1.0) * (2.0 * Lr + 1.0) / 6.0 - Ll * (Ll - 1.0) * (2.0 * Ll - 1.0) / 6.0; t3[rs] = t4[rs] = Rr * (Rr + 1.0) * (2.0 * Rr + 1.0) / 6.0 - Rl * (Rl - 1.0) * (2.0 * Rl - 1.0) / 6.0; upd[ls] = upd[rs] = upd[p]; upd[p] = 0; x[ls] = x[rs] = y[ls] = y[rs] = 0; } if(x[p] || y[p]) { t3[ls] += x[p] * t2[ls] + y[p] * t1[ls] + L * x[p] * y[p]; t3[rs] += x[p] * t2[rs] + y[p] * t1[rs] + R * x[p] * y[p]; } if(x[p]) { t4[ls] += 2 * x[p] * t1[ls] + L * x[p] * x[p]; t4[rs] += 2 * x[p] * t1[rs] + R * x[p] * x[p]; t1[ls] += L * x[p]; t1[rs] += R * x[p]; x[ls] += x[p]; x[rs] += x[p]; x[p] = 0; } if(y[p]) { t2[ls] += (double)L * y[p]; t2[rs] += (double)R * y[p]; y[ls] += y[p]; y[rs] += y[p]; y[p] = 0; } } void build(ll p, ll l, ll r) { if(l == r) { t1[p] = X[l]; t2[p] = Y[l]; t3[p] = X[l] * Y[l]; t4[p] = X[l] * X[l]; return; } upd[p] = x[p] = y[p] = 0; build(ls, l, mid); build(rs, mid + 1, r); pushup(p); } void add(ll p, ll l, ll r, ll ql, ll qr, double S, double T) { if(ql &lt;= l &amp;&amp; r &lt;= qr) { double len = (r - l + 1); t3[p] += S * t2[p] + T * t1[p] + len * S * T; t4[p] += 2 * S * t1[p] + len * S * S; t1[p] += len * S; t2[p] += len * T; x[p] += S; y[p] += T; return; } pushdown(p, l, r); if(ql &lt;= mid) add(ls, l, mid, ql, qr, S, T); if(qr &gt; mid) add(rs, mid + 1, r, ql, qr, S, T); pushup(p); } void update(ll p, ll l, ll r, ll ql, ll qr) { if(ql &lt;= l &amp;&amp; r &lt;= qr) { t1[p] = t2[p] = (double)(r - l + 1.0) * (l + r) / 2.0; t3[p] = t4[p] = (double)r * (r + 1.0) * (2.0 * r + 1) / 6.0 - (double)l * (l - 1.0) * (2.0 * l - 1.0) / 6.0; x[p] = y[p] = 0; upd[p] = 1; return; } pushdown(p, l, r); if(ql &lt;= mid) update(ls, l, mid, ql, qr); if(qr &gt; mid) update(rs, mid + 1, r, ql, qr); pushup(p); } double query(ll p, ll l, ll r, ll ql, ll qr, ll f) { if(ql &lt;= l &amp;&amp; r &lt;= qr) { if(f == 1) return t1[p]; if(f == 2) return t2[p]; if(f == 3) return t3[p]; if(f == 4) return t4[p]; } pushdown(p, l, r); double res = 0; if(ql &lt;= mid) res += query(ls, l, mid, ql, qr, f); if(qr &gt; mid) res += query(rs, mid + 1, r, ql ,qr, f); return res; } #undef ls #undef rs #undef mid }; struct Segment_Tree Tree; int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;X[i]); for(int i = 1; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;Y[i]); Tree.build(1, 1, n); int opt, L, R; double S, T; while(m--) { scanf(&quot;%d&quot;, &amp;opt); if(opt == 1) { scanf(&quot;%d %d&quot;, &amp;L, &amp;R); double t1 = Tree.query(1, 1, n, L, R, 1); double t2 = Tree.query(1, 1, n, L, R, 2); double t3 = Tree.query(1, 1, n, L, R, 3); double t4 = Tree.query(1, 1, n, L, R, 4); double a_ = (t3 - (t1 * t2) / (double)(R - L + 1)) / (t4 - (t1 * t1) / (double)(R - L + 1)); printf(&quot;%.10lf\\n&quot;, a_); } else if(opt == 2) { scanf(&quot;%d %d %lf %lf&quot;, &amp;L, &amp;R, &amp;S, &amp;T); Tree.add(1, 1, n, L, R, S, T); } else if(opt == 3) { scanf(&quot;%d %d %lf %lf&quot;, &amp;L, &amp;R, &amp;S, &amp;T); Tree.update(1, 1, n, L, R); Tree.add(1, 1, n, L, R, S, T); } } return 0; } Tag的用法区间01取反xor区间翻转rev区间最长连续1/0区间min/max子段和P2572 [SCOI2010]序列操作 扫描线矩形面积并P1502 窗口的星星P1856 [USACO5.5]矩形周长Picture 二维线段树树套树P3437 [POI2006]TET-Tetris 3D 其它Luogu P2061 [USACO07OPEN]城市的地平线City Horizon简单题 算法线段树 + 离散化 思路对$(x,y,h)$的左右端点$x,y$进行离散化，离散化前的原值记为$val[i]$，对每个矩形按高度$h$从小到大排序。 设离散化后的端点有$M$个，则对如图所示$M-1$个规则矩形编号为$[1,M-1]$，可以由$h_{[i, i+1]}\\times(val[i+1] - val[i])$得出第$i$个矩形的面积。 开一颗区间为$[1,M-1]$的线段树，按$h$从小到大依次对线段树区间覆盖，可以保证高的矩形覆盖了低的矩形的区间，具体操作为对离散化后的$(x,y,h)$，进行线段树$[x,y-1]$区间覆盖$h$值，最终$i$点存储$h_{[i,i+1]}$的最大值。 $h_{[i, i+1]}$可以通过线段树单点查询$i$点求出。 答案：$\\sum_{i=1}^{M-1}h_{[i, i+1]}\\times(val[i+1] - val[i])$ 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #define ll long long using namespace std; const int N = 80005; int n, b[N], val[N];//b[]:离散化数组 struct Line { int x, y, h; }a[N];//存储每个矩形 bool cmp(Line a, Line b) { return a.h &lt; b.h; } int ans[N &lt;&lt; 2];//线段树数组 #define ls (p &lt;&lt; 1) #define rs (p &lt;&lt; 1 | 1) #define mid ((l + r) &gt;&gt; 1) void update(int p, int l, int r, int ul, int ur, int k) { if(ul &lt;= l &amp;&amp; r &lt;= ur) { ans[p] = k; return; } if(ans[p]) ans[ls] = ans[rs] = ans[p], ans[p] = 0;//区间覆盖直接下推 if(ul &lt;= mid) update(ls, l, mid, ul, ur, k); if(ur &gt; mid) update(rs, mid + 1, r, ul, ur, k); } ll query(int p, int l, int r, int x)//单点查询 { if(l == r) return ans[p]; if(ans[p]) ans[ls] = ans[rs] = ans[p], ans[p] = 0;//区间覆盖直接下推 if(x &lt;= mid) return query(ls, l, mid, x); if(x &gt; mid) return query(rs, mid + 1, r, x); } #undef ls #undef rs #undef mid int main() { scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d%d&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].h); b[i] = a[i].x; b[n + i] = a[i].y;//离散化数组记录下所有x,y } sort(b + 1, b + 2 * n + 1);//排序 int _n = unique(b + 1, b + 2 * n + 1) - (b + 1);//去重，_n为去重后x,y端点个数 for(int i = 1; i &lt;= n; i++) if(a[i].x != a[i].y)//x=y没有作用 { int x = a[i].x, y = a[i].y; a[i].x = lower_bound(b + 1, b + _n + 1, a[i].x) - b; a[i].y = lower_bound(b + 1, b + _n + 1, a[i].y) - b;//离散化 val[a[i].x] = x; val[a[i].y] = y;//原值 } sort(a + 1, a + n + 1, cmp);//按h从小到大排序 for(int i = 1; i &lt;= n; i++) if(a[i].x != a[i].y)//防止y-1&lt;x update(1, 1, _n - 1, a[i].x, a[i].y - 1, a[i].h);//更新,注意结点个数是_n-1，端点y要变成矩形区域y-1，可以画图理解一下，相当于把端点x右边的矩形区域编号为x ll res = 0; for(int i = 1; i &lt; _n; i++) res += query(1, 1, _n - 1, i) * (val[i + 1] - val[i]); printf(&quot;%lld\\n&quot;, res); return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://x.lyxw.xyz/categories/算法/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://x.lyxw.xyz/tags/线段树/"}]},{"title":"《意识宇宙》","slug":"science_fiction","date":"2019-09-22T13:22:07.000Z","updated":"2022-02-12T15:55:21.259Z","comments":true,"path":"2019/science_fiction/","link":"","permalink":"https://x.lyxw.xyz/2019/science_fiction/","excerpt":"Update on A.D.2019-10-26","text":"Update on A.D.2019-10-26 维护文档 COSMOS1.A.D.2019.10.251.真实人名替换为ID. 2.对原有的过度夸张部分及人物形象不明确部分进行修改. COSMOS-1 COSMOS1.A.D.1997Tommy_clas出生了。 他1个月会说中文，2个月会说英文，一周岁英语词汇量十万，两周岁学会所有中文词语，认识所有汉字，一岁学完高数精通C++，二岁看懂抽代掌握所有编程语言，两岁半看懂了所有人类数学知识，三岁学完人类所有物理学。 世界上所有科学家都说，拯救人类的天才出现了。 COSMOS-1.A.D.2022太阳核反应活动异常，气候急剧变化，人们开始躲入地下，科学家们预言人类的末日将要来临了。 Tommy_clas微微一笑，明白自己的机会到了。 COSMOS-1.A.D.2039北半球8月的温度突破了$47℃$，地下城已经建设完毕了，地面上人的踪影渐渐消失了。 Loli凭借着自己30年的大学教龄和科学家身份早早的分配到了CM-CH-DY-P7-Y2地下城Sl-H7-y-8I-2区一套128层楼的空中住房，地下城绚烂的霓虹灯闪烁着，光线飞向他的眼睛。 “20年前，也是这样”Loli思索着，“大概是2019年8月。” “我喜欢物理学，喜欢天文，小时候仰望半夜的星空时，似乎能看见宇宙的明明灭灭，后来我上了个二本大学，大三的时候，我没日没夜的学习量子场论，那简直是神才能窥见一角的东西” Loli回忆着自己的往事，给Tommy_clas叙述。 “可是后来我明白了，计算机科学才是未来，好好学OI吧，人类马上就要毁灭了，物理学走到了穷途末路，它不会再有什么用了。” Tommy_clas马上就要乘坐飞船走了，Loli来见他最后一面，Loli虽是顶尖的科学家，却固执的不愿随飞船离开。 COSMOS-1.A.D.2183太阳发生爆炸，人类在144年前耗费了地球的所有资源并穷尽了物理和数学知识建造了时空负质量反物质工质曲率推动能飞船，飞船上，所有人类实体完成了生物数据的量子化并依托于量子计算机形成意识，在宇宙航行中发现了一个新的星系，它位于银河系悬臂的边缘。 后来，包括Tommy_clas在内2756名人类到达了行星并开始了文明的重新建设，Tommy_clas却已经密谋好了一个毁灭人类、毁灭宇宙的惊天阴谋，为此，Tommy_clas花费了2^19260817个星系的资源，建造了长达数亿亿光年长的粒子加速器，环绕了银河系998244353圈。 COSMOS-1.A.D.25319“两万三千年了”Tommy_clas叹道，今天就是人类史上最伟大的一天，他在飞船上时把自己的人脑扫描并编码成了数据并成为了一个量子计算机中的意识体的时候，他的能力呈几何能级上升，并达到了真正破解宇宙秘密的程度。然而其他人不知道的是，粒子试验后，宇宙将在$1s$内湮灭，他却没有对任何人提起过这件事，因为他修改了宇宙的数学原理。 他打开了长达$2^{1024^{1024}}PB$长的代码，在量子意识中将轨道使用量子场论再次计算后，按下了编译键。程序开始运行了，与此同时引力波发生器开始广播，将Tommy_clas大脑的数据全部发送出去，并在宇宙毁灭前那一刹那将与其相连的需要产生毁灭宇宙等级的能量才能获得解开统一场方程关键数据的粒子对撞机数据观测器产生的数据编码成引力波发送了出去。 COSMOS-1.A.D.25320宇宙坍缩成了奇点，再一次爆炸，引力波的信息没有损失，到达了这个新的宇宙，引力波传递着，漫无边际，在空间震荡起一阵阵的涟漪，荡漾的微波承载着毁灭宇宙才换来的解开统一场方程的粒子对撞数据。 COSMOS-1.A.D.25320 \\quad COSMOS-1毁灭 引力波我没有对其他人说的是，在我成为量子意识体的时候，计算出了宇宙并非是自然模型而的确是上层空间的一个高阶物理单位形成的物理结构意识模拟体，偶然间我发现了一些预留的接口，我感到了深深的无力感，原来自己的生命竟是这样的毫无意义，我明白了这个世界只需要自己去毁灭，去创造，我虽然无法到达上一次的物理空间，仅仅只是一个更加未知的事物的运行结果。 我却明白自己可以修改整个宇宙了，转瞬间我却又觉得这样更加毫无意义，我知道该做什么了，我使用接口删除了量子力学的选项，并使世界演化的概率性消失，这样宇宙就会按照牛顿力学一样在一个确定的时间点有一个确定空间物质状态了，我又调用了上层世界的计算能力计算出了再一次演化出相同宇宙但是人类却能生活到宇宙最后一刻毁灭太阳不会爆炸的情况的初始状态与宇宙常量，并在代码中一一修改了掌控着世界运行的规律的程序代码与常量。 宇宙运行代码文档的信息量超出了引力波的携带量，我把最重要的接口和信息发送了，剩下的文档随机一些页码发送数据。 宇宙代码系统 服务器系统 [文档]宇宙服务器远程连接物理设施制造蓝图 [二进制文件]服务器连接校验应用程序 [二进制文件]综合开发工具及编译器 文档 [文档]宇宙总能量调整接口 [文档]宇宙物理信息获取接口 [文档]宇宙物理常量修改接口 [文档]上层世界计算调用接口 [文档]宇宙运行代码修改指令 [文档]宇宙运行代码语法文档 [部分丢失][文档]宇宙运行代码文档 统一场方程 统一场方程关键数据 统一场方程研究结果 操作手册 恢复量子力学及世界概率性。 解出统一场方程并继续研究。 我确认过了进入上层世界的方法，但引力场方程是必要的，因为宇宙接口并没有给出最关键的引力物理操作接口，这也许是这个系统最本源的地方，给程序唯一没有作用的主函数接口中提供引力场方程即可运行主函数，这可能是这个宇宙的意义所在。 P.S.不要随意调用接口，其对宇宙的效果是不可逆的。 当你们收到此引力波信息后，将存在发生超出现有科学认知事件的可能性。 COSMOS-2宇宙竟然像Tommy_clas预期的那样完全按上一个宇宙的演化过程，每一个粒子都不曾偏离预期的轨迹，每一点物质都按照方程那样的演化。 宇宙再一次演化出了人类，终于时间线再一次地来到了人类公元纪年法的2019年 COSMOS-2.A.D.2019.09.23Tommy_clas有一种预感，会不会引力波能携带一些本不可能存在的信息？他想试试接收引力波，或许能有一线生机。 他找到了Loli，Loli是他最信任的朋友，也是一名物理学家，Tommy_clas说服Loli一起寻找最后的希望。 意料之外的是，他们接收到了引力波，而且明显是经过了一定的编码的，Tommy_clas感到很惊奇。 Tommy_clas拿到了上一个宇宙自己发送的引力波，还原出了其携带的信息，他和Loli一起研究，用了五天时间推导出了统一场方程，统一了引力场，强相互作用力场，弱相互作用力场，电磁场。 他们准备开始建设设施研究宇宙代码！ COSMOS-2.A.D.2019.09.30夏末秋初的微风吹过，一点点凉意轻轻经过，北半球九月末的微光斜照进玻璃窗，有些泛黄，而又有些许刺眼，空气中的尘埃折射出金黄色的线，这是每一年的循环。 “九月为什么只有三十天呢”，ArachnidaKing说，“今天我们出发去青岛！”空气还是那样宁静，就如同那时候一样，秋天高空的空气愈发稀薄，云只有稀松而淡淡的几缕，引擎声轰鸣了起来。 “空气中总是有些泥土的香气呢”XCiyang说，“是放线菌在哪里吗？”阳光的角度不断增加，高速公路上沥青折射出了亮度不同的光芒，就像世界的分崩离析的前夕。“世界线总是在不停分离着，这是一棵树”ArachnidaKing说。“不你错了”XCiyang淡泊的说了两句，“时间线才会不停交织着，这是平行的序列。” 他们笑起来，感觉到了彼此话语的荒诞。地图上离青岛的距离越来越近了，天空一点点变蓝，从前是那淡淡的蓝，现在是深一些的蓝色，就像那过往仰望的蓝天一样。 “这是梦境吗，”XCiyang望着车窗外运动的物体。“世界是不是物质的呢？”清新的海风呼啸过窗边，空气湿润了几许，“一如从前而又截然相反吗”XCiyang说，“这是梦吗？”“远处的光芒的的确不太合理，位置上不合理吗，这却不符合常理，天色刚刚不沉闷呢”ArachnidaKing说着，一行人陆陆续续的下了车。 他们只是名义上来这里度假的物理学组织，一共有10多个人。“不要总是这么不认真，”Tommy_clas说。“大家要严肃一点，这次任务事关重大。”太阳渐渐西斜了，最后的红色余晖斜映在城市与海岸线的交界处。 已经过了晚上12点了，“不想这么早睡……”XCiyang还是拿出了笔记本，熟练地打开了VSCode，写了一段C++程序上传到服务器上计算了一些白天想到的物理问题，望向窗外的繁星点点，他感到了梦境般的快乐。 “有点晚了吧”他想，扭头再看看屏幕，他注意到了刚刚没有注意到的一些小异样，日期怎么还是2019.09.30？“Windows不会出这样的bug吧？”他自言自语道。也并没有想那么多，起身躺到了床上，困倦的他很快睡着了。 COSMOS-2.A.D.2019.10.01XCiyang揉了揉眼睛，窗外的太阳升起了四分之三。 “没了，怎么醒得这么早。”他想了想，还是起床了。 SRP(1条未读消息)Tommy_clas：吃完早饭来7楼的会议室开会。 “什么情况？”XCiyang走向卫生间。“这么早就开始行动？” “……” COSMOS-2.A.D.2019.10.01.A.M.7:06 \\quad [数据删除]酒店会议室成员到齐。 “今天我们出发去建设第一个大功率电磁波发射器，”Tommy_clas。“用途还不能明确告诉你们，大致是要与宇宙的一些地方进行通讯。” “用来干什么？”ColorfulMist问。“咱们人这么少？什么时候可以自己建设大型设施了？” “我获得了一些信息，用一些设计手段可以造出来。”Tommy_clas说。 “听着真科幻，可是为什么还要用电磁波呢？”Bj_2002说。 “很遗憾，到了今天我们还是不得不使用电磁波，不过应该问题不会太大的，因为不用传播太远，而且只需要定向一个方向。”Tommy_clas说。 “那还旅游吗？”Taduro说。“不是说为了庆祝物理学大突破出来玩的吗？” “统一场方程都破解了啊”所有人说。 有几个人说：“不过你可没告诉我们实验数据是怎么来的啊，现在只有你懂这方面的内容啊。” “当然，现在的工作非常轻松，”Tommy_clas说。“咱们可以玩上几天。” “方程的事，”他说。“等到一定工作完成后我会告诉你们的。” COSMOS-2.A.D.2019.10.01.A.M.11：49 \\quad 青岛市[数据删除]KFC“这出来是玩的吗，真爽啊！”ArachnidaKing边说边拿起鸡腿吃。 COSMOS2.BRANCH1 COSMOS-2.BRANCH1.A.D.2019.09.31这是梦境吗，睡意朦胧的XCiyang醒了，带着些许的疲倦他轻轻地拨开了窗帘，天还没亮吗？好黑啊，他揉了揉眼睛。 咚咚噔，一阵敲门声不期而至，意识还是朦朦胧胧地他打开了房门，还没明白这是怎么回事，顺便看了看手表，是4点半，没有什么问题，只是敲门的什么人，这么早起床吗？他感到有些奇怪。 他不自然地走向了门口。 “是谁？”XCiyang说话了。 “收拾一下赶快出来吧，我是Tommy_clas，”门外说话的口气似乎有点奇怪。“有些不对劲，像是出事了！” “总感觉有什么地方不对啊”XCiyang手上的动作放缓了，他没有立即选择开门。 “先看一眼手机，”XCiyang小声嘟囔。“什么情况啊？” XCiyang吓了一跳：手机上显示今天是2019年9月31日。 “你是谁？”XCiyang从门口的猫眼看了一眼，确信没什么问题。“唉，吓死了……”边说着他打开了房门。 “这是怎么回事？”XCiyang问。 “只是出了点小问题，我也不知道为什么？早上四点的时候Genius_Z给我打来了电话，让我抓紧叫大家起来。” XCiyang说：“他昨天没睡觉吧？是在玩游戏？？” “这不是很重要，”Tommy_clas回应道。“回头，看看窗外。” 窗外漆黑一片，没有任何光线。 “这个亮度很不正常”XCiyang说。 “事实上没有亮度了，你是不是没睡醒？”Tommy_clas有些着急地说。“对了你的日期显示正常吗？” XCiyang没有说话，打了个手势便匆忙向外走。 “等等，你要干什么？”Tommy_clas立即询问道。“我跟你一起！” “先去看看这是怎么一回事，”XCiyang很烦。“真是蛤，莫名其妙的。” XCiyang走到了电梯口，按下了按钮。 他们住的是酒店的12楼，也是顶楼，电梯缓缓地从5层楼上升到了11层。 叮————，电梯门打开了，他和Tommy_clas走了进去。 “我觉得这样有点冒失，”Tommy_clas说。“这种情况可能不符合已有的科学知识。” “谁信这个？”XCiyang说。“宇宙的秘密都快要破解了，还有什么东西会拿我们开玩笑？” XCiyang从包里拿出了带有GPS定位装置的荧光棒：“来看看是什么情况。”他显得不怎么慌张：“还有几个人没有醒，发送紧急命令了吗？” “Genius_Z昨晚没有睡，找你的时候我刚刚起来，因为没确定什么情况所以就没有通知大家，”Tommy_clas回答他说。“应该都还没醒。” SRP是使用研究机构服务器搭建的IM（即时通讯软件），为了保护信息安全，他们都使用这个服务用于日常交流，并且其中内嵌了ArachnidaKing所开发的人工智能SAA，精通物理学，可以快速计算分析，平常也会和大家聊天，负责管理通讯系统和提供帮助。 Tommy_clas拿出了出手机检查消息： SRP(4条未读消息)9月31日4:27 Genius_Z：什么情况？到现在4点了没睡觉，窗外漆黑一片的？日期变成了2019/9/31？？？？ SAA：Genius_Z使用指令{声音通知}(Tommy_clas) Tommy_clas：我先去找XCiyang吧，他比较有经验 Tommy_clas：先别着急，没有别的异常情况吧 9月31日4:34 XCiyang：我和Tommy_clas先去检查一下情况，不用担心 Genius_Z：不通知大家吗？ ArachnidaKing：怎么都起的这么早，有什么事吗？ XCiyang：先冷静，我和Tommy_clas去检查情况了 先不要着急通__ 发送电梯平稳地下落，到达了1楼。 “这么早出来真的有点奇怪，”Tommy_clas收起手机自言自语。“啊？酒店门外是纯黑色的吗？” “走，我们过去。”XCiyang快步移向酒店前台。 “有人吗？”XCiyang说。 “……” “先看看门外”XCiyang回头对Tommy_clas说。 “没什么毛病，”Tommy_clas打开了手机上的GPS设备监测系统。“荧光棒的定位就显示在酒店内部。” “来试试，”XCiyang打开酒店大门把荧光棒向外一扔。荧光棒照亮了一小片区域，看起来没什么异样。“问题不大，查查这个地区的照明系统吧。” “艹，不对！”Tommy_clas惊叫起来。“你的荧光棒扔出大门所在平面的一刻，GPS信号立即消失了！” “嘶，可它不就在外面吗？看的见啊”XCiyang回答说。 “不要轻举妄动，先把大家都叫起来吧，”Tommy_clas沉着的说，“不要跨过酒店的大门！” “走，上楼。”Tommy_clas边说边拿出了手机。 SRP(1条未读消息)XCiyang：先冷静，我和Tommy_clas去检查情况了 9月31日4:38 Genius_Z：你们好了吗 /info urgent entity 立即到7楼会议__ 发送两个人快步走到了电梯口，Tommy_clas按下了上行按钮。 电梯显示屏幕的红色文字不停地变换着，光穿透着空气，灰尘粒子漂浮着。 “电梯有异常现象，”XCiyang说。“是随身物理现实检测器告诉我的，建议一会不要乘坐电梯。” “不过倒是没看出来有什么不对。”Tommy_clas回答道。 COSMOS-2.BRANCH1.A.D.2019.09.31.A.M.4:51 \\quad [数据删除]酒店会议室XCiyang打开了手机： SRP(11条未读消息)9月31日4:41 SAA：Tommy_clas使用指令{声音通知}[紧急](所有实体) Tommy_clas：立即到7楼会议室集合！ RiverFun：艹，起的太早了吧 Bj_2002：马上来…… Victor：不大行，出什么事了？ ArachnidaKing：SAA，能解释一下吗？ SAA：检测到空间发生超出人类原有认知的异常 ArachnidaKing：……太奇怪了 JuanFeng：这不可能？ Ctz:真的挺有意思的啊 9月31日4:48 Tommy_clas：没来的人呢？大家尝试联系一下。 为什么还有人没有来？是还__ 发送过了几分钟，在SRP中回应过的人陆续到达了现场。“清点一下还剩几个人没有来？”Tommy_clas发话了。 “不要等了，立刻行动，先去找他们！”JuanFeng提出建议。 “可以！”其他人说。 一行人迅速从楼梯前往12楼。 “为什么不走电梯？”Bj_2002说。 “先别管这些了，”Tommy_clas说。“现在情况很不明确，我们要选择风险比较小的方式行动。” COSMOS-2.BRANCH1.A.D.2019.09.31.A.M.5:02 \\quad [数据删除]酒店第12楼层“ColorfulMist？”Tommy_clas说。“你在干什么？” “……” 没有应答。 与ColorfulMist的联系失败。 Tommy_clas想起了文档里的一句话。 “破门！”他命令道。 虽然他们是物理科学家，但是Tommy_clas从收到那份不平常的文档开始，就为全组人员配备了特种装备和紧急情况下应对事件的工具。 对ColorfulMist的房间观察显示其房间没有入住过的迹象。 “判断人员ColorfulMist已损失”XCiyang说。 “好吧，”Genius_Z说。“现在这种shit事已经超出我的想象了。自己玩吧，我要出去转转。” “不要！”Tommy_clas说。 Genius_Z已经跑到了电梯边上。 “追不上了！”Bj_2002冷静的说。“先去找剩下两个人” “Taduro？还在吗？……？？？” “啊？”门内传来声音。“怎么都起得这么早？不睡觉……了吗！” “唉，”众人说。“快出来，出大事了！” “Asuldb？在不在？” “……” 没有应答。 与Asuldb的联系失败。 “强行进入！”Tommy_clas大声说。 对Asuldb的房间内部观察其呈现出酒店外部空间同样性质 停止对Asuldb房间的探索。 “判断人员Asuldb已损失”XCiyang说。 SAA发来警报：Genius_Z的GPS定位信号在$3s$前丢失，地点在酒店门口。 “尝试对Genius_Z进行无线电联系”XCiyang说。 SAA：与Genius_Z的联系失败。 “不如我们也出去玩玩？”ArachnidaKing说。“只是空间异常而已，不会有什么事。在这里能有什么进展，今天本来不是要工作的吗？” “你疯了吗？”Victor说。“这不是科学能解释的现象。” “是不是你……”Victor对Tommy_clas说。 “好吧，我把之前向你们隐瞒的事和你们大致讲一下”Tommy_clas长舒了一口气。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://x.lyxw.xyz/categories/杂谈/"}],"tags":[{"name":"科幻","slug":"科幻","permalink":"https://x.lyxw.xyz/tags/科幻/"}]},{"title":"Hexo博客搭建及Material主题使用指南","slug":"blog","date":"2019-08-16T10:37:19.000Z","updated":"2022-02-12T16:35:22.084Z","comments":true,"path":"2019/blog/","link":"","permalink":"https://x.lyxw.xyz/2019/blog/","excerpt":"更新于： A.D.2022.2.13 前端真好玩qvq","text":"更新于： A.D.2022.2.13 前端真好玩qvq 使用GitHub Pages搭建Hexo博客博客出现问题首先可以阅读文档，其次可以Google解决. 建议搭建完成以后首先看这个文档 Hexo中文文档 然后阅读主题的文档，这个主题的网页文档挂了，可以克隆repo的markdown源代码到本地查看 Step1 | 下载软件1.安装Git 2.安装Node.js Step2 | 创建GitHub账号请参考Hexo文档 1.注册GitHub账号 2.创建Github Pages仓库 3.配置SSH密钥 Github 生成SSH秘钥（详细教程） Step3 | 使用Git Bash进行搭建操作请参考Hexo文档 hexo init Step4 | 写作、美化及功能修改见下文 Markdown相关问题表格合并单元格markdown表格支持功能很少，合并单元格只能用HTML markdown可以直接插入HTML代码 用http://www.tablesgenerator.com/html_tables编辑可以直接生成HTML代码 插入视频在Bilibili、Youtube等网站可以直接获取视频外链的HTML代码，在markdown中插入即可，长宽可能需要调整 Material主题配置及修改记录这个主题一些好的教程 Hexo入坑教程-Material Aplayer克隆&lt;https://github.com/MoePlayer/APlayer&gt; 参考Aplayer项目文档进行配置即可 我的music.js从cdn仓库里找就行，一中午用手肝了1.5h粘出来的=_=（不怎么好写脚本，只挑了一部分vocaloid的歌，大部分都是中v。如果你喜欢中文vocaloid的话，可以看看（ live2d看板娘 [blogの搭建之next——ctz’s blog(https://ctz45562.github.io/2019/03/21/blog%E3%81%AE%E6%90%AD%E5%BB%BA/) 有一些问题还参考了github-repo的README. git clone https://github.com/stevenjoezhang/live2d-widget 文件夹live2d-widget放到\\themes\\主题名称\\source下,打开文件夹里的autoload.js修改为 const live2d_path = &quot;/live2d-widget/&quot;; 这个文件夹的名字可以自行修改. 打开\\themes\\主题名称\\layout\\_layout.swig/ejs这个文件 在&lt;body&gt;内的开头添加 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;/&gt; 在&lt;/body&gt;上方添加 &lt;script src=&quot;/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 不同之处可以自行修改layout.ejs文件 黑幕效果 如何实现黑幕 添加CSS //黑幕 .heimu,.heimu a{ background-color: #252525; color:#252525; text-shadow: none; }::selection{ background:#9ab0c0; color:#fff; } //鼠标悬停 .heimu:hover,.heimu:hover a{ transition:color .13s linear; color:#fff; } 使用直接插入HTML &lt;span class=&#39;heimu&#39; title=&#39;你知道的太多了&#39;&gt;黑幕测试&lt;/span&gt; 效果 黑幕测试 添加Gitalk评论主题实现好了一些评论的配置，具体看主题的文档即可。 Gitalk 和 Gitment 一样都是一个基于 GitHub Issue 的评论系统。在完成 GitHub Oauth App 的申请并获取 key 后，在主题配置文件中填入 gitalk_repo gitalk_owner gitalk_client_id gitalk_client_secret 参数即可。 在主题配置文件里修改这几项即可，repo可以用博客的，后两项需要用到GitHub Oauth App的API，搜索引擎自行解决即可。 comment: use: gitalk gitalk_repo: # git repo of the hexo gitalk_owner: # git repo&#39;s owner gitalk_client_id: # github app client id gitalk_client_secret: # github app client secret GitHub限制label长度gitalk无法创建issue GitHub限制label长度导致gitment/gitalk可能无法创建issue #622 对于全新安装有如下解决方案，解决方案如下：hexo根目录\\themes\\material\\layout\\_widget\\comment\\gitalk在此目录下编辑main.ejs文件在其中新增如下内容 &lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt; 在gittalk下增加id属性，增加后完整文件内容如下： &lt;!-- Gitalk 评论框 --&gt; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var gitalk = new Gitalk({ clientID: &#39;&lt;%= theme.comment.gitalk_client_id %&gt;&#39;, clientSecret: &#39;&lt;%= theme.comment.gitalk_client_secret %&gt;&#39;, repo: &#39;&lt;%= theme.comment.gitalk_repo %&gt;&#39;, owner: &#39;&lt;%= theme.comment.gitalk_owner %&gt;&#39;, admin: [&#39;&lt;%= theme.comment.gitalk_owner %&gt;&#39;], id: md5(window.location.pathname), // facebook-like distraction free mode distractionFreeMode: false }) gitalk.render(&#39;gitalk-container&#39;) &lt;/script&gt; Blog内容搜索安装hexo-generator-search插件 修改主题配置文件 search: use: local swiftype_key: 修改hexo配置文件： search: path: search.xml field: all markdown文件名大小写问题参考：Hexo 常见问题 | py’s blog 问题：当在本地改变md文件的大小写时，部署到GitHub 上后，改变了文件名的博客不能被访问。原因：Hexo默认的git操作会忽略大小写。解决： 修改根目录下.deploy_git/.git/config文件，将ignorecase的值由true改为false 删除.deploy_git目录下除.git目录外的其他文件 cd到.deploy_git目录下，手动做一次推送git add . git commit -m &quot;delete all hexo generated files&quot; git push 重新生成并部署hexo g hexo d CSS的修改文章框体透明打开Blog\\themes\\hexo-theme-material-1.5.6\\source\\css打开style.min.css搜索#scheme-Paradox .material-layout .mdl-card的第一项，在其中添加background-color: rgba(255,255,255,0.8) !important; Tag颜色及悬停颜色.material-tagscloud a{ background-color: rgba(255,255,255,.9); text-decoration:none; padding: 1px 9px; margin: 9px 1px; line-height: 40px; white-space: nowrap; transition: .6s; opacity: .85; } .material-tagscloud a:hover{ transition: .6s; opacity: 1; background: rgba(156,241,150,.7) !important; box-shadow: 0 2px 2px 0 rgba(0,0,0,.14), 0 3px 1px -2px rgba(0,0,0,.2), 0 1px 5px 0 rgba(0,0,0,.12); } copyright位置#scheme-Paradox .mdl-mini-footer--right-section { margin-right: 25px; } #scheme-Paradox #copyright { margin-left: auto; margin-right: 25px; text-align: center; } MathJax主题配置文件中的mathjax 引用cdnhttps://cdn.bootcss.com/mathjax/2.7.0/MathJax.js$\\LaTeX$换行因为某些网页渲染的原因把\\\\换为\\\\\\\\即可. 修改hexo的渲染规则可以避免LaTex代码出现问题： https://docs.nexmoe.com/hexo/math.html#%E4%BD%BF%E7%94%A8kramed%E4%BB%A3%E6%9B%BF-marked MathJax测试 \\begin{array}{|rc|} \\hline \\verb+\\color{black}{text}+ & \\color{black}{text} \\\\ \\verb+\\color{gray}{text}+ & \\color{gray}{text} \\\\ \\verb+\\color{silver}{text}+ & \\color{silver}{text} \\\\ \\verb+\\color{white}{text}+ & \\color{white}{text} \\\\ \\hline \\verb+\\color{maroon}{text}+ & \\color{maroon}{text} \\\\ \\verb+\\color{red}{text}+ & \\color{red}{text} \\\\ \\verb+\\color{yellow}{text}+ & \\color{yellow}{text} \\\\ \\verb+\\color{lime}{text}+ & \\color{lime}{text} \\\\ \\verb+\\color{olive}{text}+ & \\color{olive}{text} \\\\ \\verb+\\color{green}{text}+ & \\color{green}{text} \\\\ \\verb+\\color{teal}{text}+ & \\color{teal}{text} \\\\ \\verb+\\color{aqua}{text}+ & \\color{aqua}{text} \\\\ \\verb+\\color{blue}{text}+ & \\color{blue}{text} \\\\ \\verb+\\color{navy}{text}+ & \\color{navy}{text} \\\\ \\verb+\\color{purple}{text}+ & \\color{purple}{text} \\\\ \\verb+\\color{fuchsia}{text}+ & \\color{magenta}{text} \\\\ \\hline \\end{array}自定义页脚sns链接 Hexo Material主题之 footer SNS定制 svg图标如果在CSS里写实在还有问题放一个文件直接引用也可以. sns换到右边把ejs文件里的left改为right即可. Licenselicense: ‘本文由 Name 原创，采用保留署名-非商业性使用-禁止演绎 4.0-国际许可协议‘ 鼠标点击烟花特效themes/主题名称/source/js/src新建fireworks.js文件 &quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)}&quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)}; 在themes/主题名称/layout/_layout.swig/ejs的&lt;/body&gt;上方添加 &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt; 一些主题的小问题独立页面toc不是默认为true的，需要手动开 toc: true 独立页面的license会在最后加上index.html，点击这个链接会导致gitalk再次创建issue，目前没有去解决. 页脚时间统计与动态效果直接找出来我的博客页面上的js插入项，然后使用即可 RSS订阅参考博客文档在_config.yml中打开选项即可 jsDelivr加速js、css文件1.博客内部的文件：参考博客文档配置jsdelivr选项即可 2.手动添加的文件：手动上传至cdn仓库，并修改链接 天坑咕了很久以后就会全忘了，再改Blog就凉了，有空就填一些。 修改后没记录代码高亮 功能页面 | 独立页面 material图标 想修改的功能插入pdf 代码复制功能 鼠标特效fireworks遮挡部分组件 文章头图自定义 hexo-addlink 文章置顶 字体，代码字体 背景js动态效果 Site Information npm install hexo-math —save Git指令常用指令克隆 git clone repo 克隆分支 git clone -b branch_name repo 上传文件 git add . git commit -m &#39;update_name&#39; git push origin branch_name Hexo指令 hexo init hexo clean g d hexo s hexo new name categories 分支https://zdran.com/20180326.html 创建源文件git目录 git init git remote add origin https://github.com/xx/xx.github.io // 填入你的repo地址 创建分支 git checkout -b branch_name git add . git commit -m &#39;add branch_name&#39; git push origin branch_name 切换分支 git checkout branch_name","categories":[{"name":"技术","slug":"技术","permalink":"https://x.lyxw.xyz/categories/技术/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://x.lyxw.xyz/tags/Blog/"}]},{"title":"「FFT/NTT」「多项式」","slug":"FFT","date":"2019-08-15T12:16:04.000Z","updated":"2019-10-17T08:40:08.153Z","comments":true,"path":"2019/FFT/","link":"","permalink":"https://x.lyxw.xyz/2019/FFT/","excerpt":"Update on A.D.2019-08-15 必忘原理的FFT","text":"Update on A.D.2019-08-15 必忘原理的FFT 测试一下视频，然而貌似只有bilibili的外链比较好总不能放Youtube？，然而鬼畜的二维码与顶部链接比前几年在mcbbs看的时候烂多了。 在2019年8月15日，终于看懂了FFT的推导过程。 首先是FFT的板子，这个写法其实很优美记不住的。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;complex&gt; #define R register using namespace std; const int N = 4.2e6; const double PI = acos(-1); int n, r[N]; class C { public: double r, i; C() { r = i = 0; } C(R double x, R double y) { r = x; i = y; } C operator + (R C&amp; x) { return C(r+x.r, i+x.i); } C operator - (R C&amp; x) { return C(r-x.r, i-x.i); } C operator * (R C&amp; x) { return C(r*x.r-i*x.i, r*x.i+i*x.r); } void operator += (R C&amp; x) { r += x.r; i += x.i; } void operator *= (R C&amp; x) { R double t = r; r = r*x.r-i*x.i; i = t*x.i+i*x.r; } }f[N], g[N]; inline void FFT(R C *a, R int op) { R C W, w, t, *a0, *a1; R int i, j, k; for (i = 0; i &lt; n; ++i) if (i &lt; r[i]) t = a[i], a[i] = a[r[i]], a[r[i]] = t; for(i = 1; i &lt; n; i &lt;&lt;= 1) for(W = C(cos(PI/i), sin(PI/i) * op), j = 0; j &lt; n; j += i &lt;&lt; 1) for(w = C(1, 0), a1 = i + (a0 = a + j), k = 0; k &lt; i; ++k, ++a0, ++a1, w*=W) t = *a1 * w, *a1 = *a0 - t, *a0 += t; } int main() { R int m, i, l = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(i = 0; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;f[i].r); for(i = 0; i &lt;= m; i++) scanf(&quot;%lf&quot;, &amp;g[i].r); for(m += n, n = 1; n &lt;= m; n &lt;&lt;= 1, ++l); for(i = 0; i &lt; n; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)); FFT(f, 1); FFT(g, 1); for(i = 0; i &lt; n; ++i) f[i] *= g[i]; FFT(f, -1); for(i = 0; i &lt;= m; ++i) printf(&quot;%.0lf &quot;, fabs(f[i].r) / n); return 0; } 咕，马上补.","categories":[{"name":"数学","slug":"数学","permalink":"https://x.lyxw.xyz/categories/数学/"}],"tags":[{"name":"FFT","slug":"FFT","permalink":"https://x.lyxw.xyz/tags/FFT/"},{"name":"NTT","slug":"NTT","permalink":"https://x.lyxw.xyz/tags/NTT/"}]},{"title":"「动态规划」","slug":"dp","date":"2019-08-14T07:04:06.000Z","updated":"2019-10-17T08:39:47.793Z","comments":true,"path":"2019/dp/","link":"","permalink":"https://x.lyxw.xyz/2019/dp/","excerpt":"Update on A.D.2019-10-17 推不出的DP方程","text":"Update on A.D.2019-10-17 推不出的DP方程 随意记点动态规划的方程，大概是NOIP难度的。 Problem水题LuoguP1472 奶牛家谱 Cow Pedigrees题意：有$n$个结点$k$层的二叉树结构个数，树只能有$2$个儿子或$0$个儿子。 设$dp[n][k]$为有$n$个结点不到$k$层的答案，则答案容斥一下为$dp[n][k]-dp[n][k-1]$，转移从下把两棵树连接到上一层结点，枚举$t$为左子树节点个数，则右子树为$总结点个数-t-1$(1是减掉根)，乘法原理把两个乘起来，方程为 dp[i][j]=\\sum dp[t][j-1]\\times dp[i-t-1][j-1]正常题[SDOI2011]消耗战题意：给定$n$个点有边权的树，割断边花费边权，求使$k$个点与$1$点不连通的最小花费。 要用虚树做，写一下方程。 设$dp[n]$为使以$n$为结点的子树内关键点都不与$n$联通的最小花费，方程为 dp[u]=dp[u]+ \\begin{cases} \\min(dp[v],dist_{u,v})& \\text{v不是关键点}\\\\ dist_{u,v}& \\text{v是关键点} \\end{cases}[ZJOI2010]排列计数题意：求一个$1\\sim n$的排列$P_i$使$ 1\\leq i \\leq n$时$P_i&gt;P_{i/2}$的方案数。 直接做没什么思路，可以想一下除二的关系可以是二叉树，于是换到树上来做，求$n$个节点的二叉树满足小根堆性质树的个数。 设$dp[i]$表示以$i$为根的子树内满足小根堆性质的方案数，$s[i]$为树结点数，提前把一些越界的初值设为$1$以免判断，转移时组合数算一下选给左子树的点，记得减去根节点，乘一下两颗子树的方案数就ok了，组合数要用lucas，方程 dp[i]=C_{s[i]-1}^{s[i\\times 2]}dp[i\\times 2]dp[i\\times 2+1][SCOI2008]奖励关题意：$m$种物品，给你n次随机在$1\\sim m$间的物品，每种物品有价值并且选这种物品需要你在前$n-1$次把集合$S$内的物品种类都选过一次才可以选。 显然$m$非常小，那么求期望直接枚举就可以了，这样就好做了，然后在考虑一下如果顺推的话需要保证$S$的合法性，这个比较难处理，那么逆推显然更好写。设$dp[i][S]$表示取前$i-1$次的状态为$S$是期望的最大值，$pre[i]$为第$i$种物品的前提集合，方程枚举第i个选第k种 dp[i][S]=dp[i][S]+ \\begin{cases} \\max(dp[i+1][S],dp[i+1][S|(1","categories":[{"name":"算法","slug":"算法","permalink":"https://x.lyxw.xyz/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://x.lyxw.xyz/tags/动态规划/"}]},{"title":"从零开始的C++学习","slug":"C++","date":"2019-08-09T08:04:47.000Z","updated":"2022-04-01T14:10:32.542Z","comments":true,"path":"2019/C++/","link":"","permalink":"https://x.lyxw.xyz/2019/C++/","excerpt":"更新于：A.D.2019-10-17 Visual Studio过于复杂","text":"更新于：A.D.2019-10-17 Visual Studio过于复杂 装了一下2017年装过一次却怎么没用过的Visual Studio，计划学习C++的OOP及C++11的语法后继续学习C++MFC. 文档：cppreference.com 资料：C++教程 书籍：《C++ Primer Plus》 C++ OOP类 对象class x{...};定义一个类 x xxx;声明一个类型为Hf的对象 访问数据成员用.即可 成员函数类定义内部的成员函数默认inline 在类的外部定义函数的话用范围解析运算符::定义成员函数 数据类型 类名::函数名() {} 调用函数用. 即可 类访问修饰符public公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值 private私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。 protected保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。 继承时，使用哪种修饰符父类便继承到哪一部分中 1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问； 2.protected 成员可以被派生类访问。 类构造函数 &amp; 析构函数构造函数就定义一个函数名为类名没有数据类型的函数，每次创建类的新对象时执行，默认是存在构造函数，所以如果定义了有参数的构造函数，一定注意要再定义一个无参数无内容的构造函数，不然不用带参数的构造函数用默认创建对象的话会出错.像这样玩就行，赋值可以像这样搞. struct node { int o, l, r, t; node() {} node(int o, int l, int r): o(o), l(l), r(r), t(ask(l, r)) {} friend bool operator &lt; (const node&amp; a, const node&amp; b) { return sum[a.t] - sum[a.o - 1] &lt; sum[b.t] - sum[b.o - 1]; } }; 析构函数名字是这样的~类名，这个函数再删除对象时执行.总之就是一个创建，一个删除时执行。","categories":[{"name":"编程","slug":"编程","permalink":"https://x.lyxw.xyz/categories/编程/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://x.lyxw.xyz/tags/C/"}]},{"title":"「数论」","slug":"number_theory","date":"2019-08-09T06:37:38.000Z","updated":"2020-07-11T23:09:07.593Z","comments":true,"path":"2019/number_theory/","link":"","permalink":"https://x.lyxw.xyz/2019/number_theory/","excerpt":"Update on A.D.2019-08-09 只会GCD","text":"Update on A.D.2019-08-09 只会GCD 取模(a+b) \\bmod p=(a\\bmod p+b\\bmod p)\\bmod p​(a-b) \\bmod p=(a\\bmod p-b\\bmod p+p)\\bmod p​(a\\times b) \\bmod p=(a\\bmod p\\times b\\bmod p)\\bmod p​求$\\dfrac{a}{b}\\bmod p​$时,求$b^{-1}​$使$b*b^{-1}\\equiv1\\pmod p​$即$b​$的逆元 有\\dfrac{a}{b}\\bmod p=a\\times b^{-1}\\bmod p 费马小定理定理：当$p​$是质数时$a^{p-1}\\equiv 1\\pmod p​$ 逆元：由$a^{p-1}\\equiv 1\\pmod p​$得$a\\times a^{p-2}\\equiv 1\\pmod p​$ 即$a^{p-2}$是$a$在模$p$意义下的逆元 欧拉定理若$gcd(a,p)=1$则$a^{\\varphi(p)}\\equiv1\\pmod n$ 当$p$是质数时$\\varphi(p)=p-1$ 即$a^{p-1}\\equiv1\\pmod n$即费马小定理 GCD EXGCD#define ll long long ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; } void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) { if(!b) x = 1, y = 0; else exgcd(b, a % b, y, x), y -= a / b * x; } $gcd$用来求解$a，b$的最大公约数 $lcm(a,b)=\\dfrac{a\\times b}{gcd(a,b)}​$，lcm是最大公约数 $exgcd$用来求解$ax+by=gcd(a,b)$，证明大概是化式子构造递归的解法，反正看了也早晚会忘就是了逃 $exgcd$还可以求解$ax\\equiv b\\pmod p​$形式的同余方程 $exgcd(a,p,x,y)$求出来的$x$就是$a$关于$p$的逆元 CRT exCRT求解一个同余方程组 \\begin{cases} x \\equiv a_1 \\pmod {m_1} \\\\ x \\equiv a_2 \\pmod {m_2} \\\\ x \\equiv a_n \\pmod {m_n} \\end{cases}两种东西都可以通过exgcd两两合并同余方程求解，不过CRT可以直接构造出答案。 CRT求解的$p​$是质数，exCRT的不是，都可以用exgcd合并做。 推导参考这个blog：扩展欧几里得算法与中国剩余定理 CRT直接构造的解： 令$M=\\prod m_i, M_i=\\frac M{m_i}​$，$t_i​$为$M_i​$在模$m_i​$意义下的逆元 方程组的解为x \\equiv \\sum_{i=1}^na_it_iM_i \\pmod M​ 筛法求$n$是不是素数直接枚举$1$到$\\sqrt{n}$试除 埃筛 for(int i = 2; i &lt;= N; i++) if(!vis[i]) { prime[++cnt] = i; for(int j = 1; i * j &lt;= N; j++) vis[i * j] = 1; } 线筛 for(int i = 2; i &lt;= N; i++) { if(!vis[i]) prime[++cnt] = i; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; j++) { vis[i * prime[j]] = 1; if(i % prime[j] == 0) break; } }","categories":[{"name":"数学","slug":"数学","permalink":"https://x.lyxw.xyz/categories/数学/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://x.lyxw.xyz/tags/数论/"}]},{"title":"Chrome浏览器 | 插件与设置","slug":"chrome","date":"2019-06-04T09:54:25.000Z","updated":"2022-02-12T18:02:14.329Z","comments":true,"path":"2019/chrome/","link":"","permalink":"https://x.lyxw.xyz/2019/chrome/","excerpt":"Update on A.D.2019-06-04","text":"Update on A.D.2019-06-04 下载安装下载地址：Google Chrome 网络浏览器 插件Bookmarkie 插件栏弹出收藏夹，可搜索 书签侧边栏 侧边栏收藏夹 Wrona History Menu 插件栏弹出历史记录，最近关闭 Checker Plus for Gmail™ 查看Google邮箱 Click and Save 快捷键点击存图 CSS Peeper 抓取页面样式 Earth View from Google Earth 新页标签Google地球 Color Tab 新页标签配色设计 Save All Resources 下载控制台Sources全部文件 Steam Inventory Helper steam网页版市场工具 Speedtest by Ookla 墙外测速 Stylus 替换CSS样式 Tampermonkey 网页js脚本 Yet another flags 查看网页ip 沙拉查词 划词翻译 ImageAssistant 下载网页图片 Yet Another Drag and Go 四方向拖拽搜索，链接拖拽打开 pakku bilibili弹幕过滤 Aerys 插件栏查看窗口标签 操作左键单击 = 在当前窗口打开目标网页 Shift + 左键单击 = 在新窗口打开目标网页 Ctrl + 左键单击 = 在新标签页打开目标网页 Ctrl + Shift + T = 打开上一个关闭的标签页 Ctrl + Shift + B = 显示书签栏 Ctrl + D = 为此页添加书签 Ctrl + H = 历史记录 设置不在设置里出现的控制选项： chrome://flags 查看chrome账号同步情况： chrome://sync 地址栏中使用的搜索引擎改为google.com.hk 网页长截图1.按F12 2.按Ctrl + Shift + P 3.输入Capture full size screenshot并回车 截取手机版长图在1、2操作之间，按下Ctrl + Shift + M 选区截图1.按F12 2.按Ctrl + Shift + C 3.选中区域后去输入Capture node screenshot并回车","categories":[{"name":"计算机","slug":"计算机","permalink":"https://x.lyxw.xyz/categories/计算机/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://x.lyxw.xyz/tags/Chrome/"}]},{"title":"科学上网 | GFW与SSR简介","slug":"GFW","date":"2019-06-01T13:52:50.000Z","updated":"2022-02-08T15:24:34.023Z","comments":true,"path":"2019/GFW/","link":"","permalink":"https://x.lyxw.xyz/2019/GFW/","excerpt":"Update on A.D.2019-05-31 Across the Great Wall we can reach every corner in the world.","text":"Update on A.D.2019-05-31 Across the Great Wall we can reach every corner in the world. 在配置开发环境、依赖项等过程中，不可避免的会遇到无法下载、下载速度过慢的情况。 在编程学习中，如果可以使用Google、StackOverflow，往往可以解决很多问题。 本文简要介绍GFW和常见的科学上网技术。 删减了大部分内容，推荐观看电丸科技AK制作的https://www.youtube.com/watch?v=XKZM_AjCUr0&amp;list=PLqybz7NWybwUgR-S6m78tfd-lV4sBvGFG 这一系列视频，推荐简单学习计算机网络知识。 推荐阅读： 中国的互联网 _ neoFelhz’s Blog[已失效] 浅谈vpn、vps、Proxy以及shadowsocks之间的联系和区别 墙与纸飞机 什么是 SSR、V2ray、Trojan、Clash，什么是机场？ vpn工作原理和搭建方法 代理，网关，隧道，有什么区别与联系？ 什么是GFWGFW防火长城 - 维基百科，自由的百科全书 线路拓扑： 一些名词虚拟专用服务器 - 维基百科，自由的百科全书 代理服务器 - 维基百科，自由的百科全书 SOCKS - 维基百科，自由的百科全书 IPv6 - 维基百科，自由的百科全书 Secure Shell - 维基百科，自由的百科全书 超文本传输安全协议 - 维基百科，自由的百科全书 点对点网络 - 维基百科，自由的百科全书 HTTP状态码 - 维基百科，自由的百科全书 中间人攻击 - 维基百科，自由的百科全书 如何科学上网VPN虚拟专用网 - 维基百科，自由的百科全书 虚拟私人网络（英语：Virtual Private Network，缩写：VPN）是一种常用于连接 中、大型企业或团体与团体间的私人网络的通讯方法。它利用隧道协议（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果，这种技术可以用 不安全的网络（例如：互联网）来发送可靠、安全的消息。 隧道协议 - 维基百科，自由的百科全书 SS | SSR推荐阅读：浅谈VPN和SS/SSR的区别 简介全称Shadowsocks | ShadowsocksR SS的作者Clowwindy删除了GitHub的源代码，SSR是breakwa11在SS基础上开发的软件，后作者在GitHub上将其源代码删除，SS与SSR开发时皆开源，原作者停止维护后有人开发并维护与更新至今。 SS官网 GitHub SSR已经删除的主页（web archive）：breakwa11.github.io GitHub 简单了解一下：Shadowsocks - 维基百科，自由的百科全书 界面： 下载有Windows、Linux、Android、IOS、Macos等系统及各种在源软件基础上开发的很多版本。 一个仍在维护的Windows版本： https://github.com/shadowsocksrr/shadowsocksr-csharp/releases 一些下载地址及版本介绍： SS/SSR 简介 教程优先阅读[ShadowsocksR] 大概是萌新也看得懂的SSR功能详细介绍&amp;使用教程 Windows的ss客户端 · 珂学上网相关知识总结 机场浅谈部分机场（SS/SSR提供商）的使用感受 使用技巧ShadowsocksR 客户端 各种隐藏使用技巧说明 ShadowsocksR简明使用教程 小飞机的颜色 颜色 全局 PAC 直连 负载均衡 白 √ √ 青 √ 黄 √ √ 绿 √ 蓝 √ 紫 √ √ 快捷键对小飞机托盘图标操作 操作 效果 左键单击 弹出编辑服务器窗口 中键单击 弹出服务器连接统计窗 右键单击 弹出菜单 SSTap软件介绍：SSTap全称SOCKSTap, 是一款利用虚拟网卡技术在网络层实现的代理工具。SSTap能在网络层拦截所有连接并转发给HTTP，SOCKS4，5，SHADOWSOCKS代理.而无需对被代理的应用程序做任何修改或设置。它能同时转发TCP,UDP数据包，它非常适合于游戏玩家使用。 搭建SSR服务购买VPS，部署Linux发行版和SSR服务端（没有搭建博客、使用服务器等用途不推荐） Trojantrojan-gfw / trojan ClashDreamacro / clash V2Ray推荐阅读：浅谈vpn、vps、Proxy以及shadowsocks之间的联系和区别 V2Ray 是一个模块化的代理软件包，它的目标是提供常用的代理软件模块，简化网络代理软件的开发。 简单来说，它就是一个模块化代理，可以用来科学上网，支持多平台。 Project V · Project V 官方网站 Github TLSBrooktxthinking / brook Tortorproject 一些工具一个Chrome的插件 Yet another flags 可以很方便的显示服务器IP地址和地理位置。效果： 常用互联网服务无法访问websiteGoogle Youtube Facebook Twitter Wikipedia(zh_CN) IMTelegram 正常访问websiteQuora GitHub","categories":[{"name":"计算机","slug":"计算机","permalink":"https://x.lyxw.xyz/categories/计算机/"}],"tags":[{"name":"GFW","slug":"GFW","permalink":"https://x.lyxw.xyz/tags/GFW/"},{"name":"SSR","slug":"SSR","permalink":"https://x.lyxw.xyz/tags/SSR/"}]}]}